if (document.querySelectorAll("canvas").length > 1) {
  document.querySelectorAll("canvas")[0].parentElement.children[1].remove()
} //inject Sprites into the game screen by @decmant

let gamecan = document.querySelector("canvas")

let canvas = document.createElement("canvas")

canvas.height = gamecan.height

canvas.width = gamecan.width

canvas.style.height = gamecan.style.height

canvas.style.width = gamecan.style.width

canvas.style.position = "relative"

canvas.style.top = `${0 - Number(gamecan.style.height.match(/\d*/))}px`

canvas.style.left = `0px`

gamecan.parentElement.append(canvas)

let ctx = canvas.getContext("2d")

sprite.visible = false

let lastFrameTime = performance.now()

let fps = 0

let smoothFPS = 0

function updateSkyBox() {
  switch (level) {
    case levels.castle_grounds:
      //Credits: https://www.textures-resource.com/nintendo_64/mario64/texture/1315/
      skybox.src = "https://i.postimg.cc/s2J6Lz4J/castle-grounds.png"
      break
  }
}

const screenDimensions = {
  width: 480,

  height: 360,

  halfwidth: 240,

  halfheight: 180,
}

let zBuffer = new Float32Array(screenDimensions.width * screenDimensions.height)

enum levels {
  castle_grounds,

  inside_castle,
}

let level = levels.castle_grounds

let skybox = new Image()

updateSkyBox()

const camera = {
  x: 0,

  y: 7,

  z: -12,

  yaw: 0,

  pitch: 0,
}

let horizontalSpeed = 0

let playerRotation = 0

const moveSpeed = 0.1

const rotationSpeed = -2

const projectionDistance = 1

class Vector3 {
    x: number
    y: number
    z: number
    constructor(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    subtract(v: any) {
        return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);
    }
    cross(v: any) {
        return new Vector3(
            this.y * v.z - this.z * v.y,
            this.z * v.x - this.x * v.z,
            this.x * v.y - this.y * v.x
        );
    }
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    normalize() {
        const mag = this.magnitude();
        return mag === 0 ? new Vector3(0, 0, 0) : new Vector3(this.x / mag, this.y / mag, this.z / mag);
    }
}

console.log("118")

// Hilfsfunktion zur Normalenberechnung (angenommen, diese existiert)
function calculateNormal(v1: any, v2: any, v3: any) {
    const edge1 = v2.subtract(v1);
    const edge2 = v3.subtract(v1);
    return edge1.cross(edge2).normalize();
}

// RGB (0-1) zu Hex String Konverter (angenommen, diese existiert)
function rgbToHex(r: any, g: any, b: any) {
    const toHex = (c: any) => {
        const hex = Math.floor(c * 255).toString(16);
        return hex.length === 1 ? "0" + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

// Alpha (0-1) zu Hex String Konverter für RGBA (optional, falls setPixel das verarbeiten kann)
function rgbaToHex(r: any, g: any, b: any, a: any) {
     const toHex = (c: any) => {
        const hex = Math.floor(c * 255).toString(16);
        return hex.length === 1 ? "0" + hex : hex;
     };
     const toAlphaHex = (a: any) => {
         const hex = Math.floor(a * 255).toString(16);
         return hex.length === 1 ? "0" + hex : hex;
     }
     // RGBA im Format #RRGGBBAA ist weniger verbreitet im Web als rgba()
     // Rückgabe als RGBA-String für Canvas fillStyle ist einfacher
     return `rgba(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)}, ${a})`;
}


// Interface für UV Koordinaten
interface UV {
    u: number;
    v: number;
}

// Struktur zum Speichern von Pixeldaten einer Textur
interface TextureData {
    width: number;
    height: number;
    data: Uint8ClampedArray; // Pixeldaten (R, G, B, A für jeden Pixel)
}

class Triangle {
    vertices: [Vector3, Vector3, Vector3]; // Original 3D vertices
    uvs: [UV | null, UV | null, UV | null]; // Original UV coordinates
    color: string; // Solide Farbe (Fallback)
    normal: Vector3; // Normale
    texture: TextureData | undefined; // Referenz zu den geladenen Texturdaten
    materialAlpha: number; // Material Dissolve/Alpha Wert (d)

    constructor(
      v1: Vector3, v2: Vector3, v3: Vector3,
      uv1: UV | null = null, uv2: UV | null = null, uv3: UV | null = null,
      color: string = "white",
      textureData: TextureData | undefined = undefined,
      materialAlpha: number = 1.0 // Füge Material Alpha hinzu
    ) {
        this.vertices = [v1, v2, v3];
        this.uvs = [uv1, uv2, uv3];
        this.color = color;
        this.normal = calculateNormal(v1, v2, v3);
        this.texture = textureData;
        this.materialAlpha = materialAlpha; // Speichere Material Alpha
    }
}

function setPixel(x: any, y: any, z: any, color: any) {
  if (
    x < 0 ||
    y < 0 ||
    x >= screenDimensions.width ||
    y >= screenDimensions.height
  )
    return
  const index = y * screenDimensions.width + x
  if (z < zBuffer[index]) {
    zBuffer[index] = z
    ctx.fillStyle = color
    ctx.fillRect(x, y, 1, 1)
  }
}

const loadedTextures: { [key: string]: TextureData } = {};

// Funktion zum asynchronen Laden einer Textur und Lesen ihrer Pixeldaten
function loadTexture(url: string): Promise<TextureData> {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            // Zeichne das Bild in ein temporäres Canvas, um Pixeldaten zu extrahieren
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            if (!tempCtx) {
                 reject("Could not get 2D context from temporary canvas.");
                 return;
            }
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            tempCtx.drawImage(img, 0, 0);

            try {
                const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
                const textureData: TextureData = {
                    width: img.width,
                    height: img.height,
                    data: imageData.data
                };
                loadedTextures[url] = textureData; // Speichere die extrahierten Daten
                resolve(textureData);
            } catch (e) {
                console.error("Fehler beim Extrahieren der Texturdaten:", url, e);
                reject(e);
            }
        };
        img.onerror = (err) => {
            console.error("Fehler beim Laden der Texturdatei:", url, err);
            reject(err);
        };
        img.crossOrigin = ''; // Wichtig für CORS, wenn Texturen von anderer Domain geladen werden
        img.src = url;
    });
}

function getPixelColorFromData(textureData: TextureData, u: number, v: number): { r: number; g: number; b: number; a: number } {
    // Klemme U,V an den Bereich [0, 1]
    const clampedU = Math.max(0, Math.min(1, u));
    const clampedV = Math.max(0, Math.min(1, v));

    // Konvertiere UV [0, 1] zu Pixelkoordinaten [0, width/height - 1]
    // Math.floor ist wichtig, um zu einem spezifischen Pixel zu kommen
    const textureX = Math.floor(clampedU * (textureData.width - 1));
    const textureY = Math.floor(clampedV * (textureData.height - 1));

    // Berechne den Index im 1D Array (RGBA)
    const index = (textureY * textureData.width + textureX) * 4;

    // Stelle sicher, dass der Index gültig ist
    if (index < 0 || index >= textureData.data.length) {
         console.warn("Ungültiger Texturdaten-Index:", index, "für UV:", u, v);
         return { r: 0, g: 0, b: 0, a: 0 }; // Schwarzes transparentes Pixel bei Fehler
    }

    return {
        r: textureData.data[index],
        g: textureData.data[index + 1],
        b: textureData.data[index + 2],
        a: textureData.data[index + 3] // Alpha Wert (0-255)
    };
}

console.log("273")

function project(vertex: Vector3, originalUv: UV | null = null): { x: number; y: number; z: number; u: number | null; v: number | null } | null {
   let worldX = vertex.x - camera.x;
   let worldY = vertex.y - camera.y;
   let worldZ = vertex.z - camera.z;

    const yawInRadians = camera.yaw;
    const cosYaw = Math.cos(yawInRadians);
    const sinYaw = Math.sin(yawInRadians);
    const rotatedX = cosYaw * worldX + sinYaw * worldZ;
    const rotatedZ = -sinYaw * worldX + cosYaw * worldZ;
    worldX = rotatedX;
    worldZ = rotatedZ;

    const pitchInRadians = camera.pitch;
    const cosPitch = Math.cos(pitchInRadians);
    const sinPitch = Math.sin(pitchInRadians);
    const rotatedY = cosPitch * worldY - sinPitch * worldZ;
    const rotatedZ2 = sinPitch * worldY + cosPitch * worldZ;
    worldY = rotatedY;
    worldZ = rotatedZ2;


   if (worldZ <= 0.95) {
       return null;
   }

   const screenX = (projectionDistance * worldX) / worldZ;
   const screenY = (projectionDistance * worldY) / worldZ;

   const aspectRatio = canvas.width / canvas.height;
   const canvasX = canvas.width / 2 + screenX * canvas.width / 2;
   const canvasY = canvas.height / 2 - screenY * canvas.height / 2 * aspectRatio;

   return {
       x: canvasX,
       y: canvasY,
       z: worldZ,
       u: originalUv ? originalUv.u : null,
       v: originalUv ? originalUv.v : null
   };
}
console.log("316")
function drawTriangleProjected(triangle: Triangle) {
  const projectedVertices = triangle.vertices.map(project)
  drawLine(
    Math.round(projectedVertices[0].x),
    Math.round(projectedVertices[0].y),
    Math.round(projectedVertices[1].x),
    Math.round(projectedVertices[1].y),
    projectedVertices[0].z,
    triangle.color,
  )
  drawLine(
    Math.round(projectedVertices[1].x),
    Math.round(projectedVertices[1].y),
    Math.round(projectedVertices[2].x),
    Math.round(projectedVertices[2].y),
    projectedVertices[1].z,
    triangle.color,
  )
  drawLine(
    Math.round(projectedVertices[2].x),
    Math.round(projectedVertices[2].y),
    Math.round(projectedVertices[0].x),
    Math.round(projectedVertices[0].y),
    projectedVertices[2].z,
    triangle.color,
  )
}
console.log("344")
function drawLine(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  z: number,
  color: string,
) {
  const dx = Math.abs(x2 - x1)
  const dy = Math.abs(y2 - y1)
  const sx = x1 < x2 ? 1 : -1
  const sy = y1 < y2 ? 1 : -1
  let err = dx - dy
  while (true) {
    setPixel(x1, y1, z, color)
    if (x1 === x2 && y1 === y2) break
    const e2 = 2 * err
    if (e2 > -dy) {
      err -= dy
      x1 += sx
    }

    if (e2 < dx) {
      err += dx
      y1 += sy
    }
  }
}

console.log("374")
function interpolate(
  y: number,
  vA: { x: number; y: number; z: number; u: number | null; v: number | null },
  vB: { x: number; y: number; z: number; u: number | null; v: number | null }
): { x: number; z: number; u: number | null; v: number | null } | null {

  const epsilon = 1e-6;
  if (Math.abs(y - vB.y) < epsilon) {
      return { x: vB.x, z: vB.z, u: vB.u, v: vB.v };
  }
  if (Math.abs(y - vA.y) < epsilon) {
       return { x: vA.x, z: vA.z, u: vA.u, v: vA.v };
  }
  if (Math.abs(vA.y - vB.y) < epsilon) {
       return null;
  }

  const t = (y - vA.y) / (vB.y - vA.y);

  if (t < -epsilon || t > 1 + epsilon) return null;

  const x = vA.x + t * (vB.x - vA.x);
  const z = vA.z + t * (vB.z - vA.z);

  let u = null;
  let v = null;

  if (vA.u !== null && vA.v !== null && vB.u !== null && vB.v !== null) {
       u = vA.u + t * (vB.u - vA.u);
       v = vA.v + t * (vB.v - vA.v);
       // Hier wäre die Stelle für perspektivisch korrekte Interpolation (U/W, V/W, 1/W)
  }

  return { x, z, u, v };
}
console.log("410")
// fillScanline anpassen (Textur-Sampling und Alpha Blending)
function fillScanline(
  y: number,
  p1_edge: { x: number; z: number; u: number | null; v: number | null },
  p2_edge: { x: number; z: number; u: number | null; v: number | null },
  color: string, // Fallback Farbe
  textureData: TextureData | undefined, // Texturdaten
  materialAlpha: number // Material Alpha Wert
) {
    const [left_edge, right_edge] = p1_edge.x < p2_edge.x ? [p1_edge, p2_edge] : [p2_edge, p1_edge];

    const startX = Math.floor(left_edge.x);
    const endX = Math.floor(right_edge.x);

    const totalStepsX = right_edge.x - left_edge.x;

    const useTexture = textureData && left_edge.u !== null && left_edge.v !== null && right_edge.u !== null && right_edge.v !== null;

    for (let x = startX; x <= endX; x++) {
      const t_horizontal = (totalStepsX === 0) ? 0.0 : (x - left_edge.x) / totalStepsX;
      const clamped_t_horizontal = Math.max(0, Math.min(1, t_horizontal));

      const z = left_edge.z + clamped_t_horizontal * (right_edge.z - left_edge.z);

      const bufferIndex = Math.floor(y) * canvas.width + Math.floor(x);
      if (z < zBuffer[bufferIndex]) {
          zBuffer[bufferIndex] = z;

          let finalColor = color;
          let finalAlpha = materialAlpha; // Beginne mit Material Alpha

          if (useTexture) {
              const u_pixel = left_edge.u! + clamped_t_horizontal * (right_edge.u! - left_edge.u!);
              const v_pixel = left_edge.v! + clamped_t_horizontal * (right_edge.v! - left_edge.v!);

              // Hole Farbe und Alpha aus den Texturdaten
              const texturePixel = getPixelColorFromData(textureData!, u_pixel, v_pixel);

              // Kombiniere Textur-Alpha mit Material-Alpha
              finalAlpha = (texturePixel.a / 255.0) * materialAlpha;

              // Wenn das Pixel nicht komplett transparent ist (nach Alpha-Kombination)
              if (finalAlpha > 0) {
                   // Wandle gesampelte RGB Farbe in einen Canvas Style
                   // Für einfache Darstellung erstmal nur die Texturfarbe, ohne Blending
                   finalColor = `rgb(${texturePixel.r},${texturePixel.g},${texturePixel.b})`;
                   // Wenn Alpha < 1, setze RGBA Style
                   if (finalAlpha < 1.0) {
                       finalColor = `rgba(${texturePixel.r},${texturePixel.g},${texturePixel.b},${finalAlpha})`;
                        // *** WICHTIG ***
                        // Korrektes Alpha-Blending erfordert das Mischen mit dem HINTERGRUND-Pixel.
                        // setPixel müsste das können, oder du setzt ctx.fillStyle und füllst direkt
                        // Das Zeichnen von transparenten Objekten muss nach opaken Objekten und
                        // von hinten nach vorne erfolgen, damit Blending korrekt aussieht.
                        // Dieses einfache `fillStyle` setzt nur die Farbe mit Alpha, was bei Überlappungen
                        // von transparenten Objekten falsch aussehen kann.
                        // Für dieses Beispiel setzen wir es erstmal so, um zu sehen, dass Alpha ankommt.
                   }
              } else {
                  // Wenn komplett transparent, zeichne nichts
                  continue; // Springe zum nächsten Pixel
              }

          } else {
              // Wenn keine Textur oder UVs, benutze die Material/Fallback Farbe
               if (materialAlpha < 1.0) {
                    finalColor = `rgba(${parseInt(color.substring(1,3), 16)},${parseInt(color.substring(3,5), 16)},${parseInt(color.substring(5,7), 16)},${materialAlpha})`;
                     // Siehe WICHTIG oben bezüglich Blending/Zeichenreihenfolge
               }
          }


          // Setze das Pixel (deine setPixel Funktion oder direkt mit ctx)
          // setPixel muss Z-Buffer berücksichtigen, was wir oben schon gemacht haben.
          // Setze die Farbe. Wenn finalAlpha < 1.0, wird der RGBA Style verwendet.
          // Wenn setPixel nur Hex kann, musst du hier RGB/Alpha in Hex umwandeln oder
          // setPixel so anpassen, dass es RGBA verarbeiten kann.
           ctx.fillStyle = finalColor;
           ctx.fillRect(Math.floor(x), Math.floor(y), 1, 1); // Benutze Canvas fillRect
      }
    }
}

function fillTriangleProjected(triangle: Triangle) {
    // Projekte die Eckpunkte des Dreiecks und speichere original UVs
    const projectedVertices = triangle.vertices.map((vertex, index) =>
        project(vertex, triangle.uvs[index])
    ).filter(pv => pv !== null); // Entferne Punkte, die hinter der Kamera sind

    // Mindestens 3 projizierte Punkte für ein Dreieck
    if (projectedVertices.length < 3) {
        return;
    }

    // Sortiere Eckpunkte nach ihrer Y-Koordinate auf dem Bildschirm
    projectedVertices.sort((a, b) => a.y - b.y);

    const p1 = projectedVertices[0]; // Oberster Punkt
    const p2 = projectedVertices[1]; // Mittlerer Punkt
    const p3 = projectedVertices[2]; // Unterster Punkt

    // Behandle den Fall, dass der mittlere Punkt nicht auf der horizontalen Linie von p1 liegt
    if (Math.abs(p2.y - p1.y) > 1.0) { // Toleranz für Floating Point
         // Finde den Punkt p4 auf der Kante p1-p3 mit derselben Y-Koordinate wie p2
         const p4 = interpolate(p2.y, p1, p3);

         if (p4) {
              // Obere Hälfte des Dreiecks (von p1 zu p2 und p4)
              for (let y = Math.ceil(p1.y); y < Math.floor(p2.y); y++) {
                   if (y < 0 || y >= canvas.height) continue;
                   const p_left = interpolate(y, p1, p2);
                   const p_right = interpolate(y, p1, p4);
                   if (p_left && p_right) {
                       fillScanline(y, p_left, p_right, triangle.color, triangle.texture, triangle.materialAlpha);
                   }
              }
              // Untere Hälfte des Dreiecks (von p2 und p4 zu p3)
               for (let y = Math.ceil(p2.y); y <= Math.floor(p3.y); y++) {
                   if (y < 0 || y >= canvas.height) continue;
                   const p_left = interpolate(y, p2, p3);
                   const p_right = interpolate(y, p4, p3);
                   if (p_left && p_right) {
                       fillScanline(y, p_left, p_right, triangle.color, triangle.texture, triangle.materialAlpha);
                   }
              }
         } else {
             // Fallback: Dreieck als ganzes füllen, wenn p4 nicht gefunden wurde
              console.warn("Could not find split point p4 for triangle.");
               for (let y = Math.ceil(p1.y); y <= Math.floor(p3.y); y++) {
                   if (y < 0 || y >= canvas.height) continue;
                   const p_left = interpolate(y, p1, p3); // Kante p1-p3
                   let edgePoints = [interpolate(y, p1, p2), interpolate(y, p2, p3)]; // Kanten p1-p2 und p2-p3
                   edgePoints = edgePoints.filter(p => p !== null); // Filter nulls
                   edgePoints.sort((a,b) => a.x - b.x); // Sortiere nach X
                   if(edgePoints.length >= 2){
                       fillScanline(y, edgePoints[0], edgePoints[1], triangle.color, triangle.texture, triangle.materialAlpha);
                   }
              }
         }
    } else {
        // Das Dreieck hat eine horizontale Kante oben oder unten (p1.y == p2.y oder p2.y == p3.y)
        // Oder p2 ist sehr nah an p1.y
        // Behandle als ein einzelnes Dreieck von p1.y bis p3.y
        for (let y = Math.ceil(p1.y); y <= Math.floor(p3.y); y++) {
            if (y < 0 || y >= canvas.height) continue;
            const p_left = interpolate(y, p1, p3); // Kante p1-p3
            let edgePoints = [interpolate(y, p1, p2), interpolate(y, p2, p3)]; // Kanten p1-p2 und p2-p3
             edgePoints = edgePoints.filter(p => p !== null); // Filter nulls
             edgePoints.sort((a,b) => a.x - b.x); // Sortiere nach X
             if(edgePoints.length >= 2){
                 fillScanline(y, edgePoints[0], edgePoints[1], triangle.color, triangle.texture, triangle.materialAlpha);
             }
        }
    }
}
console.log("565")
      
function getRandomColor() {
  const letters = "0123456789ABCDEF"
  let color = "#"
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random(0, 1) * 16)]
  }
  return color
}

console.log("576")
      
const TEXTURE_URL = "https://i.postimg.cc/xCPN8FCj/texture01.png";

// Erstelle ein neues Image Objekt
const textureImage = new Image();

// Setze die crossOrigin Eigenschaft für CORS, falls das Bild von einer anderen Domain kommt
// (oft nötig, wenn du Pixeldaten lesen willst, wie wir es für das Sampling tun)
textureImage.crossOrigin = '';

// Definiere eine Funktion, die aufgerufen wird, wenn das Bild vollständig geladen ist
textureImage.onload = () => {
  // HIER ist das Texturbild vollständig geladen und bereit zur Verwendung
  console.log("Textur erfolgreich geladen:", textureImage.src, textureImage.width, textureImage.height);

  // Ab hier kannst du das 'textureImage' Objekt nutzen,
  // z.B. es in ein Canvas zeichnen, Pixeldaten extrahieren, etc.
};

// Definiere eine Funktion, die aufgerufen wird, wenn ein Fehler beim Laden auftritt
textureImage.onerror = (err) => {
  console.error("Fehler beim Laden der Textur:", TEXTURE_URL, err);
};

// Setze die Quelle des Bildes, was den Ladevorgang startet
textureImage.src = TEXTURE_URL;

console.log("Image-Ladevorgang gestartet... Code läuft hier sofort weiter!");

//__ Fetch Model Data __
let model1 = "https://api.jsonsilo.com/public/7cd9822c-f656-466c-aab5-dfc9e4cfb5eb"
let model2 = "https://github.com/3ngelch3n/code_wisp/blob/main/cube_with_texture.json"
const scene: Triangle[] = [];
const JSON_URL = "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/cube_with_texture.json"; // Deine URL!

fetch(JSON_URL)
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(async (data) => {
    const vertices_data = data.vertices;
    const normals_data = data.normals;
    const texcoords_data = data.texcoords;
    const faces_data = data.faces;
    const materials_data = data.materials;

    const textureUrlsToLoad: string[] = [];
    const materialsInfo: { [materialName: string]: { textureUrl?: string; alpha: number; kdColor?: string } } = {};

    for (const matName in materials_data) {
        const material = materials_data[matName];
        const matInfo: { textureUrl?: string; alpha: number; kdColor?: string } = { alpha: 1.0 }; // Standard: opak
        if (material) {
             if (material.map_Kd && typeof material.map_Kd === 'string') {
                 matInfo.textureUrl = material.map_Kd;
                if (!textureUrlsToLoad.includes(matInfo.textureUrl)) {
                    textureUrlsToLoad.push(matInfo.textureUrl);
                }
             }
             // Hole Dissolve/Alpha Wert (d)
             if (material.d !== undefined && typeof material.d === 'number') {
                 matInfo.alpha = material.d;
             } else if (material.Tr !== undefined && typeof material.Tr === 'number') { // Manchmal wird Tr statt d benutzt
                 matInfo.alpha = 1.0 - material.Tr;
             }
             // Hole Kd Farbe als Fallback
             if(material.Kd && material.Kd.length === 3) {
                 matInfo.kdColor = rgbToHex(material.Kd[0], material.Kd[1], material.Kd[2]);
             }
        }
        materialsInfo[matName] = matInfo;
    }

    const loadingPromises = textureUrlsToLoad.map(url => loadTexture(url));

    try {
         await Promise.all(loadingPromises);
         console.log(`Alle ${textureUrlsToLoad.length} Texturen geladen.`);
    } catch (error) {
         console.error("Fehler beim Laden einer oder mehrerer Texturen:", error);
         // Fahre fort, auch wenn Texturen fehlen (sie werden dann nicht gerendert)
    }

    for (const faceData of faces_data) {
          if (faceData.indices.length === 3) {

              const v_idx1 = faceData.indices[0].v;
              const v_idx2 = faceData.indices[1].v;
              const v_idx3 = faceData.indices[2].v;

              const vt_idx1 = faceData.indices[0].vt;
              const vt_idx2 = faceData.indices[1].vt;
              const vt_idx3 = faceData.indices[2].vt;

              const v1_3D = new Vector3(...vertices_data[v_idx1]);
              const v2_3D = new Vector3(...vertices_data[v_idx2]);
              const v3_3D = new Vector3(...vertices_data[v_idx3]);

              const uv1 = (vt_idx1 !== null && texcoords_data[vt_idx1] !== undefined) ? { u: texcoords_data[vt_idx1][0], v: 1.0 - texcoords_data[vt_idx1][1] } : null;
              const uv2 = (vt_idx2 !== null && texcoords_data[vt_idx2] !== undefined) ? { u: texcoords_data[vt_idx2][0], v: 1.0 - texcoords_data[vt_idx2][1] } : null;
              const uv3 = (vt_idx3 !== null && texcoords_data[vt_idx3] !== undefined) ? { u: texcoords_data[vt_idx3][0], v: 1.0 - texcoords_data[vt_idx3][1] } : null;

              const materialName = faceData.material;
              const materialInfo = materialName ? materialsInfo[materialName] : undefined;

              const textureUrlForFace = materialInfo ? materialInfo.textureUrl : undefined;
              const textureDataForFace = textureUrlForFace ? loadedTextures[textureUrlForFace] : undefined;

              const materialAlpha = materialInfo ? materialInfo.alpha : 1.0;
              const faceColor = (materialInfo && materialInfo.kdColor) ? materialInfo.kdColor : defaultColor;


              const triangle = new Triangle(v1_3D, v2_3D, v3_3D, uv1, uv2, uv3, faceColor, textureDataForFace, materialAlpha);

              scene.push(triangle);
            } else {
                 console.warn("Skipping non-triangle face or face without 3 vertex indices:", faceData);
            }
        }

    console.log(`Szene mit ${scene.length} Dreiecken erstellt.`);
    // Starte die Game Loop erst, nachdem Szene geladen ist

  })
  .catch((error) => {
    console.error("fehler beim laden der modelldata oder Texturen:", error);
  });



forever(function () {
  gameLoop()
})

function drawFrame() {
  ctx.clearRect(0, 0, gamecan.width, gamecan.height)
  for (let i = 0; i < zBuffer.length; i++) {
    zBuffer[i] = Infinity
  }

  //drawSkyBox();
  drawFPS()

  scene.forEach((triangle) => {
    fillTriangleProjected(triangle)
  })
}

console.log("looping now!: 728")
function gameLoop() {
  updateCamera()
  drawFrame()
  //requestAnimationFrame(gameLoop);
}

function drawSkyBox() {
  const scaleFactor = screenDimensions.height / skybox.height
  ctx.drawImage(
    skybox,
    0,
    0,
    skybox.width * scaleFactor,
    skybox.height * scaleFactor,
  )
}



function drawFPS() {
  const now = performance.now()
  const delta = now - lastFrameTime
  lastFrameTime = now
  fps = 1000 / delta
  smoothFPS = smoothFPS * 0.9 + fps * 0.1
  ctx.fillStyle = "black"
  ctx.fillRect(0, 0, 150, 40)
  ctx.fillStyle = "lime"
  ctx.font = "bold 14px monospace"
  ctx.fillText("FPS: " + Math.round(smoothFPS), 5, 15)
  ctx.fillText(`X: ${camera.x.toFixed(2)}`, 5, 30)
  ctx.fillText(`Y: ${camera.y.toFixed(2)}`, 70, 30)
  ctx.fillText(`Z: ${camera.z.toFixed(2)}`, 135, 30)
}



function updateCamera() {
  horizontalSpeed = 0

  if (Keyboard.keyHeld(Key.Space)) {
    camera.y += moveSpeed
  }

  if (Keyboard.keyHeld(Key.Shift)) {
    camera.y -= moveSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowLeft)) {
    camera.yaw -= rotationSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowRight)) {
    camera.yaw += rotationSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowUp)) {
    camera.pitch -= rotationSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowDown)) {
    camera.pitch += rotationSpeed
  }

  if (Keyboard.keyHeld(Key.W)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw
  }

  if (Keyboard.keyHeld(Key.A)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw + 90
  }

  if (Keyboard.keyHeld(Key.S)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw - 180
  }

  if (Keyboard.keyHeld(Key.D)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw - 90
  }

  if (horizontalSpeed > 0.2) horizontalSpeed = 0.2

  const dirX = -Math.sin(playerRotation)

  const dirZ = Math.cos(playerRotation)

  camera.x += dirX * horizontalSpeed

  camera.z += dirZ * horizontalSpeed

  camera.pitch = Math.max(-89, Math.min(89, camera.pitch))
}
/(/texture borkem
