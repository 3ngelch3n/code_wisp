if (document.querySelectorAll("canvas").length > 1) {
  document.querySelectorAll("canvas")[0].parentElement.children[1].remove()
} //inject Sprites into the game screen by @decmant

let gamecan = document.querySelector("canvas")

let canvas = document.createElement("canvas")

let shouldStart = false

canvas.height = gamecan.height

canvas.width = gamecan.width

canvas.style.height = gamecan.style.height

canvas.style.width = gamecan.style.width

canvas.style.position = "relative"

canvas.style.top = `${0 - Number(gamecan.style.height.match(/\d*/))}px`

canvas.style.left = `0px`

gamecan.parentElement.append(canvas)

let ctx = canvas.getContext("2d")

sprite.visible = false

let lastFrameTime = performance.now()

let fps = 0

let smoothFPS = 0

function updateSkyBox() {
  switch (level) {
    case levels.castle_grounds:
      //Credits: https://www.textures-resource.com/nintendo_64/mario64/texture/1315/
      skybox.src = "https://i.postimg.cc/s2J6Lz4J/castle-grounds.png"
      break
  }
}

const screenDimensions = {
  width: 480,

  height: 360,

  halfwidth: 240,

  halfheight: 180,
}

let zBuffer = new Float32Array(screenDimensions.width * screenDimensions.height)

enum levels {
  castle_grounds,

  inside_castle,
}

let level = levels.castle_grounds

let skybox = new Image()

updateSkyBox()

const camera = {
  x: 0,

  y: 7,

  z: -12,

  yaw: 0,

  pitch: 0,
}

let horizontalSpeed = 0

let playerRotation = 0

const moveSpeed = 0.1

const rotationSpeed = -2

const projectionDistance = 1

class Vector3 {
  x: number
  y: number
  z: number
  constructor(x = 0, y = 0, z = 0) {
    this.x = x
    this.y = y
    this.z = z
  }
  subtract(v: any) {
    return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z)
  }
  cross(v: any) {
    return new Vector3(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x,
    )
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }
  normalize() {
    const mag = this.magnitude()
    return mag === 0
      ? new Vector3(0, 0, 0)
      : new Vector3(this.x / mag, this.y / mag, this.z / mag)
  }
}

console.log("118")

// Hilfsfunktion zur Normalenberechnung (angenommen, diese existiert)
function calculateNormal(v1: any, v2: any, v3: any) {
  const edge1 = v2.subtract(v1)
  const edge2 = v3.subtract(v1)
  return edge1.cross(edge2).normalize()
}

// RGB (0-1) zu Hex String Konverter (angenommen, diese existiert)
function rgbToHex(r: any, g: any, b: any) {
  const toHex = (c: any) => {
    const hex = Math.floor(c * 255).toString(16)
    return hex.length === 1 ? "0" + hex : hex
  }
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`
}

// Alpha (0-1) zu Hex String Konverter für RGBA (optional, falls setPixel das verarbeiten kann)
function rgbaToHex(r: any, g: any, b: any, a: any) {
  const toHex = (c: any) => {
    const hex = Math.floor(c * 255).toString(16)
    return hex.length === 1 ? "0" + hex : hex
  }
  const toAlphaHex = (a: any) => {
    const hex = Math.floor(a * 255).toString(16)
    return hex.length === 1 ? "0" + hex : hex
  }
  // RGBA im Format #RRGGBBAA ist weniger verbreitet im Web als rgba()
  // Rückgabe als RGBA-String für Canvas fillStyle ist einfacher
  return `rgba(${Math.floor(r * 255)}, ${Math.floor(g * 255)}, ${Math.floor(b * 255)}, ${a})`
}

// Interface für UV Koordinaten
interface UV {
  u: number
  v: number
}

// Struktur zum Speichern von Pixeldaten einer Textur
interface TextureData {
  width: number
  height: number
  data: Uint8ClampedArray // Pixeldaten (R, G, B, A für jeden Pixel)
}

class Triangle {
  vertices: [Vector3, Vector3, Vector3] // Original 3D vertices
  uvs: [UV | null, UV | null, UV | null] // Original UV coordinates
  color: string // Solide Farbe (Fallback)
  normal: Vector3 // Normale
  texture: TextureData | undefined // Referenz zu den geladenen Texturdaten
  materialAlpha: number // Material Dissolve/Alpha Wert (d)

  constructor(
    v1: Vector3,
    v2: Vector3,
    v3: Vector3,
    uv1: UV | null = null,
    uv2: UV | null = null,
    uv3: UV | null = null,
    color: string = "white",
    textureData: TextureData | undefined = undefined,
    materialAlpha: number = 1.0, // Füge Material Alpha hinzu
  ) {
    this.vertices = [v1, v2, v3]
    this.uvs = [uv1, uv2, uv3]
    this.color = color
    this.normal = calculateNormal(v1, v2, v3)
    this.texture = textureData
    this.materialAlpha = materialAlpha // Speichere Material Alpha
  }
}

function setPixel(x: any, y: any, z: any, color: any) {
  if (
    x < 0 ||
    y < 0 ||
    x >= screenDimensions.width ||
    y >= screenDimensions.height
  )
    return
  const index = y * screenDimensions.width + x
  if (z < zBuffer[index]) {
    zBuffer[index] = z
    ctx.fillStyle = color
    ctx.fillRect(x, y, 1, 1)
  }
}

const loadedTextures: { [key: string]: TextureData } = {}

// Funktion zum asynchronen Laden einer Textur und Lesen ihrer Pixeldaten
function loadTexture(url: string): Promise<TextureData> {
  return new Promise((resolve, reject) => {
    const img = new Image()
    img.onload = () => {
      // Zeichne das Bild in ein temporäres Canvas, um Pixeldaten zu extrahieren
      const tempCanvas = document.createElement("canvas")
      const tempCtx = tempCanvas.getContext("2d")
      if (!tempCtx) {
        reject("Could not get 2D context from temporary canvas.")
        return
      }
      tempCanvas.width = img.width
      tempCanvas.height = img.height
      tempCtx.drawImage(img, 0, 0)

      try {
        const imageData = tempCtx.getImageData(0, 0, img.width, img.height)
        const textureData: TextureData = {
          width: img.width,
          height: img.height,
          data: imageData.data,
        }
        loadedTextures[url] = textureData // Speichere die extrahierten Daten
        resolve(textureData)
      } catch (e) {
        console.error("Fehler beim Extrahieren der Texturdaten:", url, e)
        reject(e)
      }
    }
    img.onerror = (err) => {
      console.error("Fehler beim Laden der Texturdatei:", url, err)
      reject(err)
    }
    img.crossOrigin = "" // Wichtig für CORS, wenn Texturen von anderer Domain geladen werden
    img.src = url
  })
}

function getPixelColorFromData(
  textureData: TextureData,
  u: number,
  v: number,
): { r: number; g: number; b: number; a: number } {
  // Klemme U,V an den Bereich [0, 1]
  const clampedU = Math.max(0, Math.min(1, u))
  const clampedV = Math.max(0, Math.min(1, v))

  // Konvertiere UV [0, 1] zu Pixelkoordinaten [0, width/height - 1]
  // Math.floor ist wichtig, um zu einem spezifischen Pixel zu kommen
  const textureX = Math.floor(clampedU * (textureData.width - 1))
  const textureY = Math.floor(clampedV * (textureData.height - 1))

  // Berechne den Index im 1D Array (RGBA)
  const index = (textureY * textureData.width + textureX) * 4

  // Stelle sicher, dass der Index gültig ist
  if (index < 0 || index >= textureData.data.length) {
    console.warn("Ungültiger Texturdaten-Index:", index, "für UV:", u, v)
    return { r: 0, g: 0, b: 0, a: 0 } // Schwarzes transparentes Pixel bei Fehler
  }

  return {
    r: textureData.data[index],
    g: textureData.data[index + 1],
    b: textureData.data[index + 2],
    a: textureData.data[index + 3], // Alpha Wert (0-255)
  }
}

console.log("273")

function project(
  vertex: Vector3,
  originalUv: UV | null = null,
): {
  x: number
  y: number
  z: number
  u: number | null
  v: number | null
} | null {
  let worldX = vertex.x - camera.x
  let worldY = vertex.y - camera.y
  let worldZ = vertex.z - camera.z

  const yawInRadians = camera.yaw
  const cosYaw = Math.cos(yawInRadians)
  const sinYaw = Math.sin(yawInRadians)
  const rotatedX = cosYaw * worldX + sinYaw * worldZ
  const rotatedZ = -sinYaw * worldX + cosYaw * worldZ
  worldX = rotatedX
  worldZ = rotatedZ

  const pitchInRadians = camera.pitch
  const cosPitch = Math.cos(pitchInRadians)
  const sinPitch = Math.sin(pitchInRadians)
  const rotatedY = cosPitch * worldY - sinPitch * worldZ
  const rotatedZ2 = sinPitch * worldY + cosPitch * worldZ
  worldY = rotatedY
  worldZ = rotatedZ2

  if (worldZ <= 0.95) {
    return null
  }

  const screenX = (projectionDistance * worldX) / worldZ
  const screenY = (projectionDistance * worldY) / worldZ

  const aspectRatio = canvas.width / canvas.height
  const canvasX = canvas.width / 2 + (screenX * canvas.width) / 2
  const canvasY =
    canvas.height / 2 - ((screenY * canvas.height) / 2) * aspectRatio

  return {
    x: canvasX,
    y: canvasY,
    z: worldZ,
    u: originalUv ? originalUv.u : null,
    v: originalUv ? originalUv.v : null,
  }
}
console.log("316")
function drawTriangleProjected(triangle: Triangle) {
  const projectedVertices = triangle.vertices.map(project)
  drawLine(
    Math.round(projectedVertices[0].x),
    Math.round(projectedVertices[0].y),
    Math.round(projectedVertices[1].x),
    Math.round(projectedVertices[1].y),
    projectedVertices[0].z,
    triangle.color,
  )
  drawLine(
    Math.round(projectedVertices[1].x),
    Math.round(projectedVertices[1].y),
    Math.round(projectedVertices[2].x),
    Math.round(projectedVertices[2].y),
    projectedVertices[1].z,
    triangle.color,
  )
  drawLine(
    Math.round(projectedVertices[2].x),
    Math.round(projectedVertices[2].y),
    Math.round(projectedVertices[0].x),
    Math.round(projectedVertices[0].y),
    projectedVertices[2].z,
    triangle.color,
  )
}
console.log("344")
function drawLine(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  z: number,
  color: string,
) {
  const dx = Math.abs(x2 - x1)
  const dy = Math.abs(y2 - y1)
  const sx = x1 < x2 ? 1 : -1
  const sy = y1 < y2 ? 1 : -1
  let err = dx - dy
  while (true) {
    setPixel(x1, y1, z, color)
    if (x1 === x2 && y1 === y2) break
    const e2 = 2 * err
    if (e2 > -dy) {
      err -= dy
      x1 += sx
    }

    if (e2 < dx) {
      err += dx
      y1 += sy
    }
  }
}

console.log("374")
function interpolate(
  y: number,
  vA: { x: number; y: number; z: number; u: number | null; v: number | null },
  vB: { x: number; y: number; z: number; u: number | null; v: number | null },
): { x: number; z: number; u: number | null; v: number | null } | null {
  const epsilon = 1e-6
  if (Math.abs(y - vB.y) < epsilon) {
    return { x: vB.x, z: vB.z, u: vB.u, v: vB.v }
  }
  if (Math.abs(y - vA.y) < epsilon) {
    return { x: vA.x, z: vA.z, u: vA.u, v: vA.v }
  }
  if (Math.abs(vA.y - vB.y) < epsilon) {
    return null
  }

  const t = (y - vA.y) / (vB.y - vA.y)

  if (t < -epsilon || t > 1 + epsilon) return null

  const x = vA.x + t * (vB.x - vA.x)
  const z = vA.z + t * (vB.z - vA.z)

  let u = null
  let v = null

  if (vA.u !== null && vA.v !== null && vB.u !== null && vB.v !== null) {
    u = vA.u + t * (vB.u - vA.u)
    v = vA.v + t * (vB.v - vA.v)
    // Hier wäre die Stelle für perspektivisch korrekte Interpolation (U/W, V/W, 1/W)
  }

  return { x, z, u, v }
}
console.log("410")
// fillScanline anpassen (Textur-Sampling und Alpha Blending)
function fillScanline(
  y: number,
  p1_edge: { x: number; z: number; u: number | null; v: number | null },
  p2_edge: { x: number; z: number; u: number | null; v: number | null },
  color: string, // Fallback Farbe
  textureData: TextureData | undefined, // Texturdaten
  materialAlpha: number, // Material Alpha Wert
) {
  const [left_edge, right_edge] =
    p1_edge.x < p2_edge.x ? [p1_edge, p2_edge] : [p2_edge, p1_edge]

  const startX = Math.floor(left_edge.x)
  const endX = Math.floor(right_edge.x)

  const totalStepsX = right_edge.x - left_edge.x

  const useTexture =
    textureData &&
    left_edge.u !== null &&
    left_edge.v !== null &&
    right_edge.u !== null &&
    right_edge.v !== null

  for (let x = startX; x <= endX; x++) {
    const t_horizontal =
      totalStepsX === 0 ? 0.0 : (x - left_edge.x) / totalStepsX
    const clamped_t_horizontal = Math.max(0, Math.min(1, t_horizontal))

    const z = left_edge.z + clamped_t_horizontal * (right_edge.z - left_edge.z)

    const bufferIndex = Math.floor(y) * canvas.width + Math.floor(x)
    if (z < zBuffer[bufferIndex]) {
      zBuffer[bufferIndex] = z

      let finalColor = color
      let finalAlpha = materialAlpha // Beginne mit Material Alpha

      if (useTexture) {
        const u_pixel =
          left_edge.u! + clamped_t_horizontal * (right_edge.u! - left_edge.u!)
        const v_pixel =
          left_edge.v! + clamped_t_horizontal * (right_edge.v! - left_edge.v!)

        // Hole Farbe und Alpha aus den Texturdaten
        const texturePixel = getPixelColorFromData(
          textureData!,
          u_pixel,
          v_pixel,
        )

        // Kombiniere Textur-Alpha mit Material-Alpha
        finalAlpha = (texturePixel.a / 255.0) * materialAlpha

        // Wenn das Pixel nicht komplett transparent ist (nach Alpha-Kombination)
        if (finalAlpha > 0) {
          // Wandle gesampelte RGB Farbe in einen Canvas Style
          // Für einfache Darstellung erstmal nur die Texturfarbe, ohne Blending
          finalColor = `rgb(${texturePixel.r},${texturePixel.g},${texturePixel.b})`
          // Wenn Alpha < 1, setze RGBA Style
          if (finalAlpha < 1.0) {
            finalColor = `rgba(${texturePixel.r},${texturePixel.g},${texturePixel.b},${finalAlpha})`
            // *** WICHTIG ***
            // Korrektes Alpha-Blending erfordert das Mischen mit dem HINTERGRUND-Pixel.
            // setPixel müsste das können, oder du setzt ctx.fillStyle und füllst direkt
            // Das Zeichnen von transparenten Objekten muss nach opaken Objekten und
            // von hinten nach vorne erfolgen, damit Blending korrekt aussieht.
            // Dieses einfache `fillStyle` setzt nur die Farbe mit Alpha, was bei Überlappungen
            // von transparenten Objekten falsch aussehen kann.
            // Für dieses Beispiel setzen wir es erstmal so, um zu sehen, dass Alpha ankommt.
          }
        } else {
          // Wenn komplett transparent, zeichne nichts
          continue // Springe zum nächsten Pixel
        }
      } else {
        // Wenn keine Textur oder UVs, benutze die Material/Fallback Farbe
        if (materialAlpha < 1.0) {
          finalColor = `rgba(${parseInt(color.substring(1, 3), 16)},${parseInt(color.substring(3, 5), 16)},${parseInt(color.substring(5, 7), 16)},${materialAlpha})`
          // Siehe WICHTIG oben bezüglich Blending/Zeichenreihenfolge
        }
      }

      // Setze das Pixel (deine setPixel Funktion oder direkt mit ctx)
      // setPixel muss Z-Buffer berücksichtigen, was wir oben schon gemacht haben.
      // Setze die Farbe. Wenn finalAlpha < 1.0, wird der RGBA Style verwendet.
      // Wenn setPixel nur Hex kann, musst du hier RGB/Alpha in Hex umwandeln oder
      // setPixel so anpassen, dass es RGBA verarbeiten kann.
      ctx.fillStyle = finalColor
      ctx.fillRect(Math.floor(x), Math.floor(y), 1, 1) // Benutze Canvas fillRect
    }
  }
}

function fillTriangleProjected(triangle: Triangle) {
  // Projekte die Eckpunkte des Dreiecks und speichere original UVs
  // Stelle sicher, dass deine project Funktion das original UV zurückgibt
  const projectedVertices = triangle.vertices
    .map((vertex, index) => project(vertex, triangle.uvs[index]))
    .filter((pv) => pv !== null) // Entferne Punkte, die hinter der Kamera sind

  // Mindestens 3 projizierte Punkte für ein Dreieck
  if (projectedVertices.length < 3) {
    return
  }

  // Sortiere Eckpunkte nach ihrer Y-Koordinate auf dem Bildschirm
  projectedVertices.sort((a, b) => a.y - b.y)

  const p1 = projectedVertices[0] // Oberster Punkt
  const p2 = projectedVertices[1] // Mittlerer Punkt
  const p3 = projectedVertices[2] // Unterster Punkt

  // Behandle den Fall, dass der mittlere Punkt nicht auf der horizontalen Linie von p1 liegt
  // (Splitting des Dreiecks)
  // Toleranz für Floating Point Vergleiche bei Y-Koordinaten
  const epsilonY = 1.0; // Vergleiche auf Pixelebene
  if (Math.abs(p2.y - p1.y) >= epsilonY && Math.abs(p2.y - p3.y) >= epsilonY) {
    // Finde den Punkt p4 auf der Kante p1-p3 mit derselben Y-Koordinate wie p2
    const p4 = interpolate(p2.y, p1, p3)

    if (p4) {
      // Obere Hälfte des Dreiecks (von p1 zu p2 und p4)
      // Iteriere y von p1.y (aufgerundet) bis p2.y (abgerundet)
      for (let y = Math.ceil(p1.y); y < Math.floor(p2.y); y++) {
        if (y < 0 || y >= canvas.height) continue // Clipping Y

        // Interpoliere Punkte auf den beiden Kanten bei der aktuellen Y-Koordinate
        const p_left = interpolate(y, p1, p2) // Kante p1-p2
        const p_right = interpolate(y, p1, p4) // Kante p1-p4 (auf der anderen Seite)

        if (p_left && p_right) {
          // Rufe fillScanline auf, um die horizontale Linie zu füllen
          fillScanline(
            y,
            p_left, // Startpunkt der Scanline (links)
            p_right, // Endpunkt der Scanline (rechts)
            triangle.color, // Fallback Farbe
            triangle.texture, // Texturdaten
            triangle.materialAlpha, // Material Alpha
          )
        }
      }
      // Untere Hälfte des Dreiecks (von p2 und p4 zu p3)
      // Iteriere y von p2.y (aufgerundet) bis p3.y (abgerundet)
      for (let y = Math.ceil(p2.y); y <= Math.floor(p3.y); y++) {
        if (y < 0 || y >= canvas.height) continue // Clipping Y

        // Interpoliere Punkte auf den beiden Kanten bei der aktuellen Y-Koordinate
        const p_left = interpolate(y, p2, p3) // Kante p2-p3
        const p_right = interpolate(y, p4, p3) // Kante p4-p3 (andere Seite)

        if (p_left && p_right) {
          // Rufe fillScanline auf, um die horizontale Linie zu füllen
          fillScanline(
            y,
            p_left,
            p_right,
            triangle.color,
            triangle.texture,
            triangle.materialAlpha,
          )
        }
      }
    } else {
      // Das Dreieck ist ein einfaches Dreieck (kein Splitting nötig)
      // Dies passiert, wenn p2.y sehr nah an p1.y oder p3.y ist
      // oder wenn die Kante p1-p3 vertikal ist.
      // Iteriere y von p1.y (aufgerundet) bis p3.y (abgerundet)
      for (let y = Math.ceil(p1.y); y <= Math.floor(p3.y); y++) {
        if (y < 0 || y >= canvas.height) continue // Clipping Y

        // Interpoliere Punkte auf den beiden äußeren Kanten
        // Bestimme, welche Seite die Kante p1-p3 ist und welche die anderen beiden Kanten kombiniert sind
        // Dies erfordert etwas Logik, um die "linke" und "rechte" Kante bei der aktuellen Y zu finden.
        // Eine vereinfachte Annahme könnte sein, dass p1-p3 immer eine Kante ist,
        // und die andere Kante ist entweder p1-p2 oder p2-p3, je nach Y.
        // Alternativ kann man alle Kantenpunkte bei Y berechnen und die zwei äußersten nehmen.

        const edgePoint13 = interpolate(y, p1, p3);
        const edgePoint12 = interpolate(y, p1, p2);
        const edgePoint23 = interpolate(y, p2, p3);

        let scanlinePoints = [edgePoint13, edgePoint12, edgePoint23].filter(p => p !== null);

        // Sortiere die gefundenen Punkte nach X, um die linke und rechte Kante zu finden
        scanlinePoints.sort((a, b) => a.x - b.x);

        // Wir brauchen genau 2 Punkte für eine Scanline
        if (scanlinePoints.length >= 2) {
          fillScanline(
            y,
            scanlinePoints[0], // Linker Punkt der Scanline
            scanlinePoints[scanlinePoints.length - 1], // Rechter Punkt der Scanline
            triangle.color,
            triangle.texture,
            triangle.materialAlpha,
          )
        }
         // Füge hier ggf. eine Warnung ein, wenn scanlinePoints.length < 2 ist
      }
  }
}
console.log("565")

function getRandomColor() {
  const letters = "0123456789ABCDEF"
  let color = "#"
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random(0, 1) * 16)]
  }
  return color
}

console.log("576")

//__ Fetch Model Data __
let model1 =
  "https://api.jsonsilo.com/public/7cd9822c-f656-466c-aab5-dfc9e4cfb5eb"
let model2 =
  "https://github.com/3ngelch3n/code_wisp/blob/main/cube_with_texture.json"
const scene: Triangle[] = []
const JSON_URL = "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/cube_with_texture.json";

fetch(JSON_URL)
  .then((response) => { /* ... Fehlerbehandlung ... */ return response.json(); })
  .then(async (data) => {
    // *** Definiere defaultColor HIER ***
    const defaultColor = "#111111"; // Oder eine andere Standardfarbe

    const vertices_data = data.vertices;
    // ... (normals_data, texcoords_data, faces_data, materials_data) ...
    const normals_data = data.normals;
    const texcoords_data = data.texcoords;
    const faces_data = data.faces;
    const materials_data = data.materials;


    const textureUrlsToLoad: string[] = [];
    const materialsInfo: { [materialName: string]: { textureUrl?: string; alpha: number; kdColor?: string } } = {};

    const TEXTURE_BASE_URL = ""; // Basispfad ist leer, da die URL in der JSON komplett ist

    for (const matName in materials_data) {
        const material = materials_data[matName];
        const matInfo: { textureUrl?: string; alpha: number; kdColor?: string } = { alpha: 1.0 };
        if (material) {
             if (material.map_Kd && typeof material.map_Kd === 'string') {
                const textureRelativePath = material.map_Kd;
                const textureFullUrl = textureRelativePath; // Annahme: URL in JSON ist komplett

                matInfo.textureUrl = textureFullUrl;
                if (!textureUrlsToLoad.includes(textureFullUrl)) {
                    textureUrlsToLoad.push(textureFullUrl);
                }
             }
             if (material.d !== undefined && typeof material.d === 'number') {
                 matInfo.alpha = material.d;
             } else if (material.Tr !== undefined && typeof material.Tr === 'number') {
                 matInfo.alpha = 1.0 - material.Tr;
             }
             if(material.Kd && material.Kd.length === 3) {
                 matInfo.kdColor = rgbToHex(material.Kd[0], material.Kd[1], material.Kd[2]);
             }
        }
        materialsInfo[matName] = matInfo;
    }

    const loadingPromises = textureUrlsToLoad.map(url => loadTexture(url));

    try {
         await Promise.all(loadingPromises);
         console.log(`Alle ${textureUrlsToLoad.length} Texturen geladen.`);
    } catch (error) {
         console.error("Fehler beim Laden einer oder mehrerer Texturen:", error);
         // Hier könntest du entscheiden, ob du abbricht oder ohne Texturen zeichnest
    }

    for (const faceData of faces_data) {
          if (faceData.indices.length === 3) {
              // ... (Code zum Holen von v_idx, vt_idx, v1_3D, uv1 etc.) ...
              const v_idx1 = faceData.indices[0].v; const v_idx2 = faceData.indices[1].v; const v_idx3 = faceData.indices[2].v;
              const vt_idx1 = faceData.indices[0].vt; const vt_idx2 = faceData.indices[1].vt; const vt_idx3 = faceData.indices[2].vt;
              const v1_3D = new Vector3(...vertices_data[v_idx1]); const v2_3D = new Vector3(...vertices_data[v_idx2]); const v3_3D = new Vector3(...vertices_data[v_idx3]);
              const uv1 = (vt_idx1 !== null && texcoords_data[vt_idx1] !== undefined) ? { u: texcoords_data[vt_idx1][0], v: 1.0 - texcoords_data[vt_idx1][1] } : null;
              const uv2 = (vt_idx2 !== null && texcoords_data[vt_idx2] !== undefined) ? { u: texcoords_data[vt_idx2][0], v: 1.0 - texcoords_data[vt_idx2][1] } : null;
              const uv3 = (vt_idx3 !== null && texcoords_data[vt_idx3] !== undefined) ? { u: texcoords_data[vt_idx3][0], v: 1.0 - texcoords_data[vt_idx3][1] } : null;

              const materialName = faceData.material;
              const materialInfo = materialName ? materialsInfo[materialName] : undefined;

              const textureUrlForFace = materialInfo ? materialInfo.textureUrl : undefined;
              const textureDataForFace = textureUrlForFace ? loadedTextures[textureUrlForFace] : undefined;

              const materialAlpha = materialInfo ? materialInfo.alpha : 1.0;
              // *** defaultColor wird hier richtig referenziert ***
              const faceColor = (materialInfo && materialInfo.kdColor) ? materialInfo.kdColor : defaultColor;


              const triangle = new Triangle(v1_3D, v2_3D, v3_3D, uv1, uv2, uv3, faceColor, textureDataForFace, materialAlpha);
              scene.push(triangle);
            } else {
                 console.warn("Skipping non-triangle face or face without 3 vertex indices:", faceData);
            }
        }

    console.log(`Szene mit ${scene.length} Dreiecken erstellt.`);
    // *** Rufe gameLoop() HIER auf, nachdem alles geladen und erstellt ist ***
    //gameLoop();
    shouldStart = true
    console.log("Starting The Gameloop now!")

  })
  .catch((error) => {
    console.error("fehler beim laden der modelldata oder Texturen:", error);
  });

forever(function () {
  if (shouldStart) {
  gameLoop()
  }
})

function drawFrame() {
  ctx.clearRect(0, 0, gamecan.width, gamecan.height)
  for (let i = 0; i < zBuffer.length; i++) {
    zBuffer[i] = Infinity
  }

  //drawSkyBox();
  drawFPS()

  scene.forEach((triangle) => {
    fillTriangleProjected(triangle)
  })
}


function gameLoop() {
  updateCamera()
  drawFrame()
  //requestAnimationFrame(gameLoop);
}

function drawSkyBox() {
  const scaleFactor = screenDimensions.height / skybox.height
  ctx.drawImage(
    skybox,
    0,
    0,
    skybox.width * scaleFactor,
    skybox.height * scaleFactor,
  )
}

function drawFPS() {
  const now = performance.now()
  const delta = now - lastFrameTime
  lastFrameTime = now
  fps = 1000 / delta
  smoothFPS = smoothFPS * 0.9 + fps * 0.1
  ctx.fillStyle = "black"
  ctx.fillRect(0, 0, 150, 40)
  ctx.fillStyle = "lime"
  ctx.font = "bold 14px monospace"
  ctx.fillText("FPS: " + Math.round(smoothFPS), 5, 15)
  ctx.fillText(`X: ${camera.x.toFixed(2)}`, 5, 30)
  ctx.fillText(`Y: ${camera.y.toFixed(2)}`, 70, 30)
  ctx.fillText(`Z: ${camera.z.toFixed(2)}`, 135, 30)
}

function updateCamera() {
  horizontalSpeed = 0

  if (Keyboard.keyHeld(Key.Space)) {
    camera.y += moveSpeed
  }

  if (Keyboard.keyHeld(Key.Shift)) {
    camera.y -= moveSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowLeft)) {
    camera.yaw -= rotationSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowRight)) {
    camera.yaw += rotationSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowUp)) {
    camera.pitch -= rotationSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowDown)) {
    camera.pitch += rotationSpeed
  }

  if (Keyboard.keyHeld(Key.W)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw
  }

  if (Keyboard.keyHeld(Key.A)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw + 90
  }

  if (Keyboard.keyHeld(Key.S)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw - 180
  }

  if (Keyboard.keyHeld(Key.D)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw - 90
  }

  if (horizontalSpeed > 0.2) horizontalSpeed = 0.2

  const dirX = -Math.sin(playerRotation)

  const dirZ = Math.cos(playerRotation)

  camera.x += dirX * horizontalSpeed

  camera.z += dirZ * horizontalSpeed

  camera.pitch = Math.max(-89, Math.min(89, camera.pitch))
}
//textur brfokenm again
