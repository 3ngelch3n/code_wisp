let resolutionScale = 1

let camera = {
  x: 0,
  y: 7,
  z: -12,
  yaw: 0,
  pitch: 0,
  yawVel: 0,
  pitchVel: 0,
  turningYaw: false,
  targetYaw: 0,
  stepAngle: 33.333,
  turningSpeedYaw: 200,
}

enum collisionTypes {
  floor,
  wall,
  ceiling,
}

const light = {
  yaw: 45,
  pitch: -45,
}

let intendedY = 0
let intendedX = 0
let intendedMag = 0
let intendedSpace = false
let intendedShift = false
const moveSpeed = 0.1
const gravity = -0.1
const enable_outlines = true
const rotationSpeed = -2
const projectionDistance = 1
let lightDir: Vector3
let playerIsAnimRunning: boolean = false
enum animations {
  start_jumping,
  single_jumping_fall,
  running,
  fall,
  idle,
  long_jump,
  crouch,
  sneaking,
  sneakingIdle,
  double_jumping_fall,
  tripe_jumping_fall,
  skidding,
}
enum state {
  ground,
  air,
  water,
}
enum jumpTypes {
  single,
  long,
  wall,
}
const epsilon = 1e-6
resolutionScale = Math.max(resolutionScale, 1)
if (document.querySelectorAll("canvas").length > 1) {
  document.querySelectorAll("canvas")[0].parentElement.children[1].remove()
}
let gamecan = document.querySelector("canvas")
let canvas = document.createElement("canvas")
canvas.height = gamecan.height
canvas.width = gamecan.width
canvas.style.height = gamecan.style.height
canvas.style.width = gamecan.style.width
canvas.style.position = "relative"
canvas.style.top = `${0 - Number(gamecan.style.height.match(/\d*/))}px`
canvas.style.left = `0px`
gamecan.parentElement.append(canvas)
let ctx = canvas.getContext("2d")
sprite.visible = false
let lastFrameTime = performance.now()
let fps = 0
let smoothFPS = 0
const screenDimensions = {
  width: 480 / resolutionScale,
  height: 360 / resolutionScale,
  halfwidth: 240 / resolutionScale,
  halfheight: 180 / resolutionScale,
}
let zBuffer = new Float32Array(screenDimensions.width * screenDimensions.height)
let imageData = ctx.createImageData(
  screenDimensions.width,
  screenDimensions.height,
)
let pixelBuffer = imageData.data
enum levels {
  castle_grounds,

  inside_castle,
}

let level = levels.castle_grounds
let skybox = new Image()
updateSkyBox()

const nearZ = 0.1

function worldToView(vertex: Vector3): Vector3 {
  // Translation: Verschiebe den Punkt relativ zur Kamera
  let viewX = vertex.x - camera.x
  let viewY = vertex.y - camera.y
  let viewZ = vertex.z - camera.z

  // Rotation: Drehe den Punkt entgegengesetzt zur Kamera-Rotation
  // Reihenfolge: Yaw (um Y), dann Pitch (um X) wie in deiner ursprünglichen project Funktion
  const yawInRadians = camera.yaw
  const cosYaw = Math.cos(yawInRadians)
  const sinYaw = Math.sin(yawInRadians)
  const rotatedX = cosYaw * viewX + sinYaw * viewZ
  const rotatedZ = -sinYaw * viewX + cosYaw * viewZ // Drehung um Y
  viewX = rotatedX
  viewZ = rotatedZ // viewZ ist jetzt rotiert

  const pitchInRadians = camera.pitch
  const cosPitch = Math.cos(pitchInRadians)
  const sinPitch = Math.sin(pitchInRadians)
  const rotatedY = cosPitch * viewY - sinPitch * viewZ // Nutzt den rotierten viewZ
  const rotatedZ2 = sinPitch * viewY + cosPitch * viewZ // Nutzt den rotierten viewZ, dies ist die finale Tiefe
  viewY = rotatedY
  viewZ = rotatedZ2 // Der finale Z-Wert in Kamera-Koordinaten (Tiefe)

  return new Vector3(viewX, viewY, viewZ) // Gibt den Eckpunkt in Kamera-Koordinaten zurück
}

function viewToScreen(vertex: Vector3): { x: number; y: number; z: number } {
  if (vertex.z <= epsilon) {
    console.warn("viewToScreen: Punkt hinter/auf Projektionsebene!")
    return { x: -1, y: -1, z: vertex.z }
  }

  // Perspektivische Division
  const screenX = (projectionDistance * vertex.x) / vertex.z
  const screenY = (projectionDistance * vertex.y) / vertex.z // Korrigiert: War / vertex.y im Original

  // Skalierung und Verschiebung auf Canvas-Pixel
  const aspectRatio = screenDimensions.width / screenDimensions.height
  // Deine ursprüngliche project Funktion skalierte screenY zusätzlich mit aspectRatio.
  const canvasX =
    screenDimensions.halfwidth + screenX * screenDimensions.halfwidth
  const canvasY =
    screenDimensions.halfheight -
    screenY * screenDimensions.halfheight * aspectRatio // Aspect ratio hier

  return {
    x: canvasX,
    y: canvasY,
    z: vertex.z, // Gibt den Z-Wert in Kamera-Koordinaten als Tiefe für Z-Buffering zurück
  }
}

type ViewSpaceTriangle = [Vector3, Vector3, Vector3]

// NEU: Helper function to interpolate a point along an edge
// based on parameter t. Used in clipping to find intersection points.
function interpolateVertices(vA: Vector3, vB: Vector3, t: number): Vector3 {
  return new Vector3(
    vA.x + t * (vB.x - vA.x),
    vA.y + t * (vB.y - vA.y),
    vA.z + t * (vB.z - vA.z),
  )
}

function clipTriangleAgainstNearPlane(
  triangle: ViewSpaceTriangle,
): ViewSpaceTriangle[] {
  const v1 = triangle[0]
  const v2 = triangle[1]
  const v3 = triangle[2]
  const nearZ = 0.1 // Die Z-Koordinate der Nah-Ebene in View Space
  // Dein epsilon ist bereits global definiert

  // 1. Überprüfe, welche Eckpunkte deutlich vor der Nah-Ebene liegen
  // Verwende v.z > nearZ + epsilon, um Punkte genau auf der Ebene als "außen" zu behandeln.
  const v1_inside = v1.z > nearZ + epsilon
  const v2_inside = v2.z > nearZ + epsilon
  const v3_inside = v3.z > nearZ + epsilon

  // Zähle, wie viele Eckpunkte deutlich vor der Ebene liegen
  const numInside =
    (v1_inside ? 1 : 0) + (v2_inside ? 1 : 0) + (v3_inside ? 1 : 0)

  // --- 2. Bearbeite die Fälle basierend auf der Anzahl der Eckpunkte innen ---

  if (numInside === 0) {
    // Case 0: Alle Eckpunkte sind hinter oder sehr nahe an der Ebene.
    return [] // Verwirf das Dreieck.
  }

  if (numInside === 3) {
    // Case 3: Alle Eckpunkte sind deutlich vor der Ebene.
    return [triangle] // Behalte das ursprüngliche Dreieck.
  }

  // Case 1 oder 2 innen: Das Dreieck schneidet die Nah-Ebene.
  // Wir müssen Schnittpunkte finden und neue Dreiecke bilden.

  // Helper, um den Schnittpunkt einer Kante (vA zu vB) mit der Ebene Z = planeZ zu berechnen.
  // Nimmt an, dass vA und vB auf unterschiedlichen Seiten der Ebene liegen.
  // Formel für t: vA.z + t * (vB.z - vA.z) = planeZ  -> t = (planeZ - vA.z) / (vB.z - vA.z)
  function getIntersection(vA: Vector3, vB: Vector3, planeZ: number): Vector3 {
    // Vermeide Division durch Null, falls Kante parallel zur Ebene
    if (Math.abs(vB.z - vA.z) < epsilon) {
      console.warn("Clipping Kante parallel zur Ebene!")
      return vA // Notfall-Rückgabe
    }
    const t = (planeZ - vA.z) / (vB.z - vA.z)
    // Klemme t auf [0, 1], um sicherzustellen, dass der Schnittpunkt auf dem KANTENsegment liegt.
    const clampedT = Math.max(0, Math.min(1, t))
    return interpolateVertices(vA, vB, clampedT) // Verwende den geklemmten t-Wert
  }

  // Liste, um die Eckpunkte des resultierenden Polygons zu sammeln (in Reihenfolge entlang der Kanten)
  const clippedPolygonsVertices: Vector3[] = []
  const originalVertices = [v1, v2, v3]
  const insideFlags = [v1_inside, v2_inside, v3_inside]

  // Gehe entlang der Kanten des Originaldreiecks (V1->V2, V2->V3, V3->V1)
  for (let i = 0; i < 3; i++) {
    const currentVertex = originalVertices[i]
    const nextVertex = originalVertices[(i + 1) % 3] // %3 sorgt für V3 -> V1
    const currentInside = insideFlags[i]
    const nextInside = insideFlags[(i + 1) % 3]

    if (currentInside) {
      // Wenn der aktuelle Punkt innen ist, behalte ihn für das resultierende Polygon.
      clippedPolygonsVertices.push(currentVertex)
    }

    if (currentInside !== nextInside) {
      // Wenn die Kante die Ebene kreuzt (ein Endpunkt innen, einer außen)
      // Berechne den Schnittpunkt und füge ihn zum resultierenden Polygon hinzu.
      const intersectionPoint = getIntersection(
        currentVertex,
        nextVertex,
        nearZ,
      )
      clippedPolygonsVertices.push(intersectionPoint)
    }
  }

  // clippedPolygonsVertices enthält jetzt die Eckpunkte des resultierenden Polygons
  // in Reihenfolge (3 Eckpunkte für Case 1 innen, 4 für Case 2 innen).

  // Nun trianguliere das Ergebnis (es ist ein konvexes Polygon).
  if (clippedPolygonsVertices.length < 3) {
    // Sollte nicht passieren, wenn Clipping korrekt, aber zur Sicherheit.
    return [] // Kein gültiges Polygon
  }
  if (clippedPolygonsVertices.length === 3) {
    // Das Ergebnis ist ein Dreieck (Passiert bei Case 1 innen).
    return [
      [
        clippedPolygonsVertices[0],
        clippedPolygonsVertices[1],
        clippedPolygonsVertices[2],
      ],
    ]
  }
  if (clippedPolygonsVertices.length === 4) {
    // Das Ergebnis ist ein Viereck (Passiert bei Case 2 innen). Trianguliere in 2 Dreiecke.
    // Nimm den ersten Punkt als Anker und bilde Dreiecke mit ihm und den anderen Punktpaaren.
    return [
      [
        clippedPolygonsVertices[0],
        clippedPolygonsVertices[1],
        clippedPolygonsVertices[2],
      ], // Dreieck 1 (0, 1, 2)
      [
        clippedPolygonsVertices[0],
        clippedPolygonsVertices[2],
        clippedPolygonsVertices[3],
      ], // Dreieck 2 (0, 2, 3)
    ]
  }

  // Falls etwas schief ging und mehr als 4 Punkte rauskommen (sollte nicht passieren bei Dreieck Input)
  console.error(
    "clipTriangleAgainstNearPlane: Clipping erzeugte Polygon mit mehr als 4 Eckpunkten!",
  )
  return []
}

function project(vertex: Vector3): { x: number; y: number; z: number } | null {
  let worldX = vertex.x - camera.x
  let worldY = vertex.y - camera.y
  let worldZ = vertex.z - camera.z

  const yawInRadians = camera.yaw
  const cosYaw = Math.cos(yawInRadians)
  const sinYaw = Math.sin(yawInRadians)
  const rotatedX = cosYaw * worldX + sinYaw * worldZ
  const rotatedZ = -sinYaw * worldX + cosYaw * worldZ
  worldX = rotatedX
  worldZ = rotatedZ

  const pitchInRadians = camera.pitch
  const cosPitch = Math.cos(pitchInRadians)
  const sinPitch = Math.sin(pitchInRadians)
  const rotatedY = cosPitch * worldY - sinPitch * worldZ
  const rotatedZ2 = sinPitch * worldY + cosPitch * worldZ
  worldY = rotatedY
  worldZ = rotatedZ2

  if (worldZ <= 0.1) {
    return null // Vertex is behind the camera
  }

  const screenX = (projectionDistance * worldX) / worldZ
  const screenY = (projectionDistance * worldY) / worldZ

  const aspectRatio = screenDimensions.width / screenDimensions.height

  const canvasX =
    screenDimensions.halfwidth + screenX * screenDimensions.halfwidth
  const canvasY =
    screenDimensions.halfheight -
    screenY * screenDimensions.halfheight * aspectRatio

  return {
    x: canvasX,
    y: canvasY,
    z: worldZ, // Return depth for Z-buffering
  }
}

// Represents rotation around pitch, yaw, and roll axes.
class rotation {
  pitch: number
  yaw: number
  roll: number
  constructor(yaw: number, pitch: number, roll: number) {
    this.pitch = pitch
    this.yaw = yaw
    this.roll = roll
  }
}

// Represents a 3D vector with common vector operations.
class Vector3 {
  x: number
  y: number
  z: number

  constructor(x: number = 0, y: number = 0, z: number = 0) {
    this.x = x
    this.y = y
    this.z = z
  }

  scale(amount: number): Vector3 {
    return new Vector3(this.x * amount, this.y * amount, this.z * amount)
  }

  add(other: Vector3): Vector3 {
    return new Vector3(this.x + other.x, this.y + other.y, this.z + other.z)
  }

  subtract(other: Vector3): Vector3 {
    return new Vector3(this.x - other.x, this.y - other.y, this.z - other.z)
  }

  // Calculates the cross product of this vector and another.
  cross(other: Vector3): Vector3 {
    return new Vector3(
      this.y * other.z - this.z * other.y,
      this.z * other.x - this.x * other.z,
      this.x * other.y - this.y * other.x,
    )
  }

  magnitude(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }

  // Returns a new vector with the same direction but unit length.
  normalize(): Vector3 {
    const mag = this.magnitude()
    if (mag > 1e-6) {
      return new Vector3(this.x / mag, this.y / mag, this.z / mag)
    } else {
      return new Vector3(0, 0, 0)
    }
  }

  // Calculates the dot product of this vector and another.
  dot(other: Vector3): number {
    return this.x * other.x + this.y * other.y + this.z * other.z
  }
}

class AnimatableObject {
  position: Vector3
  rotation: rotation
  model: Triangle[]

  constructor(position: Vector3, rotation: rotation, model: Triangle[]) {
    this.position = position
    this.rotation = rotation
    this.model = model
  }
}

// Calculates the normal vector for a triangle defined by three vertices.
function calculateNormal(v1: Vector3, v2: Vector3, v3: Vector3): Vector3 {
  const edge1 = v2.subtract(v1)
  const edge2 = v3.subtract(v1)
  const normal = edge1.cross(edge2)
  return normal.normalize()
}

// Scales a vector relative to a given center point.
function scaleVector3(vec: Vector3, center: Vector3, factor: number): Vector3 {
  const diff = vec.subtract(center)
  const scaledDiff = new Vector3(
    diff.x * factor,
    diff.y * factor,
    diff.z * factor,
  )
  return center.add(scaledDiff)
}
function fillScanline(
  y: number,
  x1: number,
  x2: number,
  z1: number,
  z2: number,
  rByte: number,
  gByte: number,
  bByte: number,
  applyZBias: boolean,
) {
  const iy = Math.round(y)

  if (iy < 0 || iy >= screenDimensions.height) {
    return
  }

  let ix1 = Math.round(x1)
  let ix2 = Math.round(x2)

  const originalWidth = ix2 - ix1

  const screenWidth = screenDimensions.width
  const clippedIx1 = Math.max(0, Math.min(screenWidth - 1, ix1))
  const clippedIx2 = Math.max(0, Math.min(screenWidth - 1, ix2))

  if (clippedIx1 > clippedIx2) {
    return
  }

  let clippedZ1 = z1
  let clippedZ2 = z2

  if (originalWidth !== 0) {
    const t1 = (clippedIx1 - ix1) / originalWidth
    clippedZ1 = z1 + t1 * (z2 - z1)

    const t2 = (clippedIx2 - ix1) / originalWidth
    clippedZ2 = z1 + t2 * (z2 - z1)
  }

  const biasedZ1 = clippedZ1 + (applyZBias ? 3 : 0)
  const biasedZ2 = clippedZ2 + (applyZBias ? 3 : 0)

  const clippedWidth = clippedIx2 - clippedIx1
  let zStep = 0

  if (clippedWidth > 0) {
    zStep = (biasedZ2 - biasedZ1) / clippedWidth
  }

  let currentZ = biasedZ1

  for (let ix = clippedIx1; ix <= clippedIx2; ix++) {
    setPixel(ix, iy, currentZ, rByte, gByte, bByte, 255)
    currentZ += zStep
  }
}

function interpolate(
  y: number,
  vA: { x: number; y: number; z: number },
  vB: { x: number; y: number; z: number },
): { x: number; z: number } | null {
  const yDiff = vB.y - vA.y

  if (Math.abs(yDiff) < epsilon) {
    if (Math.abs(y - vA.y) < epsilon) {
      return { x: vA.x, z: vA.z }
    }
    return null
  }

  const t = (y - vA.y) / yDiff
  if (t < -epsilon || t > 1 + epsilon) return null

  const x = vA.x + t * (vB.x - vA.x)
  const z = vA.z + t * (vB.z - vA.z)
  return { x, z }
}

function fillTriangleProjected(triangle: Triangle) {
  const v1View = worldToView(triangle.vertices[0])
  const v2View = worldToView(triangle.vertices[1])
  const v3View = worldToView(triangle.vertices[2])
  const viewTriangle: ViewSpaceTriangle = [v1View, v2View, v3View]

  const v1v2View = v2View.subtract(v1View)
  const v1v3View = v3View.subtract(v1View)
  const normalView = v1v2View.cross(v1v3View).normalize()

  const cameraForwardViewActual = new Vector3(0, 0, 1)

  const dotCullingCorrectedView = normalView.dot(cameraForwardViewActual)

  if (dotCullingCorrectedView > epsilon && !triangle.isPlayer) {
    return
  }

  let clippedTrianglesView = clipTriangleAgainstNearPlane(viewTriangle)

  let finalClippedTriangles = clippedTrianglesView

  finalClippedTriangles.forEach((clippedTriView) => {
    const p1 = viewToScreen(clippedTriView[0])
    const p2 = viewToScreen(clippedTriView[1])
    const p3 = viewToScreen(clippedTriView[2])

    const projectedPoints2D = [p1, p2, p3]
    projectedPoints2D.sort((a, b) => a.y - b.y)

    const pp1 = projectedPoints2D[0]
    const pp2 = projectedPoints2D[1]
    const pp3 = projectedPoints2D[2]

    let rFloat = 1.0,
      gFloat = 1.0,
      bFloat = 1.0
    const initialColor = hexToRgb(triangle.color)

    if (initialColor !== null) {
      rFloat = initialColor.r
      gFloat = initialColor.g
      bFloat = initialColor.b

      if (!triangle.bakedLight) {
        const lightLevels = calculateLightLevel(triangle.normal)
        rFloat = Math.max(0, Math.min(1, rFloat + lightLevels))
        gFloat = Math.max(0, Math.min(1, gFloat + lightLevels))
        bFloat = Math.max(0, Math.min(1, bFloat + lightLevels))
      }
    }

    const rByte = Math.floor(rFloat * 255)
    const gByte = Math.floor(gFloat * 255)
    const bByte = Math.floor(bFloat * 255)

    const startY = Math.round(pp1.y)
    const endY = Math.round(pp3.y)

    const clampedStartY = Math.max(
      0,
      Math.min(screenDimensions.height - 1, startY),
    )
    const clampedEndY = Math.max(0, Math.min(screenDimensions.height - 1, endY))

    for (let y = clampedStartY; y <= clampedEndY; y++) {
      const scanlineP1 = interpolate(y, pp1, pp3)

      let scanlineP2 = null
      if (y < pp2.y) {
        scanlineP2 = interpolate(y, pp1, pp2)
      } else {
        scanlineP2 = interpolate(y, pp2, pp3)
      }

      if (scanlineP1 !== null && scanlineP2 !== null) {
        if (scanlineP1.x < scanlineP2.x) {
          fillScanline(
            y,
            scanlineP1.x,
            scanlineP2.x,
            scanlineP1.z,
            scanlineP2.z,
            rByte,
            gByte,
            bByte,
            triangle.applyZBias,
          )
        } else {
          fillScanline(
            y,
            scanlineP2.x,
            scanlineP1.x,
            scanlineP2.z,
            scanlineP1.z,
            rByte,
            gByte,
            bByte,
            triangle.applyZBias,
          )
        }
      }
    }
  })
}

// Represents a renderable triangle with color, normal, and lighting properties.
class Triangle {
  vertices: [Vector3, Vector3, Vector3]
  color: string
  normal: Vector3
  bakedLight: boolean
  isPlayer: boolean
  applyZBias: boolean // For Z-buffering order control

  constructor(
    v1: Vector3,
    v2: Vector3,
    v3: Vector3,
    color: string = "white",
    normal: Vector3,
    bakedLight: boolean,
    isPlayer: boolean = false,
    applyZBias: boolean = false,
  ) {
    this.vertices = [v1, v2, v3]
    this.color = color
    this.normal = normal
    this.bakedLight = bakedLight
    this.isPlayer = isPlayer
    this.applyZBias = applyZBias
  }
}

// Represents a triangle used for collision detection.
class collisionTriangle {
  vertices: [Vector3, Vector3, Vector3]
  normal: Vector3
  collisionType: collisionTypes
  originOffset: number // Distance from origin to the plane along the normal

  constructor(
    v1: Vector3,
    v2: Vector3,
    v3: Vector3,
    normal: Vector3,
    collisionType: collisionTypes = collisionTypes.wall,
  ) {
    this.originOffset = 0
    this.vertices = [v1, v2, v3]
    this.collisionType = collisionType
    this.normal = normal
  }

  // Updates collision data based on potentially transformed world vertices and normal.
  updateCollisionData(
    worldVertices: [Vector3, Vector3, Vector3],
    worldNormal: Vector3,
  ): void {
    this.vertices = worldVertices
    this.normal = worldNormal.normalize()

    // Determine collision type based on the up component of the normal
    if (this.normal.y > 0.01) {
      this.collisionType = collisionTypes.floor
    } else if (this.normal.y < -0.01) {
      this.collisionType = collisionTypes.ceiling
    } else {
      this.collisionType = collisionTypes.wall
    }
    // Calculate the plane equation constant (Ax + By + Cz + D = 0, where D = -normal.dot(vertex))
    this.originOffset = -this.normal.dot(this.vertices[0])
  }
}

let player = {
  position: new Vector3(0, 0, 0),
  yaw: 0,
  pitch: 0,
  roll: 0,
  forwardVel: 0,
  slideVelX: 0,
  slideVelZ: 0,
  verticalVel: 0,
  intendedYaw: 0,
  animWannaState: 0,
  state: state.ground,
  currentAnimation: animations.idle,
  height: 8,
  radius: 2.5,
  canMove: true,
  bonkedTimer: 0,
  bonked: false,
  skiddingTime: 0,
  skiddingAngle: 0,
  sneaking: false,
  sneak_walk: false,
  long_jump: false,
  groundTriangle: new collisionTriangle(
    new Vector3(0, 0, 0),
    new Vector3(0, 0, 0),
    new Vector3(0, 0, 0),
    new Vector3(0, 0, 0),
  ),
  wallTriangle: new collisionTriangle(
    new Vector3(0, 0, 0),
    new Vector3(0, 0, 0),
    new Vector3(0, 0, 0),
    new Vector3(0, 0, 0),
  ),
}

const LEVEL_BOUNDARY_MAX = 600 // Max extent of the level in world units
const CELL_SIZE = 40 // Size of a grid cell in world units
const LEVEL_DIMENSION = LEVEL_BOUNDARY_MAX * 2 // Total dimension of the level (e.g., 400)
const NUM_CELLS_PER_DIMENSION = Math.ceil(LEVEL_DIMENSION / CELL_SIZE) // Number of grid cells along one dimension
const NUM_CELLS_INDEX = NUM_CELLS_PER_DIMENSION // Alias for clarity

let staticSurfacePartitionTriangles: collisionTriangle[] = []
const staticSurfacePartition: number[][][] = []

let scene: Triangle[] = []

let collisionMap: collisionTriangle[] = []
let playerCenter = new Vector3(0, 0, 0)
let playerCount = 0
const wispy =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/wisp_anim"
const collisionMapModel =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/bbb"
//const collisionMapModel =
//  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/map2"

async function loadResources() {
  loadCollisionMap()
  importPlayer()
  //wait(0.5)
}
loadResources()

function initializeSpatialPartition() {
  for (let z = 0; z < NUM_CELLS_PER_DIMENSION; z++) {
    staticSurfacePartition[z] = new Array<number[]>(NUM_CELLS_PER_DIMENSION)

    for (let x = 0; x < NUM_CELLS_PER_DIMENSION; x++) {
      staticSurfacePartition[z][x] = [] as number[]
    }
  }
  console.log(
    `Räumliche Partition initialisiert: ${NUM_CELLS_PER_DIMENSION}x${NUM_CELLS_PER_DIMENSION} Zellen.`,
  )
}

function setupStaticCollisionGeometry() {
  initializeSpatialPartition()

  collisionMap.forEach((colTriangle) => {
    const worldVertices = colTriangle.vertices
    const worldNormal = colTriangle.normal

    colTriangle.updateCollisionData(
      worldVertices as [Vector3, Vector3, Vector3],
      worldNormal,
    )
    staticSurfacePartitionTriangles.push(colTriangle)
    addTriangleToPartition_BoundingBox(colTriangle)
  })

  console.log("Statische Kollisionsgeometrie im Grid eingerichtet.")
}

function getWorldCoordsCellIndices(
  worldX: number,
  worldZ: number,
): { cellX: number; cellZ: number } {
  const cellX = Math.floor((worldX + LEVEL_BOUNDARY_MAX) / CELL_SIZE)
  const cellZ = Math.floor((worldZ + LEVEL_BOUNDARY_MAX) / CELL_SIZE)

  return { cellX: cellX, cellZ: cellZ }
}

function addTriangleToPartition_BoundingBox(triangle: collisionTriangle): void {
  const minX = Math.min(
    triangle.vertices[0].x,
    triangle.vertices[1].x,
    triangle.vertices[2].x,
  )
  const maxX = Math.max(
    triangle.vertices[0].x,
    triangle.vertices[1].x,
    triangle.vertices[2].x,
  )
  const minZ = Math.min(
    triangle.vertices[0].z,
    triangle.vertices[1].z,
    triangle.vertices[2].z,
  )
  const maxZ = Math.max(
    triangle.vertices[0].z,
    triangle.vertices[1].z,
    triangle.vertices[2].z,
  )

  const startCellIndices = getWorldCoordsCellIndices(minX, minZ)
  const startCellX = startCellIndices.cellX
  const startCellZ = startCellIndices.cellZ

  const endCellIndices = getWorldCoordsCellIndices(maxX, maxZ)
  const endCellX = endCellIndices.cellX
  const endCellZ = endCellIndices.cellZ

  const clampedStartCellX = Math.max(0, startCellX)
  const clampedEndCellX = Math.min(NUM_CELLS_PER_DIMENSION - 1, endCellX)
  const clampedStartCellZ = Math.max(0, startCellZ)
  const clampedEndCellZ = Math.min(NUM_CELLS_PER_DIMENSION - 1, endCellZ)

  for (let z = clampedStartCellZ; z <= clampedEndCellZ; z++) {
    for (let x = clampedStartCellX; x <= clampedEndCellX; x++) {
      if (Array.isArray(staticSurfacePartition[z]?.[x])) {
        staticSurfacePartition[z][x].push(
          staticSurfacePartitionTriangles.length - 1,
        )
      } else {
        console.error(
          `FEHLER: staticSurfacePartition[${z}][${x}] ist KEIN Array! Typ: ${typeof staticSurfacePartition[z]?.[x]}`,
          staticSurfacePartition[z]?.[x],
        )
      }
    }
  }
}

function calculateLightDirection(yaw: number, pitch: number): Vector3 {
  let dir = new Vector3(0, 0, 1)

  const cosPitch = Math.cos(pitch)
  const sinPitch = Math.sin(pitch)
  const pitchedY = dir.y * cosPitch - dir.z * sinPitch
  const pitchedZ = dir.y * sinPitch + dir.z * cosPitch
  dir.y = pitchedY
  dir.z = pitchedZ

  const cosYaw = Math.cos(yaw)
  const sinYaw = Math.sin(yaw)
  const yawedX = dir.x * cosYaw + dir.z * sinYaw
  const yawedZ = dir.z * cosYaw - dir.x * sinYaw
  dir.x = yawedX
  dir.z = yawedZ

  return dir.normalize()
}

function calculateLightLevel(normal: Vector3): number {
  const dot = normal.dot(lightDir)

  const levelFloat = dot + 0.5

  return levelFloat / 8
}

function getRandomColor() {
  const letters = "0123456789ABCDEF"
  let color = "#"
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random(0, 1) * 16)]
  }
  return color
}

let playerObj: {
  leftArm: AnimatableObject
  rightArm: AnimatableObject
  Head: AnimatableObject
  Body: AnimatableObject
  leftLeg: AnimatableObject
  rightLeg: AnimatableObject
} = {
  leftArm: resetAnimatableObject(),
  rightArm: resetAnimatableObject(),
  Head: resetAnimatableObject(),
  Body: resetAnimatableObject(),
  leftLeg: resetAnimatableObject(),
  rightLeg: resetAnimatableObject(),
}

function rgbToUint32(r: number, g: number, b: number, a: number = 1.0): number {
  const ir = Math.floor(Math.max(0.0, Math.min(1.0, r)) * 255 + 0.5)
  const ig = Math.floor(Math.max(0.0, Math.min(1.0, g)) * 255 + 0.5)
  const ib = Math.floor(Math.max(0.0, Math.min(1.0, b)) * 255 + 0.5)
  const ia = Math.floor(Math.max(0.0, Math.min(1.0, a)) * 255 + 0.5)
  return (ia << 24) | (ir << 16) | (ig << 8) | ib
}

//__ RGB zu Hex Konverter __
function rgbToHex(r: number, g: number, b: number): string {
  const toHex = (c: number): string => {
    const clampedC = Math.max(0, Math.min(1, c))
    const hex = Math.floor(clampedC * 255).toString(16)
    return hex.length === 1 ? "0" + hex : hex
  }
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`
}

function hexToRgb(
  hexString: string,
): { r: number; g: number; b: number } | null {
  const cleanHexString = hexString.startsWith("#")
    ? hexString.slice(1)
    : hexString

  if (cleanHexString.length !== 6) {
    console.error(
      `Ungültige Hex-String Länge: "${hexString}". Erwarte 6 Zeichen (oder 7 mit #).`,
    )
    return null // Ungültige Länge
  }

  const rHex = cleanHexString.substring(0, 2)
  const gHex = cleanHexString.substring(2, 4)
  const bHex = cleanHexString.substring(4, 6)

  const rInt = parseInt(rHex, 16)
  const gInt = parseInt(gHex, 16)
  const bInt = parseInt(bHex, 16)

  if (isNaN(rInt) || isNaN(gInt) || isNaN(bInt)) {
    console.error(`Ungültige Hex-Zeichen im String: "${hexString}".`)
    return null
  }

  const rFloat = rInt / 255.0
  const gFloat = gInt / 255.0
  const bFloat = bInt / 255.0

  return { r: rFloat, g: gFloat, b: bFloat }
}

function resetAnimatableObject() {
  return new AnimatableObject(new Vector3(0, 0, 0), new rotation(0, 0, 0), [])
}

forever(function () {
  gameLoop()
})

function drawFrame() {
  ctx.clearRect(0, 0, gamecan.width, gamecan.height)
  zBuffer.fill(Infinity)
  pixelBuffer.fill(0)

  scene
    .filter((triangle) => !triangle.isPlayer)
    .forEach((triangle) => {
      fillTriangleProjected(triangle)
    })

  const outlineScaleFactor = 1.1
  const outlineColor = "#333333"
  const off = 0

  scene
    .filter((triangle) => triangle.isPlayer)
    .forEach((originalPlayerTriangle) => {
      const center = playerCenter.add(
        new Vector3(
          player.position.x,
          player.position.y + off,
          player.position.z,
        ),
      )
      const scaledV1 = scaleVector3(
        originalPlayerTriangle.vertices[0],
        center,
        outlineScaleFactor,
      )
      const scaledV2 = scaleVector3(
        originalPlayerTriangle.vertices[1],
        center,
        outlineScaleFactor,
      )
      const scaledV3 = scaleVector3(
        originalPlayerTriangle.vertices[2],
        center,
        outlineScaleFactor,
      )

      const outlineTriangle = new Triangle(
        scaledV1,
        scaledV2,
        scaledV3,
        outlineColor,
        calculateNormal(scaledV1, scaledV2, scaledV3),
        true,
        true,
        true,
      )

      fillTriangleProjected(outlineTriangle)
    })

  scene
    .filter((triangle) => triangle.isPlayer)
    .forEach((triangle) => {
      fillTriangleProjected(triangle)
    })

  ctx.putImageData(imageData, 0, 0)

  drawFPS()

  scene
    .filter((triangle) => triangle.isPlayer)
    .forEach((triangle) => {
      scene.pop()
    })
}

function gameLoop() {
  inputs()
  updatePlayer()
  updateCamera()
  updateLight()
  updateAnimations()
  drawFrame()
  //requestAnimationFrame(gameLoop);
}

function updateLight() {
  lightDir = calculateLightDirection(light.yaw, light.pitch)
}

let animationTimer = 0
let animationTime = 0
let animTime = 0
let animTime2 = 0
let speed = 0
function updateAnimations() {
  const animatedBodyTriangles = setAnimationTypePositionsRotations(
    playerObj.Body,
  )
  const animatedHeadTriangles = setAnimationTypePositionsRotations(
    playerObj.Head,
  )
  const animatedLeftArmTriangles = setAnimationTypePositionsRotations(
    playerObj.leftArm,
  )
  const animatedRightArmTriangles = setAnimationTypePositionsRotations(
    playerObj.rightArm,
  )
  const animatedLeftLegTriangles = setAnimationTypePositionsRotations(
    playerObj.leftLeg,
  )
  const animatedRightLegTriangles = setAnimationTypePositionsRotations(
    playerObj.rightLeg,
  )

  scene = scene.concat(
    animatedBodyTriangles,
    animatedHeadTriangles,
    animatedLeftArmTriangles,
    animatedRightArmTriangles,
    animatedLeftLegTriangles,
    animatedRightLegTriangles,
  )
}

function setAnimationTypePositionsRotations(
  anim: AnimatableObject,
): Triangle[] {
  const endModel: Triangle[] = []

  anim.model?.forEach((triangle) => {
    const transformedVerts: Vector3[] = triangle.vertices.map((v) => {
      let newPos = applyRotation(
        v,
        new rotation(
          anim.rotation.yaw,
          anim.rotation.pitch,
          anim.rotation.roll,
        ),
      )
      newPos = newPos.add(anim.position)
      newPos = applyRotation(
        newPos,
        new rotation(player.yaw + 90, player.roll, player.pitch),
      )
      return newPos.add(player.position)
    })

    const transformedTriangle = new Triangle(
      transformedVerts[0],
      transformedVerts[1],
      transformedVerts[2],
      triangle.color,
      calculateNormal(
        transformedVerts[0],
        transformedVerts[1],
        transformedVerts[2],
      ),
      triangle.bakedLight,
      triangle.isPlayer,
      triangle.applyZBias,
    )

    endModel.push(transformedTriangle)
  })

  return endModel
}

function applyRotation(vec: Vector3, rot: rotation): Vector3 {
  // einfache Rotation um X, Y, Z – in Radiant umrechnen!
  const rx = rot.pitch
  const ry = rot.yaw
  const rz = rot.roll

  let v = new Vector3(vec.x, vec.y, vec.z)

  // Rotation um X (Pitch)
  v = new Vector3(
    v.x,
    v.y * Math.cos(rx) - v.z * Math.sin(rx),
    v.y * Math.sin(rx) + v.z * Math.cos(rx),
  )

  // Rotation um Y (Yaw)
  v = new Vector3(
    v.x * Math.cos(ry) + v.z * Math.sin(ry),
    v.y,
    -v.x * Math.sin(ry) + v.z * Math.cos(ry),
  )

  // Rotation um Z (Roll)
  v = new Vector3(
    v.x * Math.cos(rz) - v.y * Math.sin(rz),
    v.x * Math.sin(rz) + v.y * Math.cos(rz),
    v.z,
  )

  return v
}

function drawSkyBox() {
  const scaleFactor = screenDimensions.height / skybox.height
  ctx.drawImage(
    skybox,
    0,
    0,
    skybox.width * scaleFactor,
    skybox.height * scaleFactor,
  )
}

function setPixel(
  x: number,
  y: number,
  z: number, // Z-Wert (Tiefe), der bereits den Z-Bias enthalten kann
  rByte: number,
  gByte: number,
  bByte: number,
  aByte: number = 255,
) {
  // Sicherstellen, dass die Pixel-Koordinaten im gültigen Bereich liegen, bevor auf Arrays zugegriffen wird.
  const ix = Math.floor(x) // Boden für Array-Indizes verwenden
  const iy = Math.floor(y) // Boden für Array-Indizes verwenden

  if (
    ix < 0 ||
    iy < 0 ||
    ix >= screenDimensions.width ||
    iy >= screenDimensions.height
  ) {
    return // Pixel außerhalb der Bildschirmgrenzen ignorieren
  }

  const index = iy * screenDimensions.width + ix // Berechne den Index im 1D-Array

  // Z-Buffering Check: Nur zeichnen, wenn dieser Pixel näher liegt als das, was aktuell im Z-Buffer ist.
  // 'z' ist der Tiefenwert des aktuellen Pixels, der ggf. schon den Z-Bias enthält.
  if (z < zBuffer[index]) {
    zBuffer[index] = z // Aktualisiere den Z-Buffer mit dem neuen, näheren Z-Wert

    // Aktualisiere die Pixeldaten im Pixel-Buffer.
    const pixelIndex = index * 4 // Jeder Pixel benötigt 4 Bytes (R, G, B, A)
    pixelBuffer[pixelIndex] = rByte // Rot-Kanal
    pixelBuffer[pixelIndex + 1] = gByte // Grün-Kanal
    pixelBuffer[pixelIndex + 2] = bByte // Blau-Kanal
    pixelBuffer[pixelIndex + 3] = aByte // Alpha-Kanal (Transparenz)
  }
}

function drawFPS() {
  const now = performance.now()
  const delta = now - lastFrameTime
  lastFrameTime = now
  fps = 1000 / delta
  smoothFPS = smoothFPS * 0.9 + fps * 0.1
  ctx.fillStyle = "black"
  ctx.fillRect(0, 0, 230, 70)
  ctx.fillStyle = "lime"
  ctx.font = "bold 14px monospace"
  ctx.fillText("FPS: " + Math.round(smoothFPS), 5, 15)
  ctx.fillText(`X: ${camera.x.toFixed(2)}`, 5, 30)
  ctx.fillText(`Y: ${camera.y.toFixed(2)}`, 70, 30)
  ctx.fillText(`Z: ${camera.z.toFixed(2)}`, 135, 30)
  ctx.fillText(`FV: ${player.forwardVel.toFixed(2)}`, 5, 45)
  ctx.fillText(`PY: ${player.yaw.toFixed(2)}`, 80, 45)
  ctx.fillText(` WJ: ${player.bonkedTimer.toFixed(2)}`, 145, 45)
  ctx.fillText(`GR: ${player.verticalVel.toFixed(2)}`, 5, 60)
  ctx.fillText(`CM: ${player.skiddingTime.toFixed(2)}`, 120, 60)
  ctx.fillText(`IY: ${player.intendedYaw.toFixed(2)}`, 5, 75)
  ctx.fillText(`IX: ${intendedX.toFixed(2)}`, 5, 90)
  ctx.fillText(`IY: ${intendedY.toFixed(2)}`, 75, 90)
  ctx.fillText(`IM: ${intendedMag.toFixed(2)}`, 5, 105)
}

function updateSkyBox() {
  switch (level) {
    case levels.castle_grounds:
      //Credits: https://www.textures-resource.com/nintendo_64/mario64/texture/1315/
      skybox.src = "https://i.postimg.cc/s2J6Lz4J/castle-grounds.png"
      break
  }
}

function rotateTowardsAngleDegrees(
  currentAngle: number,
  targetAngle: number,
  rotationSpeed: number, // Maximale Drehgeschwindigkeit pro Update in Grad
): number {
  let angleDifference = targetAngle - currentAngle

  // Passt die Differenz so an, dass sie im Bereich (-180, 180] Grad liegt
  // Findet den kürzesten Drehweg
  while (angleDifference > 180) {
    angleDifference -= 360
  }
  while (angleDifference <= -180) {
    angleDifference += 360
  }

  // Berechnet den tatsächlichen Drehbetrag, begrenzt durch rotationSpeed
  const rotateAmount =
    Math.sign(angleDifference) *
    Math.min(Math.abs(angleDifference), rotationSpeed)

  // Berechnet den neuen Winkel
  let newAngle = currentAngle + rotateAmount

  while (newAngle <= -180) {
    newAngle += 360
  }
  while (newAngle > 180) {
    newAngle -= 360
  }

  return newAngle
}

function inputs() {
  intendedX = 0
  intendedY = 0
  intendedSpace = false
  intendedShift = false
  if (!camera.turningYaw) {
    if (Keyboard.keyDown(Key.ArrowRight)) {
      camera.targetYaw = camera.targetYaw - camera.stepAngle
      camera.targetYaw = ((camera.targetYaw % 360) + 360) % 360
      camera.turningYaw = true
    }
    if (Keyboard.keyDown(Key.ArrowLeft)) {
      camera.targetYaw = camera.targetYaw + camera.stepAngle
      camera.targetYaw = ((camera.targetYaw % 360) + 360) % 360
      camera.turningYaw = true
    }
  }
  if (player.canMove) {
    if (Keyboard.keyHeld(Key.W)) {
      intendedY += 32
    }
    if (Keyboard.keyHeld(Key.S)) {
      intendedY -= 32
    }
    if (Keyboard.keyHeld(Key.A)) {
      intendedX -= 32
    }
    if (Keyboard.keyHeld(Key.D)) {
      intendedX += 32
    }
    if (Keyboard.keyHeld(Key.Shift)) {
      intendedShift = true
    }
    intendedMag = Math.sqrt(intendedX * intendedX + intendedY * intendedY)
    player.intendedYaw =
      -camera.yaw + (atan22(intendedX, intendedY) * 180) / Math.PI
  }
  if (Keyboard.keyDown(Key.Space) || Keyboard.keyDown(Key.B)) {
    intendedSpace = true
  }
}

function atan2(x: number, y: number): number {
  const RADIANS_TO_DEGREES = 180 / Math.PI
  x = Math.floor(x * 100) / 100
  y = Math.floor(y * 100) / 100
  if (x > 0) {
    return Math.atan(y / x) * RADIANS_TO_DEGREES
  } else if (x < 0 && y >= 0) {
    return (Math.atan(y / x) + Math.PI) * RADIANS_TO_DEGREES
  } else if (x < 0 && y < 0) {
    return (Math.atan(y / x) - Math.PI) * RADIANS_TO_DEGREES
  } else if (x === 0 && y > 0) {
    return 90
  } else if (x === 0 && y < 0) {
    return -90
  } else {
    return 0
  }
}

function atan22(y: number, x: number): number {
  x = Math.floor(x * 100) / 100
  y = Math.floor(y * 100) / 100
  if (x > 0) {
    return Math.atan(y / x) * (Math.PI / 180)
  } else if (x < 0 && y >= 0) {
    return Math.atan(y / x) * (Math.PI / 180) + Math.PI
  } else if (x < 0 && y < 0) {
    return Math.atan(y / x) * (Math.PI / 180) - Math.PI
  } else if (x === 0 && y > 0) {
    return Math.PI / 2
  } else if (x === 0 && y < 0) {
    return -Math.PI / 2
  } else {
    return 0
  }
}

function updateCamera() {
  const cameraDist = 15
  const cameraHeightOffset = 8
  const cameraPitchAngle = -10

  if (camera.turningYaw) {
    let diff = camera.targetYaw - camera.yaw
    diff = ((diff % 360) + 360) % 360
    if (diff > 180) {
      diff -= 360
    }

    if (Math.abs(diff) <= 0.1) {
      camera.yaw = camera.targetYaw
      camera.turningYaw = false
    } else {
      camera.yaw +=
        Math.sign(diff) *
        Math.min(Math.abs(diff), camera.turningSpeedYaw * (1 / 60))
    }
  }

  camera.yaw = ((camera.yaw % 360) + 360) % 360
  camera.pitch = cameraPitchAngle
  let dirZ = Math.cos(camera.yaw) * Math.cos(camera.pitch)
  let dirY = Math.sin(camera.pitch)
  let dirX = Math.sin(camera.yaw) * Math.cos(camera.pitch)

  camera.x = player.position.x + dirX * cameraDist
  camera.y = player.position.y + cameraHeightOffset - dirY * cameraDist
  camera.z = player.position.z - dirZ * cameraDist
}

function loadModel(model: Triangle[], modelUrl: string) {
  fetch(modelUrl)
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      return response.json()
    })
    .then((data) => {
      const vertices = data.vertices
      const faces = data.faces
      let sumX = 0,
        sumY = 0,
        sumZ = 0
      playerCount = vertices.length
      for (const vert of vertices) {
        sumX += vert[0]
        sumY += vert[1]
        sumZ += vert[2]
      }
      if (playerCount > 0) {
        playerCenter = new Vector3(
          sumX / playerCount,
          sumY / playerCount,
          sumZ / playerCount,
        )
      }
      for (const face of faces) {
        const faceIndic = face[0]
        const faceColor = face[1]
        if (faceIndic.length === 3) {
          const v1_3D = new Vector3(...vertices[faceIndic[0]])
          const v2_3D = new Vector3(...vertices[faceIndic[1]])
          const v3_3D = new Vector3(...vertices[faceIndic[2]])

          const normal = calculateNormal(v1_3D, v2_3D, v3_3D)

          /*if (enable_outlines) {
            const triangle = new Triangle(
              v1_3D,
              v2_3D,
              v3_3D,
              faceColor,
              normal,
              false,
              true,
            )
            model.push(triangle)
          } else {*/
          const triangle = new Triangle(
            v1_3D,
            v2_3D,
            v3_3D,
            faceColor,
            normal,
            false,
            false,
          )
          scene.push(triangle)
          //}
        }
      }
    })
    .catch((error) => {
      console.error("fehler beim laden der modeldata:", error)
    })
}

function updatePlayer() {
  const isIdle = player.forwardVel == 0
  player_actions_moving(isIdle)
  if (player.state == state.ground) {
    if (!player.sneaking) {
      if (player.skiddingTime <= 0) {
        if (player.forwardVel == 0) {
          setPlayerAnimation(animations.idle)
        } else {
          setPlayerAnimation(animations.running)
        }
      } else {
        setPlayerAnimation(animations.skidding)
      }
    } else {
      if (player.sneak_walk) {
        if (
          Math.abs(player.forwardVel) < epsilon &&
          Math.abs(player.slideVelX) < epsilon &&
          Math.abs(player.slideVelZ) < epsilon
        ) {
          setPlayerAnimation(animations.sneakingIdle)
        } else {
          setPlayerAnimation(animations.crouch)
        }
      } else {
        setPlayerAnimation(animations.sneaking)
      }
    }
  } else if (player.state == state.air) {
    if (
      player.currentAnimation == animations.fall ||
      player.currentAnimation == animations.single_jumping_fall ||
      player.currentAnimation == animations.long_jump
    ) {
    } else {
      setPlayerAnimation(animations.fall)
    }
  }
  updatePlayerAnimations()
  //highlightPlayerGridCell()
  //setPlayerFloor()
}

function setPlayerAnimation(animationSet: animations) {
  if (player.currentAnimation != animationSet) {
    player.currentAnimation = animationSet
    player.animWannaState = 0
    animTime = 0
    animTime2 = 0
  }
}

function getFloors(
  x: number,
  z: number,
  collisionTrianglesCell: collisionTriangle[] = [],
  isPlayer: boolean = false,
): number[] {
  let heightList: number[] = []
  let groundTriangle: collisionTriangle = new collisionTriangle(
    new Vector3(0, 0, 0),
    new Vector3(0, 0, 0),
    new Vector3(0, 0, 0),
    new Vector3(0, 0, 0),
  )
  let collisionTriangles = collisionTrianglesCell
  if (collisionTriangles.length == 0) {
    collisionTriangles = getSurfaceTrianglesAt(x, z)
    if (collisionTriangles.length == 0) return []
  }
  collisionTriangles
    .filter((triangle) => triangle.collisionType === collisionTypes.floor)
    .forEach((triangle) => {
      const v1 = triangle.vertices[0]
      const v2 = triangle.vertices[1]
      const v3 = triangle.vertices[2]

      const cross_v1_v2 =
        (v2.z - v1.z) * (x - v1.x) - (v2.x - v1.x) * (z - v1.z)
      const cross_v2_v3 =
        (v3.z - v2.z) * (x - v2.x) - (v3.x - v2.x) * (z - v2.z)
      const cross_v3_v1 =
        (v1.z - v3.z) * (x - v3.x) - (v1.x - v3.x) * (z - v3.z)

      const isInside2D =
        (cross_v1_v2 >= -epsilon &&
          cross_v2_v3 >= -epsilon &&
          cross_v3_v1 >= -epsilon) ||
        (cross_v1_v2 <= epsilon &&
          cross_v2_v3 <= epsilon &&
          cross_v3_v1 <= epsilon)

      if (!isInside2D) return
      const nx = triangle.normal.x
      const ny = triangle.normal.y
      const nz = triangle.normal.z
      const oo = triangle.originOffset

      if (Math.abs(ny) < epsilon) {
        return []
      }

      const heightAtPoint = -(x * nx + nz * z + oo) / ny

      if (isPlayer) {
        if (player.state == state.ground) {
          if (
            player.position.y <= heightAtPoint + 5 &&
            player.position.y >= heightAtPoint
          )
            heightList.push(heightAtPoint)
        }
        if (
          player.position.y >= heightAtPoint - 2 &&
          player.position.y <= heightAtPoint
        )
          heightList.push(heightAtPoint)
        groundTriangle = triangle
      } else {
        heightList.push(heightAtPoint)
      }
    })
  if (isPlayer) player.groundTriangle = groundTriangle
  return heightList
}

function inCeiling(
  checkY: number,
  distanceY: number,
  ceilingHeights: number[],
): boolean {
  let inCeiling = false
  ceilingHeights.forEach((height) => {
    if (checkY < height && checkY + distanceY >= height) {
      inCeiling = true
    }
  })
  return inCeiling
}

function getCeilings(
  x: number,
  z: number,
  collisionTrianglesCell: collisionTriangle[] = [],
): number[] {
  let heightList: number[] = []
  let collisionTriangles = collisionTrianglesCell
  if (collisionTriangles.length == 0) {
    collisionTriangles = getSurfaceTrianglesAt(x, z)
    if (collisionTriangles.length == 0) return []
  }
  collisionTriangles
    .filter((triangle) => triangle.collisionType === collisionTypes.ceiling)
    .forEach((triangle) => {
      const v1 = triangle.vertices[0]
      const v2 = triangle.vertices[1]
      const v3 = triangle.vertices[2]

      const cross_v1_v2 =
        (v2.z - v1.z) * (x - v1.x) - (v2.x - v1.x) * (z - v1.z)
      const cross_v2_v3 =
        (v3.z - v2.z) * (x - v2.x) - (v3.x - v2.x) * (z - v2.z)
      const cross_v3_v1 =
        (v1.z - v3.z) * (x - v3.x) - (v1.x - v3.x) * (z - v3.z)

      const isInside2D =
        (cross_v1_v2 >= -epsilon &&
          cross_v2_v3 >= -epsilon &&
          cross_v3_v1 >= -epsilon) ||
        (cross_v1_v2 <= epsilon &&
          cross_v2_v3 <= epsilon &&
          cross_v3_v1 <= epsilon)

      if (!isInside2D) return
      const nx = triangle.normal.x
      const ny = triangle.normal.y
      const nz = triangle.normal.z
      const oo = triangle.originOffset

      if (Math.abs(ny) < epsilon) {
        return []
      }

      const heightAtPoint = -(x * nx + nz * z + oo) / ny

      heightList.push(heightAtPoint)
    })

  return heightList
}

function getSurfaceTrianglesAt(x: number, z: number): collisionTriangle[] {
  const cellIndices = getWorldCoordsCellIndices(x, z)
  let trianglesInCell: collisionTriangle[] = []
  let processedTriangleIndices: number[] = []
  const checkCellX = cellIndices.cellX
  const checkCellZ = cellIndices.cellZ
  if (
    checkCellX >= 0 &&
    checkCellX < NUM_CELLS_PER_DIMENSION &&
    checkCellZ >= 0 &&
    checkCellZ < NUM_CELLS_PER_DIMENSION
  ) {
    const cellTriangleIndices = staticSurfacePartition[checkCellZ]?.[checkCellX]
    if (cellTriangleIndices && Array.isArray(cellTriangleIndices)) {
      cellTriangleIndices.forEach((index) => {
        if (index >= 0 && index < staticSurfacePartitionTriangles.length) {
          if (!processedTriangleIndices.find((element) => element == index)) {
            trianglesInCell.push(staticSurfacePartitionTriangles[index])
            processedTriangleIndices.push(index)
          }
        } else {
          console.warn(
            `getSurfaceTrianglesAt: Ungültiger Dreiecksindex im Spatial Partition: ${index}`,
          )
        }
      })
    }
  }
  return trianglesInCell
}

function playerSetAir() {
  if (player.state != state.air) {
    player.verticalVel = Math.max(player.verticalVel, 0)
    setPlayerAnimation(animations.fall)
  }
  player.state = state.air
}

function highlightPlayerGridCell() {
  const playerX = player.position.x
  const playerZ = player.position.z
  const gridY = 4

  const cellIndices = getWorldCoordsCellIndices(playerX, playerZ)
  const playerCellX = cellIndices.cellX
  const playerCellZ = cellIndices.cellZ
  let trianglesInPlayerCell: number[] = []
  trianglesInPlayerCell = staticSurfacePartition[playerCellZ][playerCellX]

  if (
    playerCellX >= 0 &&
    playerCellX < NUM_CELLS_PER_DIMENSION &&
    playerCellZ >= 0 &&
    playerCellZ < NUM_CELLS_PER_DIMENSION
  ) {
    const worldX_min = playerCellX * CELL_SIZE - LEVEL_BOUNDARY_MAX
    const worldX_max = (playerCellX + 1) * CELL_SIZE - LEVEL_BOUNDARY_MAX
    const worldZ_min = playerCellZ * CELL_SIZE - LEVEL_BOUNDARY_MAX
    const worldZ_max = (playerCellZ + 1) * CELL_SIZE - LEVEL_BOUNDARY_MAX

    const v1 = new Vector3(worldX_min, gridY, worldZ_min)
    const v2 = new Vector3(worldX_max, gridY, worldZ_min)
    const v3 = new Vector3(worldX_max, gridY, worldZ_max)
    const v4 = new Vector3(worldX_min, gridY, worldZ_max)

    if (trianglesInPlayerCell.length > 0) {
      scene.push(
        new Triangle(v1, v2, v3, "#00FF00", new Vector3(0, 1, 0), false, true),
      )
      scene.push(
        new Triangle(v1, v4, v3, "#009900", new Vector3(0, 1, 0), false, true),
      )
    } else {
      scene.push(
        new Triangle(v1, v2, v3, "#000088", new Vector3(0, 1, 0), false, true),
      )
      scene.push(
        new Triangle(v1, v4, v3, "#000066", new Vector3(0, 1, 0), false, true),
      )
    }
  } else {
  }
}

function player_actions_moving(was_standing_still: boolean) {
  if (player.state == state.ground) {
    updateGroundMovement()
  } else if (player.state == state.air) {
    updateAirMovement()
  }
  function updateAirMovement() {
    player.roll = 0
    player.pitch = 0
    const gravityMult = 2
    let dragThreshold = 32
    if (player.long_jump) dragThreshold = 50
    let sidewaysSpeed = 0
    player.forwardVel = approach(player.forwardVel, 0, 0.175, 0.175)
    if (intendedX != 0 || intendedY != 0) {
      const intendedDYaw = player.intendedYaw - player.yaw
      const intendedMagThis = intendedMag / 32
      player.forwardVel += intendedMagThis * Math.cos(intendedDYaw) * 0.75
      sidewaysSpeed = intendedMagThis * Math.sin(intendedDYaw) * 5
    }
    if (player.forwardVel > dragThreshold) {
      player.forwardVel -= 1
    }
    if (player.forwardVel < -dragThreshold / 2) {
      player.forwardVel += 2
    }
    if (player.bonkedTimer > 0) {
      player.bonkedTimer--
      if (intendedSpace) {
        playerJump(jumpTypes.wall)
        const playerVec = new Vector3(
          Math.cos(player.yaw + 90),
          0,
          Math.sin(player.yaw + 90),
        )
        const wallVec = new Vector3(
          player.wallTriangle.normal.x,
          0,
          player.wallTriangle.normal.z,
        )
        const dot = playerVec.dot(wallVec)
        const reflected = new Vector3(
          playerVec.x - 2 * dot * wallVec.x,
          0,
          playerVec.z - 2 * dot * wallVec.z,
        ) //this took way too long to figure out with atan atan2...
        player.yaw = (atan22(wallVec.x, wallVec.z) * 180) / Math.PI
      }
    }

    player.slideVelX = player.forwardVel * Math.sin(player.yaw)
    player.slideVelZ = player.forwardVel * Math.cos(player.yaw)

    player.slideVelX += sidewaysSpeed * Math.sin(player.yaw + 90)
    player.slideVelZ += sidewaysSpeed * Math.cos(player.yaw + 90)

    movePlayer(player.slideVelX, player.slideVelZ)

    if (player.verticalVel > -1.875 / gravityMult)
      player.verticalVel += gravity / gravityMult
    player.position.y += player.verticalVel
  }

  function updateGroundMovement() {
    const currentYaw = player.yaw
    const intendedYaw = player.intendedYaw
    const currentForwardVel = player.forwardVel
    const inputMagnitude = intendedMag // Globale Variable aus inputs()

    //setPitch()
    if (intendedShift) {
      if (player.sneaking == false) player.sneak_walk = false
      player.sneaking = true
    } else {
      player.sneaking = false
    }
    player.long_jump = false
    if (!player.sneaking) {
      //__IS NOT SNEAKING__

      if (player.skiddingTime <= epsilon) {
        if (player.canMove && !player.sneaking) {
          if (
            player.forwardVel > 27 &&
            getShortestAngleDifferenceDegrees(intendedYaw, player.yaw) > 160
          ) {
            player.skiddingAngle = intendedYaw
            player.skiddingTime = 20
            player.forwardVel = -player.forwardVel
          }
        }
        const rotationSpeed = 9
        if (inputMagnitude != 0) {
          if (was_standing_still) {
            player.yaw = intendedYaw
          } else {
            player.yaw = rotateTowardsAngleDegrees(
              currentYaw,
              intendedYaw,
              rotationSpeed,
            )
          }
        }
        let maxTargetSpeed = 32
        let targetSpeed =
          inputMagnitude < maxTargetSpeed ? inputMagnitude : maxTargetSpeed

        const smoothingFactor = 0.1
        player.forwardVel += (targetSpeed - currentForwardVel) * smoothingFactor

        if (player.forwardVel > 48) {
          player.forwardVel = 48
        }
        if (targetSpeed === 0 && Math.abs(player.forwardVel) < 0.5) {
          player.forwardVel = 0
        }
      } else {
        console.log("ran")
        player.skiddingTime--
        setPlayerAnimation(animations.skidding)
        player.yaw = player.skiddingAngle
        const smoothingFactor = 0.1
        player.forwardVel = approach(player.forwardVel, 32, 2.8, 2.8)
      }

      if (intendedSpace) playerJump(jumpTypes.single)
    } else {
      //__IS SNEAKING__
      if (
        !player.sneak_walk &&
        Math.abs(player.forwardVel) < epsilon &&
        Math.abs(player.slideVelX) < epsilon &&
        Math.abs(player.slideVelZ) < epsilon
      )
        player.sneak_walk = true

      player.forwardVel = approach(player.forwardVel, 0, 0.175, 0.175)
      const dragThreshold = 12
      if (player.forwardVel > dragThreshold) {
        player.forwardVel = dragThreshold
      }
      if (player.forwardVel < -dragThreshold / 2) {
        player.forwardVel += 2
      }
      const downhillSpeedConstant = 20.0
      const horizontalSteepness = Math.sqrt(
        1.0 - player.groundTriangle.normal.y * player.groundTriangle.normal.y,
      )

      if (player.sneak_walk) {
        //__CAN WALK WHILE SNEAKING__
        const rotationSpeed = 9
        if (inputMagnitude != 0) {
          if (was_standing_still) {
            player.yaw = intendedYaw
          } else {
            player.yaw = rotateTowardsAngleDegrees(
              currentYaw,
              intendedYaw,
              rotationSpeed,
            )
          }
        }
        let maxTargetSpeed = 4
        let targetSpeed =
          inputMagnitude < maxTargetSpeed ? inputMagnitude : maxTargetSpeed

        const smoothingFactor = 0.1
        player.forwardVel += (targetSpeed - currentForwardVel) * smoothingFactor
        if (intendedSpace) playerJump(jumpTypes.single)
      } else {
        //__CAN NOT WALK WHILE SNEAKING__
        if (horizontalSteepness > 0.3) {
          player.slideVelX =
            player.forwardVel * Math.sin(player.yaw) +
            downhillSpeedConstant *
              horizontalSteepness *
              player.groundTriangle.normal.x
          player.slideVelZ =
            player.forwardVel * Math.cos(player.yaw) +
            downhillSpeedConstant *
              horizontalSteepness *
              player.groundTriangle.normal.z
        } else {
          player.slideVelX = player.forwardVel * Math.sin(player.yaw)
          player.slideVelZ = player.forwardVel * Math.cos(player.yaw)
        }
        if (Math.abs(player.forwardVel) >= 4 && intendedSpace) {
          playerJump(jumpTypes.long)
          if (Math.abs(player.forwardVel) < 20)
            player.forwardVel = Math.sign(player.forwardVel) * 20
        }
      }

      movePlayer(player.slideVelX, player.slideVelZ)
    } //__ END OF IS SNEAKING __

    const speed = player.forwardVel
    const yawDegrees = player.yaw

    const deltaX = speed * Math.sin(yawDegrees)
    const deltaZ = speed * Math.cos(yawDegrees)

    movePlayer(deltaX, deltaZ)
  }

  function setPitch() {
    const normal = player.groundTriangle.normal.normalize()

    const horizontalLength = Math.sqrt(
      normal.x * normal.x + normal.z * normal.z,
    )

    if (horizontalLength < 0.001) {
      player.pitch = normal.y > 0 ? 0 : Math.PI
      player.roll = 0
      console.log(player.pitch - 90, "  ", player.roll, "  0")
    } else {
      //player.pitch = atan22(normal.y, horizontalLength) / Math.PI*180 - 90;
      //player.roll = atan22(-normal.x, normal.y) / Math.PI*180
      //console.log(player.pitch, "  ", player.roll, "  4")
    }
  }
}

function movePlayer(x: number, z: number) {
  const moveX = x / 128
  const moveZ = z / 128
  for (let i = 0; i < 3; i++) {
    player.position.x += moveX
    player.position.z += moveZ
    const trianglesInPlayerCell = getSurfaceTrianglesAt(
      player.position.x,
      player.position.z,
    )
    const wallPush = getWallPush(
      player.position,
      player.height,
      player.radius,
      trianglesInPlayerCell,
      true,
    )
    if (player.state == state.air && player.forwardVel > 30) {
      const pushAmt = Math.abs(wallPush.x) + Math.abs(wallPush.z)
      if (pushAmt >= 0.15 || pushAmt <= -0.15) {
        player.bonked = true
        player.bonkedTimer = 40
        setPlayerAnimation(animations.fall)
        player.forwardVel = -player.forwardVel / 4
      }
    }
    player.canMove = !player.bonked //currently only bonks NOMOVE
    player.position = player.position.add(wallPush)
    const heightListFloor = getFloors(
      player.position.x,
      player.position.z,
      trianglesInPlayerCell,
      true,
    )
    if (heightListFloor.length == 0) {
      playerSetAir()
    } else {
      player.state = state.ground
      player.bonked = false
      player.bonkedTimer = 0
      const floor = Math.max(...heightListFloor)
      player.position.y = floor
    }
    const heightListCeilings = getCeilings(
      player.position.x,
      player.position.z,
      trianglesInPlayerCell,
    )
    if (heightListCeilings.length != 0) {
      const isInCeiling = inCeiling(
        player.position.y,
        player.height,
        heightListCeilings,
      )
      if (isInCeiling) {
        if (player.verticalVel > 0) player.verticalVel = 0
        player.position.x -= moveX
        player.position.z -= moveZ
      }
    }
  }
}

function getShortestAngleDifferenceDegrees(
  angle1: number,
  angle2: number,
): number {
  let difference = angle1 - angle2

  if (difference > 180) {
    difference -= 360
  } else if (difference <= -180) {
    difference += 360
  }

  return Math.abs(difference)
}

function crossProduct2D(
  p1x: number,
  p1y: number,
  p2x: number,
  p2y: number,
): number {
  return p1x * p2y - p2x * p1y
}

function isPointInTriangle2D(point2D: number[], vertices2D: number[]): boolean {
  const v1x = vertices2D[0],
    v1y = vertices2D[1]
  const v2x = vertices2D[2],
    v2y = vertices2D[3]
  const v3x = vertices2D[4],
    v3y = vertices2D[5]
  const px = point2D[0],
    py = point2D[1]

  const cp1 = crossProduct2D(v2x - v1x, v2y - v1y, px - v1x, py - v1y)
  const cp2 = crossProduct2D(v3x - v2x, v3y - v2y, px - v2x, py - v2y)
  const cp3 = crossProduct2D(v1x - v3x, v1y - v3y, px - v3x, py - v3y)

  const has_neg = cp1 < -epsilon || cp2 < -epsilon || cp3 < -epsilon
  const has_pos = cp1 > epsilon || cp2 > epsilon || cp3 > epsilon

  return !(has_neg && has_pos)
}

function getWallPush(
  startpos: Vector3,
  objHeight: number,
  r: number,
  collisionTrianglesCell: collisionTriangle[] = [],
  isPlayer: boolean = false,
): Vector3 {
  let collisionTriangles = collisionTrianglesCell
  if (collisionTriangles.length == 0) {
    collisionTriangles = getSurfaceTrianglesAt(startpos.x, startpos.z)
    if (collisionTriangles.length == 0) return new Vector3(0, 0, 0)
  }

  const wallTriangles = collisionTriangles.filter(
    (triangle) => triangle.collisionType === collisionTypes.wall,
  )

  if (wallTriangles.length === 0) {
    return new Vector3(0, 0, 0)
  }

  let accumulatedWallPush = new Vector3(0, 0, 0)

  for (let i = 0; i < 2; i++) {
    const offset = new Vector3(0, 1.5 * (i + 1), 0)
    const rS = (r / 2) * (i + 1)
    let pos = startpos.add(offset)

    wallTriangles.forEach((wallTriangle) => {
      const normal = wallTriangle.normal
      const originOffset = wallTriangle.originOffset

      const distBottom = pos.dot(normal) + originOffset
      const TopPos = pos.add(new Vector3(0, objHeight, 0))
      const distTop = TopPos.dot(normal) + originOffset

      const minProjectedDistance = Math.min(distBottom, distTop)
      const maxProjectedDistance = Math.max(distBottom, distTop)

      const overlapsPlaneDepth =
        minProjectedDistance <= rS + epsilon &&
        maxProjectedDistance >= -rS - epsilon

      const wallMinY = Math.min(
        wallTriangle.vertices[0].y,
        wallTriangle.vertices[1].y,
        wallTriangle.vertices[2].y,
      )
      const wallMaxY = Math.max(
        wallTriangle.vertices[0].y,
        wallTriangle.vertices[1].y,
        wallTriangle.vertices[2].y,
      )
      const MinY = pos.y
      const MaxY = pos.y + objHeight

      const yOverlap = Math.max(
        0,
        Math.min(MaxY, wallMaxY) - Math.max(MinY, wallMinY),
      )

      if (overlapsPlaneDepth && yOverlap > epsilon) {
        const penetrationDepth = rS - minProjectedDistance

        if (penetrationDepth > epsilon) {
          const pointOnPlaneClosestToStartpos = pos.add(
            new Vector3(
              normal.x * -distBottom,
              normal.y * -distBottom,
              normal.z * -distBottom,
            ),
          )

          const absNormalX = Math.abs(normal.x)
          const absNormalY = Math.abs(normal.y)
          const absNormalZ = Math.abs(normal.z)

          let vertices2D: number[] = []
          let point2D: number[] = []

          if (absNormalZ > absNormalX && absNormalZ > absNormalY) {
            vertices2D = [
              wallTriangle.vertices[0].x,
              wallTriangle.vertices[0].y,
              wallTriangle.vertices[1].x,
              wallTriangle.vertices[1].y,
              wallTriangle.vertices[2].x,
              wallTriangle.vertices[2].y,
            ]
            point2D = [
              pointOnPlaneClosestToStartpos.x,
              pointOnPlaneClosestToStartpos.y,
            ]
          } else if (absNormalY > absNormalX && absNormalY > absNormalZ) {
            vertices2D = [
              wallTriangle.vertices[0].x,
              wallTriangle.vertices[0].z,
              wallTriangle.vertices[1].x,
              wallTriangle.vertices[1].z,
              wallTriangle.vertices[2].x,
              wallTriangle.vertices[2].z,
            ]
            point2D = [
              pointOnPlaneClosestToStartpos.x,
              pointOnPlaneClosestToStartpos.z,
            ]
          } else {
            vertices2D = [
              wallTriangle.vertices[0].y,
              wallTriangle.vertices[0].z,
              wallTriangle.vertices[1].y,
              wallTriangle.vertices[1].z,
              wallTriangle.vertices[2].y,
              wallTriangle.vertices[2].z,
            ]
            point2D = [
              pointOnPlaneClosestToStartpos.y,
              pointOnPlaneClosestToStartpos.z,
            ]
          }

          if (isPointInTriangle2D(point2D, vertices2D)) {
            const push = new Vector3(
              normal.x * penetrationDepth,
              normal.y * penetrationDepth,
              normal.z * penetrationDepth,
            )
            if (isPlayer) player.wallTriangle = wallTriangle
            accumulatedWallPush = accumulatedWallPush.add(push)
          }
        }
      }
    })
  }

  return accumulatedWallPush
}

function approach(
  current: number,
  target: number,
  incStep: number,
  decStep: number,
): number {
  const diff = target - current
  if (diff > 0) {
    // Ziel ist größer
    return current + Math.min(diff, incStep)
  } else if (diff < 0) {
    // Ziel ist kleiner
    return current + Math.max(diff, -decStep)
  } else {
    // Ziel ist erreicht
    return target
  }
}

function playerJump(jumpType: jumpTypes) {
  player.long_jump = false
  switch (jumpType) {
    case jumpTypes.single:
      player.verticalVel = 2.1 / 2 + player.forwardVel / 256
      setPlayerAnimation(animations.single_jumping_fall)
      break
    case jumpTypes.long:
      player.verticalVel = 1
      setPlayerAnimation(animations.long_jump)
      player.long_jump = true
      player.forwardVel *= 2.5
      break
    case jumpTypes.wall:
      player.canMove = true
      player.bonked = false
      player.verticalVel = 2.1 / 2 + player.forwardVel / 256
      setPlayerAnimation(animations.single_jumping_fall)
      player.long_jump = false
      player.bonkedTimer = 0
      player.forwardVel *= -3
      player.slideVelX = 0
      player.slideVelZ = 0
      break
  }

  player.state = state.air
  player.position.y += 1
}

function updatePlayerAnimations() {
  switch (player.currentAnimation) {
    case animations.idle:
      playerAnimIdle()
      break
    case animations.fall:
      playerAnimFreeFall()
      break
    case animations.single_jumping_fall:
      playerAnimSingleJump()
      break
    case animations.running:
      playerAnimRunning(player.forwardVel / 3)
      break
    case animations.crouch:
      playerAnimCrouching()
      break
    case animations.sneaking:
      playerAnimSneaking()
      break
    case animations.long_jump:
      playerAnimLongJump()
      break
    case animations.sneakingIdle:
      playerAnimSneakingIdle()
      break
    case animations.skidding:
      playerAnimSkidding()
      break
    case animations.double_jumping_fall:
      playerAnimSneakingIdle()
      break
    case animations.tripe_jumping_fall:
      playerAnimSneakingIdle()
      break
  }
}

function playerAnimRunning(runSpeed: number) {
  const timeSin = Math.sin(animTime)
  const timeSin2 = Math.sin(animTime2)
  playerObj.rightArm.rotation = new rotation(
    timeSin2 * 32 - 10,
    40 + timeSin2,
    0,
  )
  playerObj.rightArm.position = new Vector3(-timeSin2 * 1.3, -0.5, -3)
  playerObj.leftArm.rotation = new rotation(timeSin * 32 + 10, -40 - timeSin, 0)
  playerObj.leftArm.position = new Vector3(timeSin * 1.3, -0.5, 3)

  playerObj.leftLeg.rotation = new rotation(0, 0, timeSin2 * 60)
  playerObj.leftLeg.position = new Vector3(
    timeSin2 * 1.4,
    Math.abs(timeSin2),
    0,
  )
  playerObj.rightLeg.rotation = new rotation(0, 0, -timeSin * 60)
  playerObj.rightLeg.position = new Vector3(
    -timeSin * 1.4,
    Math.abs(timeSin),
    0,
  )

  playerObj.Body.rotation = new rotation(timeSin * 3, 0, 0)
  playerObj.Body.position = new Vector3(-0.2, timeSin2 / 8, 0)
  playerObj.Head.rotation = new rotation(-timeSin2 * 7, 0, 7 - timeSin)
  playerObj.Head.position = new Vector3(0.2, timeSin2 / 7 - 0.1, 0)
  const diff = Math.random(-0.3, 0.3)
  animTime = (animTime + runSpeed + diff) % 360
  animTime2 = (animTime2 + runSpeed - diff) % 360
}

function playerAnimIdle() {
  const timeSin = Math.sin(animTime)
  const timeSinAbs = Math.abs(timeSin)
  const timeSinAbs4 = Math.abs(timeSin) / 4
  const timeSin2 = Math.sin(animTime2)
  player.animWannaState = (player.animWannaState + 1) % 270
  playerObj.rightArm.rotation = new rotation(0, timeSin, -timeSinAbs)
  playerObj.rightArm.position = new Vector3(0, -timeSinAbs4, 0)
  playerObj.leftArm.rotation = new rotation(0, timeSin, -timeSinAbs)
  playerObj.leftArm.position = new Vector3(0, -timeSinAbs4, 0)

  playerObj.leftLeg.rotation = new rotation(0, 0, -timeSin * 3)
  playerObj.leftLeg.position = new Vector3(0, 0, 0)
  playerObj.rightLeg.rotation = new rotation(0, 0, timeSin * 3)
  playerObj.rightLeg.position = new Vector3(0, 0, 0)

  playerObj.Body.rotation = new rotation(0, 0, 0)
  playerObj.Body.position = new Vector3(0, -timeSinAbs4, 0)
  if (player.animWannaState > 90) {
    playerObj.Head.rotation = new rotation(timeSin2 * 36, 0, timeSinAbs)
  } else {
    playerObj.Head.rotation = new rotation(timeSin2 / 2, 0, timeSinAbs)
  }
  playerObj.Head.position = new Vector3(0, -timeSinAbs4, 0)
  const diff = Math.random(-0.3, 0.3)
  animTime = (animTime + 3 + diff) % 360
  animTime2 = (animTime2 + 2 - diff) % 360
}

function playerAnimFreeFall() {
  playerObj.rightArm.rotation = new rotation(10, 0, 200)
  playerObj.rightArm.position = new Vector3(-1.5, 8.5, -0.5)
  playerObj.leftArm.rotation = new rotation(-10, 0, 200)
  playerObj.leftArm.position = new Vector3(-1.5, 8.5, 0.5)

  playerObj.leftLeg.rotation = new rotation(0, 5, -15)
  playerObj.leftLeg.position = new Vector3(0, 0.2, 0)
  playerObj.rightLeg.rotation = new rotation(0, 0, -13)
  playerObj.rightLeg.position = new Vector3(-0.3, 0.8, 0)

  playerObj.Body.rotation = new rotation(0, 0, 8)
  playerObj.Body.position = new Vector3(0.8, 0, 0)

  playerObj.Head.rotation = new rotation(0, 0, 16)
  playerObj.Head.position = new Vector3(1.6, 0, 0)

  animTime = 0
  animTime2 = 0
  player.animWannaState = 0
}

function playerAnimLongJump() {
  playerObj.rightArm.rotation = new rotation(9, 0, -88)
  playerObj.rightArm.position = new Vector3(-4.6, 3.5, -0.2)
  playerObj.leftArm.rotation = new rotation(-11, 0, -91)
  playerObj.leftArm.position = new Vector3(-4.5, 3.55, 0.25)

  playerObj.leftLeg.rotation = new rotation(0, -4, -75)
  playerObj.leftLeg.position = new Vector3(-2.2, 1.4, 0.3)
  playerObj.rightLeg.rotation = new rotation(0, 7, -80)
  playerObj.rightLeg.position = new Vector3(-2.2, 1.4, -0.3)

  playerObj.Body.rotation = new rotation(0, 0, 5)
  playerObj.Body.position = new Vector3(0.8, -0.1, 0)

  playerObj.Head.rotation = new rotation(0, 0, 7)
  playerObj.Head.position = new Vector3(0.8, -0.1, 0)

  animTime = 0
  animTime2 = 0
  player.animWannaState = 0
}

function playerAnimSkidding() {
  playerObj.rightArm.rotation = new rotation(-40, 0, 0)
  playerObj.rightArm.position = new Vector3(0.2, 0, 0)

  playerObj.leftArm.rotation = new rotation(0, 40, -90)
  playerObj.leftArm.position = new Vector3(-2.4, 4, -2)

  playerObj.leftLeg.rotation = new rotation(0, 0, -10)
  playerObj.leftLeg.position = new Vector3(-0.1, 0.1, 0)

  playerObj.rightLeg.rotation = new rotation(0, 0, -30)
  playerObj.rightLeg.position = new Vector3(-0.5, 0.2, 0)

  playerObj.Body.rotation = new rotation(0, 0, -3)
  playerObj.Body.position = new Vector3(0.2, 0, 0)

  playerObj.Head.rotation = new rotation(0, 0, 3)
  playerObj.Head.position = new Vector3(0.7, 0, 0)

  animTime = 0
  animTime2 = 0
  player.animWannaState = 0
}

function playerAnimCrouching() {
  const timeSin = Math.sin(animTime)
  const timeSinAbs = Math.abs(timeSin)
  const timeSinAbs4 = Math.abs(timeSin) / 8
  const timeSin2 = Math.sin(animTime2)
  playerObj.rightArm.rotation = new rotation(
    -20,
    timeSin * 7 - 25,
    -timeSinAbs - 90,
  )
  playerObj.rightArm.position = new Vector3(-4, -timeSinAbs4 + 2, 1)
  playerObj.leftArm.rotation = new rotation(
    20,
    timeSin * 7 + 25,
    -timeSinAbs - 90,
  )
  playerObj.leftArm.position = new Vector3(-4, -timeSinAbs4 + 2, -1)

  playerObj.leftLeg.rotation = new rotation(
    timeSin * 3,
    -timeSin,
    -timeSin * 3 + 90,
  )
  playerObj.leftLeg.position = new Vector3(2.5, timeSin / 16, 0)
  playerObj.rightLeg.rotation = new rotation(
    -timeSin2,
    timeSin2,
    timeSin * 3 + 90,
  )
  playerObj.rightLeg.position = new Vector3(2.5, 0, -timeSin2 / 16)

  playerObj.Body.rotation = new rotation(0, timeSin * 2, 60 + timeSin2)
  playerObj.Body.position = new Vector3(3, -timeSinAbs4 - 0.5, 0)
  playerObj.Head.rotation = new rotation(0, timeSin * 2, 30)
  playerObj.Head.position = new Vector3(1, -timeSinAbs4 - 2.5, 0)
  const diff = Math.random(-0.3, 0.3)
  animTime = (animTime + 6 + diff) % 360
  animTime2 = (animTime2 + 5 - diff) % 360
}

function playerAnimSneakingIdle() {
  const timeSin = Math.sin(animTime)
  const timeSinAbs = Math.abs(timeSin)
  const timeSinAbs4 = Math.abs(timeSin) / 4
  const timeSin2 = Math.sin(animTime2)
  player.animWannaState = (player.animWannaState + 1) % 270
  playerObj.rightArm.rotation = new rotation(0, timeSin - 25, -timeSinAbs + 240)
  playerObj.rightArm.position = new Vector3(-4, -timeSinAbs4 + 6, 1.2)
  playerObj.leftArm.rotation = new rotation(0, timeSin + 25, -timeSinAbs + 240)
  playerObj.leftArm.position = new Vector3(-4, -timeSinAbs4 + 6, -1.2)

  playerObj.leftLeg.rotation = new rotation(0, 0, -timeSin * 3)
  playerObj.leftLeg.position = new Vector3(0, 0, 0)
  playerObj.rightLeg.rotation = new rotation(0, 0, timeSin * 3)
  playerObj.rightLeg.position = new Vector3(0, 0, 0)

  playerObj.Body.rotation = new rotation(0, 0, 26)
  playerObj.Body.position = new Vector3(1.3, -timeSinAbs4 - 0.5, 0)
  if (player.animWannaState > 90) {
    playerObj.Head.rotation = new rotation(timeSin2 * 36, 0, timeSinAbs + 30)
  } else {
    playerObj.Head.rotation = new rotation(timeSin2 / 2, 0, timeSinAbs + 30)
  }
  playerObj.Head.position = new Vector3(1.5, -timeSinAbs4 - 0.5, 0)
  const diff = Math.random(-0.3, 0.3)
  animTime = (animTime + 3 + diff) % 360
  animTime2 = (animTime2 + 2 - diff) % 360
}

function playerAnimSneaking() {
  playerObj.rightArm.rotation = new rotation(0, -25, 240)
  playerObj.rightArm.position = new Vector3(-4, 6, 1.2)
  playerObj.leftArm.rotation = new rotation(0, 25, 240)
  playerObj.leftArm.position = new Vector3(-4, 6, -1.2)

  playerObj.leftLeg.rotation = new rotation(0, 0, 0)
  playerObj.leftLeg.position = new Vector3(0, 0, 0)
  playerObj.rightLeg.rotation = new rotation(0, 0, 0)
  playerObj.rightLeg.position = new Vector3(0, 0, 0)

  playerObj.Body.rotation = new rotation(0, 0, 26)
  playerObj.Body.position = new Vector3(1.3, -0.5, 0)
  playerObj.Head.rotation = new rotation(0, 0, 32)
  playerObj.Head.position = new Vector3(1.7, -0.5, 0)
}

function playerAnimSingleJump() {
  playerObj.rightArm.rotation = new rotation(-30, 0, -10)
  playerObj.rightArm.position = new Vector3(-1, -0.3, -0.6)
  playerObj.leftArm.rotation = new rotation(-10, 0, 200)
  playerObj.leftArm.position = new Vector3(-1.5, 8.5, 0.5)

  playerObj.leftLeg.rotation = new rotation(0, 5, -48)
  playerObj.leftLeg.position = new Vector3(-0.9, 0.4, 0)
  playerObj.rightLeg.rotation = new rotation(0, 0, 43)
  playerObj.rightLeg.position = new Vector3(0.8, 0.4, 0)

  playerObj.Body.rotation = new rotation(0, 0, 0)
  playerObj.Body.position = new Vector3(0, 0, 0)

  playerObj.Head.rotation = new rotation(-5, 0, 3)
  playerObj.Head.position = new Vector3(0.3, 0.1, 0)

  animTime = 0
  animTime2 = 0
  player.animWannaState = 0
}

function importPlayer() {
  fetch(wispy)
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      return response.json()
    })
    .then((data) => {
      const vertices = data.vertices
      const faces = data.faces
      let sumX = 0,
        sumY = 0,
        sumZ = 0
      playerCount = vertices.length
      for (const vert of vertices) {
        sumX += vert[0]
        sumY += vert[1]
        sumZ += vert[2]
      }
      if (playerCount > 0) {
        playerCenter = new Vector3(
          sumX / playerCount,
          sumY / playerCount,
          sumZ / playerCount,
        )
      }
      for (const face of faces) {
        const faceIndic = face[0]
        const faceColor = face[1]
        let appendTo = playerObj.Body.model
        if (face[2] != null) {
          switch (face[2]) {
            case "Body":
              break
            case "LeftArm":
              appendTo = playerObj.leftArm.model
              break
            case "RightArm":
              appendTo = playerObj.rightArm.model
              break
            case "Head":
              appendTo = playerObj.Head.model
              break
            case "LeftLeg":
              appendTo = playerObj.leftLeg.model
              break
            case "RightLeg":
              appendTo = playerObj.rightLeg.model
              break
          }
        }
        if (faceIndic.length === 3) {
          const v1_3D = new Vector3(...vertices[faceIndic[0]])
          const v2_3D = new Vector3(...vertices[faceIndic[1]])
          const v3_3D = new Vector3(...vertices[faceIndic[2]])

          const normal = calculateNormal(v1_3D, v2_3D, v3_3D)

          if (enable_outlines) {
            const triangle = new Triangle(
              v1_3D,
              v2_3D,
              v3_3D,
              faceColor,
              normal,
              false,
              true,
            )
            appendTo.push(triangle)
          } else {
            const triangle = new Triangle(
              v1_3D,
              v2_3D,
              v3_3D,
              faceColor,
              normal,
              false,
              true,
            )
            appendTo.push(triangle)
          }
        }
      }
    })
    .catch((error) => {
      console.error("fehler beim laden der modeldata:", error)
    })
}

function loadCollisionMap() {
  fetch(collisionMapModel)
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      return response.json()
    })
    .then((data) => {
      const vertices = data.vertices
      const faces = data.faces
      for (const face of faces) {
        const faceIndic = face
        if (faceIndic.length === 3) {
          const v1_3D = new Vector3(...vertices[faceIndic[0]])
          const v2_3D = new Vector3(...vertices[faceIndic[1]])
          const v3_3D = new Vector3(...vertices[faceIndic[2]])

          const normal = calculateNormal(v1_3D, v2_3D, v3_3D)
          const collisionTriangleThis = new collisionTriangle(
            v1_3D,
            v2_3D,
            v3_3D,
            normal,
          )
          const renderTri = new Triangle(
            v1_3D,
            v2_3D,
            v3_3D,
            getRandomColor(),
            normal,
            true,
          )
          collisionMap.push(collisionTriangleThis)
          scene.push(renderTri)
        }
      }
      console.log("setup")
      setupStaticCollisionGeometry()
    })
    .catch((error) => {
      console.error("fehler beim laden der modeldata:", error)
    })
}

//LATESTBACKUP 14:18 11.05
