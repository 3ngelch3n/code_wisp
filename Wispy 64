const camera = {
  x: 0,

  y: 7,

  z: -12,

  yaw: 0,

  pitch: 0,
}

const light = {
  yaw: 45,
  pitch: -45,
}

let horizontalSpeed = 0

let playerRotation = 0

const moveSpeed = 0.1

const rotationSpeed = -2

const projectionDistance = 1

let lightDir: Vector3

if (document.querySelectorAll("canvas").length > 1) {
  document.querySelectorAll("canvas")[0].parentElement.children[1].remove()
}

let gamecan = document.querySelector("canvas")

let canvas = document.createElement("canvas")

canvas.height = gamecan.height

canvas.width = gamecan.width

canvas.style.height = gamecan.style.height

canvas.style.width = gamecan.style.width

canvas.style.position = "relative"

canvas.style.top = `${0 - Number(gamecan.style.height.match(/\d*/))}px`

canvas.style.left = `0px`

gamecan.parentElement.append(canvas)

let ctx = canvas.getContext("2d")

sprite.visible = false

let lastFrameTime = performance.now()

let fps = 0

let smoothFPS = 0

const screenDimensions = {
  width: 480,

  height: 360,

  halfwidth: 240,

  halfheight: 180,
}

let zBuffer = new Float32Array(screenDimensions.width * screenDimensions.height)

enum levels {
  castle_grounds,

  inside_castle,
}

let level = levels.castle_grounds

let skybox = new Image()

updateSkyBox()

function project(vertex: Vector3): { x: number; y: number; z: number } | null {
  let worldX = vertex.x - camera.x
  let worldY = vertex.y - camera.y
  let worldZ = vertex.z - camera.z

  const yawInRadians = camera.yaw
  const cosYaw = Math.cos(yawInRadians)
  const sinYaw = Math.sin(yawInRadians)
  const rotatedX = cosYaw * worldX + sinYaw * worldZ
  const rotatedZ = -sinYaw * worldX + cosYaw * worldZ
  worldX = rotatedX
  worldZ = rotatedZ // Rotation um die X-Achse (Pitch)

  const pitchInRadians = camera.pitch
  const cosPitch = Math.cos(pitchInRadians)
  const sinPitch = Math.sin(pitchInRadians)
  const rotatedY = cosPitch * worldY - sinPitch * worldZ
  const rotatedZ2 = sinPitch * worldY + cosPitch * worldZ
  worldY = rotatedY
  worldZ = rotatedZ2 // Vermeide Division durch Null und Clipping von Punkten sehr nah an der Kamera

  if (worldZ <= 0.95) {
    return null
  } // Perspektivische Division

  const screenX = (projectionDistance * worldX) / worldZ
  const screenY = (projectionDistance * worldY) / worldZ

  // Berechne das Seitenverhältnis
  const aspectRatio = screenDimensions.width / screenDimensions.height // Abbildung auf Canvas-Koordinaten - Berücksichtige das Seitenverhältnis bei screenY

  const canvasX =
    screenDimensions.halfwidth + screenX * screenDimensions.halfwidth
  const canvasY =
    screenDimensions.halfheight -
    screenY * screenDimensions.halfheight * aspectRatio // Skaliere screenY zusätzlich mit dem Seitenverhältnis

  return {
    x: canvasX,
    y: canvasY,
    z: worldZ, // Behalte die transformierte Z-Koordinate für den Z-Buffer
  }
}

function drawTriangleProjected(triangle: Triangle) {
  const projectedVertices = triangle.vertices.map(project)
  drawLine(
    Math.round(projectedVertices[0].x),
    Math.round(projectedVertices[0].y),
    Math.round(projectedVertices[1].x),
    Math.round(projectedVertices[1].y),
    projectedVertices[0].z,
    triangle.color,
  )
  drawLine(
    Math.round(projectedVertices[1].x),
    Math.round(projectedVertices[1].y),
    Math.round(projectedVertices[2].x),
    Math.round(projectedVertices[2].y),
    projectedVertices[1].z,
    triangle.color,
  )
  drawLine(
    Math.round(projectedVertices[2].x),
    Math.round(projectedVertices[2].y),
    Math.round(projectedVertices[0].x),
    Math.round(projectedVertices[0].y),
    projectedVertices[2].z,
    triangle.color,
  )
}

function drawLine(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  z: number,
  color: string,
) {
  const dx = Math.abs(x2 - x1)
  const dy = Math.abs(y2 - y1)
  const sx = x1 < x2 ? 1 : -1
  const sy = y1 < y2 ? 1 : -1
  let err = dx - dy
  while (true) {
    setPixel(x1, y1, z, color)
    if (x1 === x2 && y1 === y2) break
    const e2 = 2 * err
    if (e2 > -dy) {
      err -= dy
      x1 += sx
    }

    if (e2 < dx) {
      err += dx
      y1 += sy
    }
  }
}

class Vector3 {
  x: number
  y: number
  z: number

  constructor(x: number = 0, y: number = 0, z: number = 0) {
    this.x = x
    this.y = y
    this.z = z
  }

  subtract(other: Vector3): Vector3 {
    return new Vector3(this.x - other.x, this.y - other.y, this.z - other.z)
  }

  cross(other: Vector3): Vector3 {
    return new Vector3(
      this.y * other.z - this.z * other.y,
      this.z * other.x - this.x * other.z,
      this.x * other.y - this.y * other.x,
    )
  }

  magnitude(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }

  normalize(): Vector3 {
    const mag = this.magnitude()
    if (mag > 1e-6) {
      return new Vector3(this.x / mag, this.y / mag, this.z / mag)
    } else {
      return new Vector3(0, 0, 0)
    }
  }
  dot(other: Vector3): number {
    return this.x * other.x + this.y * other.y + this.z * other.z
  }
}

function calculateNormal(v1: Vector3, v2: Vector3, v3: Vector3): Vector3 {
  const edge1 = v2.subtract(v1)
  const edge2 = v3.subtract(v1)
  const normal = edge1.cross(edge2)
  return normal.normalize()
}

function fillTriangleProjected(triangle: Triangle) {
  const projectedVertices = triangle.vertices.map(project)
  projectedVertices.sort((a, b) => a.y - b.y)
  const v1 = projectedVertices[0]
  const v2 = projectedVertices[1]
  const v3 = projectedVertices[2]
  function fillScanline(
    y: number,
    x1: number,
    x2: number,
    z1: number,
    z2: number,
    color: string,
  ) {
    const steps = x2 - x1
    for (let x = x1; x <= x2; x++) {
      const t = (x - x1) / steps
      const z = z1 * (1 - t) + z2 * t
      setPixel(Math.round(x), Math.round(y), z, color)
    }
  }
  function interpolate(
    y: number,
    vA: { x: number; y: number; z: number },
    vB: { x: number; y: number; z: number },
  ): { x: number; z: number } | null {
    const epsilon = 1e-6
    if (Math.abs(y - vB.y) < epsilon) {
      return { x: vB.x, z: vB.z }
    }

    if (Math.abs(y - vA.y) < epsilon) {
      return { x: vA.x, z: vA.z }
    }
    if (Math.abs(vA.y - vB.y) < epsilon) {
      return null
    }
    const t = (y - vA.y) / (vB.y - vA.y)
    if (t < -epsilon || t > 1 + epsilon) return null
    const x = vA.x + t * (vB.x - vA.x)
    const z = vA.z + t * (vB.z - vA.z)
    return { x, z }
  }
  for (let y = Math.round(v1.y); y <= Math.round(v3.y); y++) {
    const p1 = interpolate(y, v1, v3)
    let p2: { x: number; z: number } | null = null
    if (y < v2.y) {
      p2 = interpolate(y, v1, v2)
    } else {
      p2 = interpolate(y, v2, v3)
    }
    if (p1 !== null && p2 !== null) {
      let fillColor = triangle.color
      if (!triangle.bakedLight) {
        let colors = hexToRgb(triangle.color)
        const lightLevels = calculateLightLevel(triangle.normal)
        if (colors != null) {
          colors.r += lightLevels
          colors.g += lightLevels
          colors.b += lightLevels
          fillColor = rgbToHex(colors.r, colors.g, colors.b)
        }
      }
      if (p1.x < p2.x) {
        fillScanline(y, p1.x, p2.x, p1.z, p2.z, fillColor)
      } else {
        fillScanline(y, p2.x, p1.x, p2.z, p1.z, fillColor)
      }
    }
  }
}

class Triangle {
  vertices: [Vector3, Vector3, Vector3]
  color: string
  normal: Vector3
  bakedLight: boolean
  constructor(
    v1: Vector3,
    v2: Vector3,
    v3: Vector3,
    color: string = "white",
    normal: Vector3,
    bakedLight: boolean,
  ) {
    this.vertices = [v1, v2, v3]
    this.color = color
    this.normal = normal
    this.bakedLight = bakedLight
  }
}

function calculateLightDirection(yaw: number, pitch: number): Vector3 {
  let dir = new Vector3(0, 0, 1)

  const cosPitch = Math.cos(pitch)
  const sinPitch = Math.sin(pitch)
  const pitchedY = dir.y * cosPitch - dir.z * sinPitch
  const pitchedZ = dir.y * sinPitch + dir.z * cosPitch
  dir.y = pitchedY
  dir.z = pitchedZ

  const cosYaw = Math.cos(yaw)
  const sinYaw = Math.sin(yaw)
  const yawedX = dir.x * cosYaw + dir.z * sinYaw
  const yawedZ = dir.z * cosYaw - dir.x * sinYaw
  dir.x = yawedX
  dir.z = yawedZ

  return dir.normalize() // Stelle sicher, dass der Vektor normalisiert ist
}

function calculateLightLevel(normal: Vector3): number {
  const lightDirection = calculateLightDirection(light.yaw, light.pitch)

  const dot = normal.dot(lightDirection)

  const levelFloat = dot + 1.0

  return levelFloat
}

function getRandomColor() {
  const letters = "0123456789ABCDEF"
  let color = "#"
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random(0, 1) * 16)]
  }
  return color
}

const scene: Triangle[] = []

//__ Fetch Model Data __
let mario_model =
  "https://api.jsonsilo.com/public/7cd9822c-f656-466c-aab5-dfc9e4cfb5eb"
let cube_test =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/cube_with_texture.json"
let this_will_crash =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/bob"
let textured =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/cube_textured"
let mario_test =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/mario_wisp_test"
fetch(mario_test)
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    return response.json()
  })
  .then((data) => {
    const vertices = data.vertices
    const faces = data.faces
    for (const face of faces) {
      const faceIndic = face[0]
      const faceColor = face[1]
      if (faceIndic.length === 3) {
        const v1_3D = new Vector3(...vertices[faceIndic[0]])
        const v2_3D = new Vector3(...vertices[faceIndic[1]])
        const v3_3D = new Vector3(...vertices[faceIndic[2]])

        const normal = calculateNormal(v1_3D, v2_3D, v3_3D)

        /*const r = (normal.x + 1) / 2
        const g = (normal.y + 1) / 2
        const b = (normal.z + 1) / 2
        const faceColor = rgbToHex(r, g, b)*/

        const triangle = new Triangle(
          v1_3D,
          v2_3D,
          v3_3D,
          faceColor,
          normal,
          false,
        )
        scene.push(triangle)
      }
    }
  })
  .catch((error) => {
    console.error("fehler beim laden der modeldata:", error)
  })

function rgbToUint32(r: number, g: number, b: number, a: number = 1.0): number {
  const ir = Math.floor(Math.max(0.0, Math.min(1.0, r)) * 255 + 0.5)
  const ig = Math.floor(Math.max(0.0, Math.min(1.0, g)) * 255 + 0.5)
  const ib = Math.floor(Math.max(0.0, Math.min(1.0, b)) * 255 + 0.5)
  const ia = Math.floor(Math.max(0.0, Math.min(1.0, a)) * 255 + 0.5)
  return (ia << 24) | (ir << 16) | (ig << 8) | ib
}

//__ RGB zu Hex Konverter __
function rgbToHex(r: number, g: number, b: number): string {
  const toHex = (c: number): string => {
    const hex = Math.floor(c * 255).toString(16)
    return hex.length === 1 ? "0" + hex : hex
  }
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`
}

function hexToRgb(
  hexString: string,
): { r: number; g: number; b: number } | null {
  const cleanHexString = hexString.startsWith("#")
    ? hexString.slice(1)
    : hexString

  if (cleanHexString.length !== 6) {
    console.error(
      `Ungültige Hex-String Länge: "${hexString}". Erwarte 6 Zeichen (oder 7 mit #).`,
    )
    return null // Ungültige Länge
  }

  const rHex = cleanHexString.substring(0, 2)
  const gHex = cleanHexString.substring(2, 4)
  const bHex = cleanHexString.substring(4, 6)

  const rInt = parseInt(rHex, 16)
  const gInt = parseInt(gHex, 16)
  const bInt = parseInt(bHex, 16)

  if (isNaN(rInt) || isNaN(gInt) || isNaN(bInt)) {
    console.error(`Ungültige Hex-Zeichen im String: "${hexString}".`)
    return null
  }

  const rFloat = rInt / 255.0
  const gFloat = gInt / 255.0
  const bFloat = bInt / 255.0

  return { r: rFloat, g: gFloat, b: bFloat }
}

forever(function () {
  gameLoop()
})

function drawFrame() {
  ctx.clearRect(0, 0, gamecan.width, gamecan.height)
  for (let i = 0; i < zBuffer.length; i++) {
    zBuffer[i] = Infinity
  }

  //drawSkyBox();
  drawFPS()

  scene.forEach((triangle) => {
    fillTriangleProjected(triangle)
  })
}

function gameLoop() {
  updateCamera()
  updateLight()
  drawFrame()
  //requestAnimationFrame(gameLoop);
}

function updateLight() {
  lightDir = 
}

function drawSkyBox() {
  const scaleFactor = screenDimensions.height / skybox.height
  ctx.drawImage(
    skybox,
    0,
    0,
    skybox.width * scaleFactor,
    skybox.height * scaleFactor,
  )
}

function setPixel(x: any, y: any, z: any, color: any) {
  if (
    x < 0 ||
    y < 0 ||
    x >= screenDimensions.width ||
    y >= screenDimensions.height
  )
    return
  const index = y * screenDimensions.width + x
  if (z < zBuffer[index]) {
    zBuffer[index] = z
    ctx.fillStyle = color
    ctx.fillRect(x, y, 1, 1)
  }
}

function drawFPS() {
  const now = performance.now()
  const delta = now - lastFrameTime
  lastFrameTime = now
  fps = 1000 / delta
  smoothFPS = smoothFPS * 0.9 + fps * 0.1
  ctx.fillStyle = "black"
  ctx.fillRect(0, 0, 150, 40)
  ctx.fillStyle = "lime"
  ctx.font = "bold 14px monospace"
  ctx.fillText("FPS: " + Math.round(smoothFPS), 5, 15)
  ctx.fillText(`X: ${camera.x.toFixed(2)}`, 5, 30)
  ctx.fillText(`Y: ${camera.y.toFixed(2)}`, 70, 30)
  ctx.fillText(`Z: ${camera.z.toFixed(2)}`, 135, 30)
}

function updateSkyBox() {
  switch (level) {
    case levels.castle_grounds:
      //Credits: https://www.textures-resource.com/nintendo_64/mario64/texture/1315/
      skybox.src = "https://i.postimg.cc/s2J6Lz4J/castle-grounds.png"
      break
  }
}

function updateCamera() {
  horizontalSpeed = 0

  if (Keyboard.keyHeld(Key.Space)) {
    camera.y += moveSpeed
  }

  if (Keyboard.keyHeld(Key.Shift)) {
    camera.y -= moveSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowLeft)) {
    camera.yaw -= rotationSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowRight)) {
    camera.yaw += rotationSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowUp)) {
    camera.pitch -= rotationSpeed
  }

  if (Keyboard.keyHeld(Key.ArrowDown)) {
    camera.pitch += rotationSpeed
  }

  if (Keyboard.keyHeld(Key.W)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw
  }

  if (Keyboard.keyHeld(Key.A)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw + 90
  }

  if (Keyboard.keyHeld(Key.S)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw - 180
  }

  if (Keyboard.keyHeld(Key.D)) {
    horizontalSpeed += moveSpeed

    playerRotation = camera.yaw - 90
  }

  if (horizontalSpeed > 0.2) horizontalSpeed = 0.2

  const dirX = -Math.sin(playerRotation)

  const dirZ = Math.cos(playerRotation)

  camera.x += dirX * horizontalSpeed

  camera.z += dirZ * horizontalSpeed

  camera.pitch = Math.max(-89, Math.min(89, camera.pitch))
}
