let resolutionScale = 1
//This can be any number bigger than 1 - 1 is the highest resolution

let camera = {
  x: 0,

  y: 7,

  z: -12,

  yaw: 0,

  pitch: 0,

  yawVel: 0,

  pitchVel: 0,

  turningYaw: false,

  targetYaw: 0,

  stepAngle: 33.333,

  turningSpeedYaw: 200,
}

enum collisionTypes {
  floor,
  wall,
  ceiling,
}

const light = {
  yaw: 45,
  pitch: -45,
}

let horizontalSpeed = 0

let playerRotation = 0

let intendedY = 0
let intendedX = 0
let intendedMag = 0

const moveSpeed = 0.1

const enable_outlines = true

const rotationSpeed = -2

const projectionDistance = 1

let lightDir: Vector3

let playerIsAnimRunning: boolean = false

enum animations {
  start_jumping,
  jumping_fall,
  running,
  idle,
}

enum state {
  ground,
  air,
  water,
}

let currentAnimation = animations.idle

resolutionScale = Math.max(resolutionScale, 1)

if (document.querySelectorAll("canvas").length > 1) {
  document.querySelectorAll("canvas")[0].parentElement.children[1].remove()
}

let gamecan = document.querySelector("canvas")

let canvas = document.createElement("canvas")

canvas.height = gamecan.height

canvas.width = gamecan.width

canvas.style.height = gamecan.style.height

canvas.style.width = gamecan.style.width

canvas.style.position = "relative"

canvas.style.top = `${0 - Number(gamecan.style.height.match(/\d*/))}px`

canvas.style.left = `0px`

gamecan.parentElement.append(canvas)

let ctx = canvas.getContext("2d")

sprite.visible = false

let lastFrameTime = performance.now()

let fps = 0

let smoothFPS = 0

const screenDimensions = {
  width: 480 / resolutionScale,

  height: 360 / resolutionScale,

  halfwidth: 240 / resolutionScale,

  halfheight: 180 / resolutionScale,
}

let zBuffer = new Float32Array(screenDimensions.width * screenDimensions.height)
let imageData = ctx.createImageData(
  screenDimensions.width,
  screenDimensions.height,
)
let pixelBuffer = imageData.data

enum levels {
  castle_grounds,

  inside_castle,
}

let level = levels.castle_grounds

let skybox = new Image()

updateSkyBox()

function project(vertex: Vector3): { x: number; y: number; z: number } | null {
  let worldX = vertex.x - camera.x
  let worldY = vertex.y - camera.y
  let worldZ = vertex.z - camera.z

  const yawInRadians = camera.yaw
  const cosYaw = Math.cos(yawInRadians)
  const sinYaw = Math.sin(yawInRadians)
  const rotatedX = cosYaw * worldX + sinYaw * worldZ
  const rotatedZ = -sinYaw * worldX + cosYaw * worldZ
  worldX = rotatedX
  worldZ = rotatedZ // Rotation um die X-Achse (Pitch)

  const pitchInRadians = camera.pitch
  const cosPitch = Math.cos(pitchInRadians)
  const sinPitch = Math.sin(pitchInRadians)
  const rotatedY = cosPitch * worldY - sinPitch * worldZ
  const rotatedZ2 = sinPitch * worldY + cosPitch * worldZ
  worldY = rotatedY
  worldZ = rotatedZ2 // Vermeide Division durch Null und Clipping von Punkten sehr nah an der Kamera

  if (worldZ <= 0.1) {
    return null
  }

  const screenX = (projectionDistance * worldX) / worldZ
  const screenY = (projectionDistance * worldY) / worldZ

  // Berechne das Seitenverhältnis
  const aspectRatio = screenDimensions.width / screenDimensions.height // Abbildung auf Canvas-Koordinaten - Berücksichtige das Seitenverhältnis bei screenY

  const canvasX =
    screenDimensions.halfwidth + screenX * screenDimensions.halfwidth
  const canvasY =
    screenDimensions.halfheight -
    screenY * screenDimensions.halfheight * aspectRatio // Skaliere screenY zusätzlich mit dem Seitenverhältnis

  return {
    x: canvasX,
    y: canvasY,
    z: worldZ, // Behalte die transformierte Z-Koordinate für den Z-Buffer
  }
}

class rotation {
  pitch: number
  yaw: number
  roll: number
  constructor(yaw: number, pitch: number, roll: number) {
    this.pitch = pitch
    this.yaw = yaw
    this.roll = roll
  }
}

class Vector3 {
  x: number
  y: number
  z: number

  constructor(x: number = 0, y: number = 0, z: number = 0) {
    this.x = x
    this.y = y
    this.z = z
  }

  add(other: Vector3): Vector3 {
    return new Vector3(this.x + other.x, this.y + other.y, this.z + other.z)
  }

  subtract(other: Vector3): Vector3 {
    return new Vector3(this.x - other.x, this.y - other.y, this.z - other.z)
  }

  cross(other: Vector3): Vector3 {
    return new Vector3(
      this.y * other.z - this.z * other.y,
      this.z * other.x - this.x * other.z,
      this.x * other.y - this.y * other.x,
    )
  }

  magnitude(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }

  normalize(): Vector3 {
    const mag = this.magnitude()
    if (mag > 1e-6) {
      return new Vector3(this.x / mag, this.y / mag, this.z / mag)
    } else {
      return new Vector3(0, 0, 0)
    }
  }
  dot(other: Vector3): number {
    return this.x * other.x + this.y * other.y + this.z * other.z
  }
}

let player = {
  position: new Vector3(0, 0, 0),
  yaw: 0,
  pitch: 0,
  forwardVel: 0,
  intendedYaw: 0,
  animWannaState: 0,
  state: state.ground,
}

class AnimatableObject {
  position: Vector3
  rotation: rotation
  model: Triangle[]

  constructor(position: Vector3, rotation: rotation, model: Triangle[]) {
    this.position = position
    this.rotation = rotation
    this.model = model
  }
}

function calculateNormal(v1: Vector3, v2: Vector3, v3: Vector3): Vector3 {
  const edge1 = v2.subtract(v1)
  const edge2 = v3.subtract(v1)
  const normal = edge1.cross(edge2)
  return normal.normalize()
}

function scaleVector3(vec: Vector3, center: Vector3, factor: number): Vector3 {
  // Vektor vom Mittelpunkt zum Vertex
  const diff = vec.subtract(center)
  // Skalierten Vektor berechnen
  const scaledDiff = new Vector3(
    diff.x * factor,
    diff.y * factor,
    diff.z * factor,
  )
  // Neue Position = Mittelpunkt + skalierter Vektor
  return center.add(scaledDiff) // <-- Füge eine Add-Methode zur Vector3-Klasse hinzu, falls noch nicht vorhanden
}

function fillScanline(
  y: number, // Dies sollte bereits ein Integer sein (gerundet von aussen)
  x1: number, // Dies sind Gleitkommazahlen aus interpolate
  x2: number, // Dies sind Gleitkommazahlen aus interpolate
  z1: number,
  z2: number,
  // Akzeptiere RGB-Byte-Werte (0-255) direkt
  rByte: number,
  gByte: number,
  bByte: number,
  applyZBias: boolean, // Wird weiterhin benötigt, um Z1/Z2 mit Bias zu berechnen
) {
  // Runde x1 und x2 einmal, bevor die Schleife beginnt
  const ix1 = Math.round(x1)
  const ix2 = Math.round(x2)
  // y sollte bereits von aussen gerundet sein, sicherheitshalber
  const iy = Math.round(y)

  let steps = ix2 - ix1 // Anzahl der Schritte (Pixel) auf dieser Scanline

  // Füge applyZBias zum Z-Wert hinzu, bevor du ihn interpolierst/nutzt
  const biasedZ1 = z1 + (applyZBias ? 3 : 0)
  const biasedZ2 = z2 + (applyZBias ? 3 : 0)

  if (steps === 0) {
    // Handle vertikale Linien (einzelner Pixel)
    // setPixel(ix1, iy, biasedZ1, rByte, gByte, bByte, 255); // y ist jetzt iy
    setPixel(ix1, iy, biasedZ1, rByte, gByte, bByte, 255) // Aufruf des globalen setPixel
    return
  }

  // Inkrementelle Z-Interpolation für die biased Z-Werte
  let currentZ = biasedZ1
  const zStep = (biasedZ2 - biasedZ1) / steps

  // Iteriere mit gerundeten Integer-Koordinaten (ix)
  for (let ix = ix1; ix <= ix2; ix++) {
    // Loop von gerundetem x1 bis gerundetem x2
    if (ix > screenDimensions.width || ix < -screenDimensions.width) return
    // Call the global setPixel with integer coordinates, biased Z, and byte colors
    setPixel(ix, iy, currentZ, rByte, gByte, bByte, 255) // Aufruf des globalen setPixel
    currentZ += zStep // Inkrementiere den Z-Wert für den nächsten Pixel
  }
}

// PASSE interpolate AN (falls nötig) und ziehe sie heraus
function interpolate(
  y: number,
  vA: { x: number; y: number; z: number },
  vB: { x: number; y: number; z: number },
): { x: number; z: number } | null {
  const epsilon = 1e-6 // Kleiner Wert für Toleranzvergleiche
  const yDiff = vB.y - vA.y

  if (Math.abs(yDiff) < epsilon) {
    if (Math.abs(y - vA.y) < epsilon) {
      return { x: vA.x, z: vA.z } // y ist auf gleicher Höhe, gib Punkt A zurück
    }
    return null // Horizontale Kante, aber y liegt nicht auf dieser Höhe
  }

  // Berechne den Interpolationsparameter t
  const t = (y - vA.y) / yDiff

  // Prüfe, ob t innerhalb des Segments liegt [0, 1] mit Toleranz
  if (t < -epsilon || t > 1 + epsilon) return null

  // Interpoliere X und Z linear basierend auf t
  const x = vA.x + t * (vB.x - vA.x)
  const z = vA.z + t * (vB.z - vA.z) // Linear interpolation of Z in screen space

  return { x, z } // Gib ein Objektliteral zurück
}

// --- ENDE HERAUSGELÖSTE HILFSFUNKTIONEN ---

// --- OPTIMIERTE fillTriangleProjected FUNKTION ---
function fillTriangleProjected(triangle: Triangle) {
  // Projiziere Eckpunkte ins 2D Bildschirm-System + behalte Z (Kameraraum)
  const projectedVertices = triangle.vertices.map(project) // 'project' erstellt Vektoren

  // Wenn irgendein Eckpunkt geclipped wurde (hinter Near Plane oder hinter Far Plane in 'project'), überspringe das Dreieck komplett
  if (projectedVertices.some((v) => v === null)) {
    return
  }

  // --- KORRIGIERTES BACKFACE CULLING mit Vektor vom Kamera zum Vertex ---
  // Nutze die Normale im Weltraum (triangle.normal) und den Vektor von der Kamera zu einem Vertex
  // Hier wird angenommen, dass triangle.normal die transformierte Normale für animierte Objekte ist

  const cameraPos = new Vector3(camera.x, camera.y, camera.z) // Erstellt einen neuen Vektor
  const vertexPos = triangle.vertices[0] // Nutze den ersten Vertex im Weltraum
  const camToVertex = vertexPos.subtract(cameraPos) // Erstellt einen neuen Vektor in subtract

  // Berechne das Punktprodukt der Dreiecksnormale (zeigt von Vorderseite weg) und des Vektors Kamera->Vertex
  // Wenn das Punktprodukt >= 0 ist, zeigt die Normale zur Kamera->Vertex-Richtung oder senkrecht dazu.
  // Das bedeutet, die Vorderseite des Dreiecks schaut WEG von der Kamera (oder ist kantenweise). Cull.
  // Wenn das Punktprodukt < 0 ist, zeigt die Normale entgegengesetzt zu Kamera->Vertex. Vorderseite schaut ZUR Kamera. Rendern.
  const dotCulling = triangle.normal.dot(camToVertex) // Benutzt die dot-Methode

  // Cull das Dreieck, wenn die Vorderseite von der Kamera weg zeigt UND es sich nicht um ein Player-Dreieck handelt
  if (dotCulling >= 0 && !triangle.isPlayer) {
    return // Dreieck verwerfen
  }
  // --- ENDE BACKFACE CULLING ---

  // Sortiere die projizierten Eckpunkte nach ihrer Y-Koordinate (aufsteigend) für die Scanline-Füllung
  // v1 ist oben, v3 ist unten
  projectedVertices.sort((a, b) => a.y - b.y)
  const v1 = projectedVertices[0]! // Nutze Non-null assertion, da wir oben auf null geprüft haben
  const v2 = projectedVertices[1]!
  const v3 = projectedVertices[2]!

  // --- FARBBERECHNUNG UND KONVERTIERUNG (Optimiert) ---
  // Berechne die finale Farbe (mit Beleuchtung) als RGB-Floats (0-1) EINMAL vor den Scanline-Schleifen
  let rFloat = 1.0,
    gFloat = 1.0,
    bFloat = 1.0 // Standard: Weiß
  const initialColor = hexToRgb(triangle.color) // Erstellt ein Objekt {r, g, b} (0-1)

  if (initialColor !== null) {
    rFloat = initialColor.r
    gFloat = initialColor.g
    bFloat = initialColor.b

    if (!triangle.bakedLight) {
      // Nutze die transformierte Normale, die in triangle.normal gespeichert sein sollte
      const lightLevels = calculateLightLevel(triangle.normal) // Gibt einen Float zurück
      rFloat = Math.max(0, Math.min(1, rFloat + lightLevels))
      gFloat = Math.max(0, Math.min(1, gFloat + lightLevels))
      bFloat = Math.max(0, Math.min(1, bFloat + lightLevels))
    }
  }

  // Konvertiere die finale Farbe zu RGB-Bytes (0-255) EINMAL für die Scanline-Funktion
  // Math.floor ist notwendig, um Integer-Werte zu erhalten, die in den Uint8ClampedArray passen
  const rByte = Math.floor(rFloat * 255) // Math.round geht auch, floor ist oft minimal schneller
  const gByte = Math.floor(gFloat * 255)
  const bByte = Math.floor(bFloat * 255)
  // --- ENDE FARBBERECHNUNG ---

  // --- HAUPT SCANLINE SCHLEIFE ---
  // Iteriere über jede horizontale Scanline von der Oberkante des Dreiecks (gerundet von v1.y)
  // bis zur Unterkante (gerundet von v3.y)
  for (let y = Math.round(v1.y); y <= Math.round(v3.y); y++) {
    // Äussere Schleife liefert gerundetes y

    // Interpoliere den Schnittpunkt der Scanline (y) mit der linken Kante des Dreiecks (v1-v3)
    const p1 = interpolate(y, v1, v3) // Ruft die herausgelöste interpolate Funktion auf

    // Interpoliere den Schnittpunkt der Scanline (y) mit der rechten Kante des Dreiecks
    // Die rechte Kante ist entweder v1-v2 (oberer Teil des Dreiecks) oder v2-v3 (unterer Teil)
    let p2: { x: number; z: number } | null = null
    if (y < v2.y) {
      p2 = interpolate(y, v1, v2) // Ruft die herausgelöste interpolate Funktion auf
    } else {
      p2 = interpolate(y, v2, v3) // Ruft die herausgelöste interpolate Funktion auf
    }

    // Wenn beide Schnittpunkte (p1 und p2) für diese Scanline gültig sind (y schneidet beide Kanten)
    if (p1 !== null && p2 !== null) {
      // Stelle sicher, dass der erste X-Wert (x1) kleiner oder gleich dem zweiten (x2) ist
      // Dies stellt sicher, dass die fillScanline Schleife korrekt läuft (von links nach rechts)
      if (p1.x < p2.x) {
        // Ruf die herausgelöste fillScanline Funktion auf
        // Übergib y, die X-Koordinaten, die Z-Werte und die vorberechneten Byte-Farben sowie applyZBias
        fillScanline(
          y,
          p1.x,
          p2.x,
          p1.z,
          p2.z,
          rByte,
          gByte,
          bByte,
          triangle.applyZBias,
        )
      } else {
        // Tausche p1 und p2, falls p2 weiter links liegt als p1
        fillScanline(
          y,
          p2.x,
          p1.x,
          p2.z,
          p1.z,
          rByte,
          gByte,
          bByte,
          triangle.applyZBias,
        )
      }
    }
  }
  // --- ENDE HAUPT SCANLINE SCHLEIFE ---
}

class Triangle {
  vertices: [Vector3, Vector3, Vector3]
  color: string
  normal: Vector3
  bakedLight: boolean
  isPlayer: boolean
  applyZBias: boolean

  constructor(
    v1: Vector3,
    v2: Vector3,
    v3: Vector3,
    color: string = "white",
    normal: Vector3,
    bakedLight: boolean,
    isPlayer: boolean = false,
    applyZBias: boolean = false,
  ) {
    this.vertices = [v1, v2, v3]
    this.color = color
    this.normal = normal
    this.bakedLight = bakedLight
    this.isPlayer = isPlayer
    this.applyZBias = applyZBias
  }
}

class collisionTriangle {
  vertices: [Vector3, Vector3, Vector3]
  normal: Vector3
  collisionType: collisionTypes
  originOffset: number

  constructor(
    v1: Vector3,
    v2: Vector3,
    v3: Vector3,
    normal: Vector3,
    collisionType: collisionTypes = collisionTypes.wall,
  ) {
    this.originOffset = 0
    this.vertices = [v1, v2, v3]
    this.collisionType = collisionType
    this.normal = normal
  }

  updateCollisionData(
    worldVertices: [Vector3, Vector3, Vector3],
    worldNormal: Vector3,
  ): void {
    this.vertices = worldVertices // Aktualisiere die Eckpunkte auf Weltraum-Koordinaten
    this.normal = worldNormal.normalize() // Aktualisiere und normalisiere die Normale im Weltraum

    this.originOffset = -this.normal.dot(this.vertices[0])
  }
}

const collisionTriangles: collisionTriangle[] = [
  new collisionTriangle(
    new Vector3(10, 0, 0),
    new Vector3(-10, 0, -10),
    new Vector3(-10, 0, 10),
    calculateNormal(
      new Vector3(10, 0, 0),
      new Vector3(-10, 0, -10),
      new Vector3(-10, 0, 10),
    ),
  ),
]
initCollisions()

function calculateLightDirection(yaw: number, pitch: number): Vector3 {
  let dir = new Vector3(0, 0, 1)

  const cosPitch = Math.cos(pitch)
  const sinPitch = Math.sin(pitch)
  const pitchedY = dir.y * cosPitch - dir.z * sinPitch
  const pitchedZ = dir.y * sinPitch + dir.z * cosPitch
  dir.y = pitchedY
  dir.z = pitchedZ

  const cosYaw = Math.cos(yaw)
  const sinYaw = Math.sin(yaw)
  const yawedX = dir.x * cosYaw + dir.z * sinYaw
  const yawedZ = dir.z * cosYaw - dir.x * sinYaw
  dir.x = yawedX
  dir.z = yawedZ

  return dir.normalize()
}

function calculateLightLevel(normal: Vector3): number {
  const dot = normal.dot(lightDir)

  const levelFloat = dot + 0.5

  return levelFloat / 8
}

function getRandomColor() {
  const letters = "0123456789ABCDEF"
  let color = "#"
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random(0, 1) * 16)]
  }
  return color
}

let playerObj: {
  leftArm: AnimatableObject
  rightArm: AnimatableObject
  Head: AnimatableObject
  Body: AnimatableObject
  leftLeg: AnimatableObject
  rightLeg: AnimatableObject
} = {
  leftArm: resetAnimatableObject(), // Initialisiere direkt
  rightArm: resetAnimatableObject(), // Initialisiere direkt
  Head: resetAnimatableObject(), // Initialisiere direkt
  Body: resetAnimatableObject(), // Initialisiere direkt
  leftLeg: resetAnimatableObject(), // Initialisiere direkt
  rightLeg: resetAnimatableObject(), // Initialisiere direkt
}

let scene: Triangle[] = []

//__ Fetch Model Data __
const mario_model =
  "https://api.jsonsilo.com/public/7cd9822c-f656-466c-aab5-dfc9e4cfb5eb"
const wispy =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/wisp_anim"
const this_will_crash =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/bob"
const textured =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/cube_textured"
const mario_test =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/mario_wisp_test"
const wisp_model_01 =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/wisp_model_01"
const test_map =
  "https://raw.githubusercontent.com/3ngelch3n/code_wisp/refs/heads/main/testmap"
let playerCenter = new Vector3(0, 0, 0)
let playerCount = 0

importPlayer()
loadModel(scene, test_map)
/*let scale = 3
const v1 = new Vector3(10*scale,0,10*scale)
const v2 = new Vector3(-10*scale,0,10*scale)
const v3 = new Vector3(10*scale,0,-10*scale)
scene.push(new Triangle(v1, v2, v3, "#00A0FF", calculateNormal(
                         v1, v2, v3), true, false))
const v11 = new Vector3(-10*scale,0,-10*scale)
const v12 = new Vector3(-10*scale,0,10*scale)
const v13 = new Vector3(10*scale,0,-10*scale)
scene.push(new Triangle(v11, v12, v13, "#001AFF", calculateNormal(
                         v11, v12, v13), true, false))
*/
function rgbToUint32(r: number, g: number, b: number, a: number = 1.0): number {
  const ir = Math.floor(Math.max(0.0, Math.min(1.0, r)) * 255 + 0.5)
  const ig = Math.floor(Math.max(0.0, Math.min(1.0, g)) * 255 + 0.5)
  const ib = Math.floor(Math.max(0.0, Math.min(1.0, b)) * 255 + 0.5)
  const ia = Math.floor(Math.max(0.0, Math.min(1.0, a)) * 255 + 0.5)
  return (ia << 24) | (ir << 16) | (ig << 8) | ib
}

//__ RGB zu Hex Konverter __
function rgbToHex(r: number, g: number, b: number): string {
  const toHex = (c: number): string => {
    const clampedC = Math.max(0, Math.min(1, c))
    const hex = Math.floor(clampedC * 255).toString(16)
    return hex.length === 1 ? "0" + hex : hex
  }
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`
}

function hexToRgb(
  hexString: string,
): { r: number; g: number; b: number } | null {
  const cleanHexString = hexString.startsWith("#")
    ? hexString.slice(1)
    : hexString

  if (cleanHexString.length !== 6) {
    console.error(
      `Ungültige Hex-String Länge: "${hexString}". Erwarte 6 Zeichen (oder 7 mit #).`,
    )
    return null // Ungültige Länge
  }

  const rHex = cleanHexString.substring(0, 2)
  const gHex = cleanHexString.substring(2, 4)
  const bHex = cleanHexString.substring(4, 6)

  const rInt = parseInt(rHex, 16)
  const gInt = parseInt(gHex, 16)
  const bInt = parseInt(bHex, 16)

  if (isNaN(rInt) || isNaN(gInt) || isNaN(bInt)) {
    console.error(`Ungültige Hex-Zeichen im String: "${hexString}".`)
    return null
  }

  const rFloat = rInt / 255.0
  const gFloat = gInt / 255.0
  const bFloat = bInt / 255.0

  return { r: rFloat, g: gFloat, b: bFloat }
}

function resetAnimatableObject() {
  return new AnimatableObject(new Vector3(0, 0, 0), new rotation(0, 0, 0), [])
}

forever(function () {
  gameLoop()
})

function drawFrame() {
  ctx.clearRect(0, 0, gamecan.width, gamecan.height)
  zBuffer.fill(Infinity)
  pixelBuffer.fill(0)

  scene
    .filter((triangle) => !triangle.isPlayer)
    .forEach((triangle) => {
      fillTriangleProjected(triangle)
    })

  const outlineScaleFactor = 1.1
  const outlineColor = "#333333"
  const off = 4
  scene
    .filter((triangle) => triangle.isPlayer)
    .forEach((triangle) => {
      const scaledV1 = scaleVector3(
        triangle.vertices[0],
        playerCenter.add(
          new Vector3(
            player.position.x,
            player.position.y + off,
            player.position.z,
          ),
        ),
        outlineScaleFactor,
      )
      const scaledV2 = scaleVector3(
        triangle.vertices[1],
        playerCenter.add(
          new Vector3(
            player.position.x,
            player.position.y + off,
            player.position.z,
          ),
        ),
        outlineScaleFactor,
      )
      const scaledV3 = scaleVector3(
        triangle.vertices[2],
        playerCenter.add(
          new Vector3(
            player.position.x,
            player.position.y + off,
            player.position.z,
          ),
        ),
        outlineScaleFactor,
      )

      const outlineTriangle = new Triangle(
        scaledV1,
        scaledV2,
        scaledV3,
        outlineColor,
        new Vector3(0, 0, 0),
        true,
        true,
        true,
      )

      fillTriangleProjected(outlineTriangle)
    })
  scene
    .filter((triangle) => triangle.isPlayer)
    .forEach((triangle) => {
      // Beleuchtung wird in fillTriangleProjected angewendet, da bakedLight false ist
      fillTriangleProjected(triangle)
    })
  ctx.putImageData(imageData, 0, 0)
  drawFPS()

  scene
    .filter((triangle) => triangle.isPlayer)
    .forEach((triangle) => {
      scene.pop()
    })
}

function gameLoop() {
  inputs()
  updatePlayer()
  updateCamera()
  updateLight()
  updateAnimations()
  drawFrame()
  //requestAnimationFrame(gameLoop);
}

function updateLight() {
  lightDir = calculateLightDirection(light.yaw, light.pitch)
}

let animationTimer = 0
let animationTime = 0
let animTime = 0
let animTime2 = 0
let speed = 0
function updateAnimations() {
  const animatedBodyTriangles = setAnimationTypePositionsRotations(
    playerObj.Body,
  )
  const animatedHeadTriangles = setAnimationTypePositionsRotations(
    playerObj.Head,
  )
  const animatedLeftArmTriangles = setAnimationTypePositionsRotations(
    playerObj.leftArm,
  )
  const animatedRightArmTriangles = setAnimationTypePositionsRotations(
    playerObj.rightArm,
  )
  const animatedLeftLegTriangles = setAnimationTypePositionsRotations(
    playerObj.leftLeg,
  )
  const animatedRightLegTriangles = setAnimationTypePositionsRotations(
    playerObj.rightLeg,
  )

  scene = scene.concat(
    animatedBodyTriangles,
    animatedHeadTriangles,
    animatedLeftArmTriangles,
    animatedRightArmTriangles,
    animatedLeftLegTriangles,
    animatedRightLegTriangles,
  )
}

function setAnimationTypePositionsRotations(
  anim: AnimatableObject,
): Triangle[] {
  const endModel: Triangle[] = []

  anim.model?.forEach((triangle) => {
    const transformedVerts: Vector3[] = triangle.vertices.map((v) => {
      let newPos = applyRotation(
        v,
        new rotation(
          anim.rotation.yaw,
          anim.rotation.pitch,
          anim.rotation.roll,
        ),
      )
      newPos = newPos.add(anim.position)
      newPos = applyRotation(
        newPos,
        new rotation(player.yaw + 90, player.pitch, 0),
      )
      return newPos.add(player.position)
    })

    const transformedTriangle = new Triangle(
      transformedVerts[0],
      transformedVerts[1],
      transformedVerts[2],
      triangle.color,
      calculateNormal(
        transformedVerts[0],
        transformedVerts[1],
        transformedVerts[2],
      ),
      triangle.bakedLight,
      triangle.isPlayer,
      triangle.applyZBias,
    )

    endModel.push(transformedTriangle)
  })

  return endModel
}

function applyRotation(vec: Vector3, rot: rotation): Vector3 {
  // einfache Rotation um X, Y, Z – in Radiant umrechnen!
  const rx = rot.pitch
  const ry = rot.yaw
  const rz = rot.roll

  let v = new Vector3(vec.x, vec.y, vec.z)

  // Rotation um X (Pitch)
  v = new Vector3(
    v.x,
    v.y * Math.cos(rx) - v.z * Math.sin(rx),
    v.y * Math.sin(rx) + v.z * Math.cos(rx),
  )

  // Rotation um Y (Yaw)
  v = new Vector3(
    v.x * Math.cos(ry) + v.z * Math.sin(ry),
    v.y,
    -v.x * Math.sin(ry) + v.z * Math.cos(ry),
  )

  // Rotation um Z (Roll)
  v = new Vector3(
    v.x * Math.cos(rz) - v.y * Math.sin(rz),
    v.x * Math.sin(rz) + v.y * Math.cos(rz),
    v.z,
  )

  return v
}

function drawSkyBox() {
  const scaleFactor = screenDimensions.height / skybox.height
  ctx.drawImage(
    skybox,
    0,
    0,
    skybox.width * scaleFactor,
    skybox.height * scaleFactor,
  )
}

function setPixel(
  x: number,
  y: number,
  z: number,
  rByte: number,
  gByte: number,
  bByte: number,
  aByte: number = 255,
  applyZBias: boolean = false,
) {
  const ix = Math.round(x)
  const iy = Math.round(y)

  if (
    ix < 0 ||
    iy < 0 ||
    ix >= screenDimensions.width ||
    iy >= screenDimensions.height
  )
    return

  const index = iy * screenDimensions.width + ix
  const bias = applyZBias ? 3 : 0
  const biasedZ = z + bias
  if (biasedZ < zBuffer[index]) {
    zBuffer[index] = biasedZ
    const pixelIndex = index * 4 // Jeder Pixel braucht 4 Bytes (R, G, B, A)
    pixelBuffer[pixelIndex] = rByte // Rot
    pixelBuffer[pixelIndex + 1] = gByte // Grün
    pixelBuffer[pixelIndex + 2] = bByte // Blau
    pixelBuffer[pixelIndex + 3] = aByte
  }
}

function drawFPS() {
  const now = performance.now()
  const delta = now - lastFrameTime
  lastFrameTime = now
  fps = 1000 / delta
  smoothFPS = smoothFPS * 0.9 + fps * 0.1
  ctx.fillStyle = "black"
  ctx.fillRect(0, 0, 230, 70)
  ctx.fillStyle = "lime"
  ctx.font = "bold 14px monospace"
  ctx.fillText("FPS: " + Math.round(smoothFPS), 5, 15)
  ctx.fillText(`X: ${camera.x.toFixed(2)}`, 5, 30)
  ctx.fillText(`Y: ${camera.y.toFixed(2)}`, 70, 30)
  ctx.fillText(`Z: ${camera.z.toFixed(2)}`, 135, 30)
  ctx.fillText(`FV: ${player.forwardVel.toFixed(2)}`, 5, 45)
  ctx.fillText(`PY: ${player.yaw.toFixed(2)}`, 80, 45)
  ctx.fillText(`M: ${intendedMag.toFixed(2)}`, 145, 45)
  ctx.fillText(`IY: ${player.intendedYaw.toFixed(2)}`, 5, 60)
}

function updateSkyBox() {
  switch (level) {
    case levels.castle_grounds:
      //Credits: https://www.textures-resource.com/nintendo_64/mario64/texture/1315/
      skybox.src = "https://i.postimg.cc/s2J6Lz4J/castle-grounds.png"
      break
  }
}

function rotateTowardsAngleDegrees(
  currentAngle: number,
  targetAngle: number,
  rotationSpeed: number, // Maximale Drehgeschwindigkeit pro Update in Grad
): number {
  let angleDifference = targetAngle - currentAngle

  // Passt die Differenz so an, dass sie im Bereich (-180, 180] Grad liegt
  // Findet den kürzesten Drehweg
  while (angleDifference > 180) {
    angleDifference -= 360
  }
  while (angleDifference <= -180) {
    angleDifference += 360
  }

  // Berechnet den tatsächlichen Drehbetrag, begrenzt durch rotationSpeed
  const rotateAmount =
    Math.sign(angleDifference) *
    Math.min(Math.abs(angleDifference), rotationSpeed)

  // Berechnet den neuen Winkel
  let newAngle = currentAngle + rotateAmount

  while (newAngle <= -180) {
    newAngle += 360
  }
  while (newAngle > 180) {
    newAngle -= 360
  }

  return newAngle
}

function inputs() {
  intendedX = 0
  intendedY = 0
  if (!camera.turningYaw) {
    if (Keyboard.keyDown(Key.ArrowRight)) {
      camera.targetYaw = camera.targetYaw - camera.stepAngle
      camera.targetYaw = ((camera.targetYaw % 360) + 360) % 360
      camera.turningYaw = true
    }
    if (Keyboard.keyDown(Key.ArrowLeft)) {
      camera.targetYaw = camera.targetYaw + camera.stepAngle
      camera.targetYaw = ((camera.targetYaw % 360) + 360) % 360
      camera.turningYaw = true
    }
  }
  if (Keyboard.keyHeld(Key.D)) {
    intendedY += 32
  }
  if (Keyboard.keyHeld(Key.A)) {
    intendedY -= 32
  }
  if (Keyboard.keyHeld(Key.S)) {
    intendedX -= 32
  }
  if (Keyboard.keyHeld(Key.W)) {
    intendedX += 32
  }
  intendedMag = Math.sqrt(intendedX * intendedX + intendedY * intendedY)
  player.intendedYaw = -camera.yaw + atan2(intendedX, intendedY)
}

function atan2(x: number, y: number): number {
  // Konstante für die Umrechnung von Radiant in Grad
  const RADIANS_TO_DEGREES = 180 / Math.PI

  if (x > 0) {
    // Winkel in Radiant * Umrechnungsfaktor
    return Math.atan(y / x) * RADIANS_TO_DEGREES
  } else if (x < 0 && y >= 0) {
    // (Winkel in Radiant + PI) * Umrechnungsfaktor
    return (Math.atan(y / x) + Math.PI) * RADIANS_TO_DEGREES
  } else if (x < 0 && y < 0) {
    // (Winkel in Radiant - PI) * Umrechnungsfaktor
    return (Math.atan(y / x) - Math.PI) * RADIANS_TO_DEGREES
  } else if (x === 0 && y > 0) {
    // PI/2 Radiant sind 90 Grad
    return 90 // Oder (Math.PI / 2) * RADIANS_TO_DEGREES, ergibt 90
  } else if (x === 0 && y < 0) {
    // -PI/2 Radiant sind -90 Grad
    return -90 // Oder (-Math.PI / 2) * RADIANS_TO_DEGREES, ergibt -90
  } else {
    // 0 Radiant ist 0 Grad
    return 0 // Oder 0 * RADIANS_TO_DEGREES, ergibt 0
  }
}

function updateCamera() {
  const cameraDist = 15
  const cameraHeightOffset = 8
  const cameraPitchAngle = -10
  /*const cameraDist = 20
  const cameraHeightOffset = 16
  const cameraPitchAngle = -70*/

  if (camera.turningYaw) {
    let diff = camera.targetYaw - camera.yaw
    diff = ((diff % 360) + 360) % 360
    if (diff > 180) {
      diff -= 360
    }

    if (Math.abs(diff) <= 0.1) {
      camera.yaw = camera.targetYaw
      camera.turningYaw = false
    } else {
      camera.yaw +=
        Math.sign(diff) *
        Math.min(Math.abs(diff), camera.turningSpeedYaw * (1 / 60))
    }
  }

  camera.yaw = ((camera.yaw % 360) + 360) % 360
  camera.pitch = cameraPitchAngle
  let dirZ = Math.cos(camera.yaw) * Math.cos(camera.pitch)
  let dirY = Math.sin(camera.pitch)
  let dirX = Math.sin(camera.yaw) * Math.cos(camera.pitch)

  camera.x = player.position.x + dirX * cameraDist
  camera.y = player.position.y + cameraHeightOffset - dirY * cameraDist
  camera.z = player.position.z - dirZ * cameraDist
}

function loadModel(model: Triangle[], modelUrl: string) {
  fetch(modelUrl)
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      return response.json()
    })
    .then((data) => {
      const vertices = data.vertices
      const faces = data.faces
      let sumX = 0,
        sumY = 0,
        sumZ = 0
      playerCount = vertices.length
      for (const vert of vertices) {
        sumX += vert[0]
        sumY += vert[1]
        sumZ += vert[2]
      }
      if (playerCount > 0) {
        playerCenter = new Vector3(
          sumX / playerCount,
          sumY / playerCount,
          sumZ / playerCount,
        )
      }
      for (const face of faces) {
        const faceIndic = face[0]
        const faceColor = face[1]
        if (faceIndic.length === 3) {
          const v1_3D = new Vector3(...vertices[faceIndic[0]])
          const v2_3D = new Vector3(...vertices[faceIndic[1]])
          const v3_3D = new Vector3(...vertices[faceIndic[2]])

          const normal = calculateNormal(v1_3D, v2_3D, v3_3D)

          /*if (enable_outlines) {
            const triangle = new Triangle(
              v1_3D,
              v2_3D,
              v3_3D,
              faceColor,
              normal,
              false,
              true,
            )
            model.push(triangle)
          } else {*/
          const triangle = new Triangle(
            v1_3D,
            v2_3D,
            v3_3D,
            faceColor,
            normal,
            false,
            false,
          )
          scene.push(triangle)
          //}
        }
      }
    })
    .catch((error) => {
      console.error("fehler beim laden der modeldata:", error)
    })
}

function initCollisions() {
  collisionTriangles.forEach((triangle) => {
    if (triangle.normal.y > 0.01) {
      triangle.collisionType = collisionTypes.floor
    } else if (triangle.normal.y < -0.01) {
      triangle.collisionType = collisionTypes.ceiling
    } else {
      triangle.collisionType = collisionTypes.wall
    }
  })
}

function updatePlayer() {
  const isIdle = player.forwardVel == 0
  player_actions_moving(isIdle)
  if (player.forwardVel == 0) {
    if (!isIdle) {
      player.animWannaState = 0
      animTime = 0
      animTime2 = 0
    }
    playerAnimIdle()
  } else {
    if (isIdle) {
      animTime = 0
      animTime2 = 0
    }
    playerAnimRunning(player.forwardVel / 3, 0)
  }
}

function player_actions_moving(was_standing_still: boolean) {
  updateGroundMovement()
  function updateGroundMovement() {
    const currentYaw = player.yaw
    const intendedYaw = player.intendedYaw
    const currentForwardVel = player.forwardVel
    const inputMagnitude = intendedMag // Globale Variable aus inputs()

    // Aktualisiere den Gierwinkel (Yaw) des Spielers sanft in Richtung intendedYaw
    // Nutzt deine existierende rotateTowardsAngleDegrees Funktion
    const rotationSpeed = 8 // Übernommen aus deiner alten update_walking_speed Logik
    if (inputMagnitude != 0) {
      if (was_standing_still) {
        player.yaw = intendedYaw
      } else {
        player.yaw = rotateTowardsAngleDegrees(
          currentYaw,
          intendedYaw,
          rotationSpeed,
        )
      }
    }
    // Aktualisiere die Vorwärtsgeschwindigkeit basierend auf Input (intendedMag)
    let maxTargetSpeed = 32 // Übernommen aus deiner alten update_walking_speed Logik
    let targetSpeed =
      inputMagnitude < maxTargetSpeed ? inputMagnitude : maxTargetSpeed

    // Glättungsfaktor: Bestimmt, wie schnell die Geschwindigkeit den Zielwert erreicht.
    // Passe diesen Wert an (z.B. 0.05 bis 0.2)
    const smoothingFactor = 0.1
    player.forwardVel += (targetSpeed - currentForwardVel) * smoothingFactor

    // Begrenze die Maximalgeschwindigkeit (übernommen aus deiner alten update_walking_speed Logik)
    if (player.forwardVel > 48) {
      player.forwardVel = 48
    }

    // Optional: Schnapp die Geschwindigkeit auf 0, wenn kein Input da ist
    // und die Geschwindigkeit sehr nahe bei 0 liegt
    if (targetSpeed === 0 && Math.abs(player.forwardVel) < 0.5) {
      player.forwardVel = 0
    }

    // Aktualisiere die Position des Spielers basierend auf forwardVel und dem aktuellen Yaw
    // Annahme: Math.sin/cos akzeptieren Grad
    const speed = player.forwardVel
    const yawDegrees = player.yaw

    const deltaX = speed * Math.sin(yawDegrees)
    const deltaZ = speed * Math.cos(yawDegrees)

    player.position.x += deltaX / 32
    player.position.z += deltaZ / 32

    // Anmerkung: Vertikale Bewegung (Y-Achse) wie Schwerkraft oder Sprünge
    // müsste separat behandelt werden. Diese Funktion macht nur die Bewegung in der XZ-Ebene.
  }
}

function importPlayer() {
  fetch(wispy)
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      return response.json()
    })
    .then((data) => {
      const vertices = data.vertices
      const faces = data.faces
      let sumX = 0,
        sumY = 0,
        sumZ = 0
      playerCount = vertices.length
      for (const vert of vertices) {
        sumX += vert[0]
        sumY += vert[1]
        sumZ += vert[2]
      }
      if (playerCount > 0) {
        playerCenter = new Vector3(
          sumX / playerCount,
          sumY / playerCount,
          sumZ / playerCount,
        )
      }
      for (const face of faces) {
        const faceIndic = face[0]
        const faceColor = face[1]
        let appendTo = playerObj.Body.model
        if (face[2] != null) {
          switch (face[2]) {
            case "Body":
              break
            case "LeftArm":
              appendTo = playerObj.leftArm.model
              break
            case "RightArm":
              appendTo = playerObj.rightArm.model
              break
            case "Head":
              appendTo = playerObj.Head.model
              break
            case "LeftLeg":
              appendTo = playerObj.leftLeg.model
              break
            case "RightLeg":
              appendTo = playerObj.rightLeg.model
              break
          }
        }
        if (faceIndic.length === 3) {
          const v1_3D = new Vector3(...vertices[faceIndic[0]])
          const v2_3D = new Vector3(...vertices[faceIndic[1]])
          const v3_3D = new Vector3(...vertices[faceIndic[2]])

          const normal = calculateNormal(v1_3D, v2_3D, v3_3D)

          if (enable_outlines) {
            const triangle = new Triangle(
              v1_3D,
              v2_3D,
              v3_3D,
              faceColor,
              normal,
              false,
              true,
            )
            appendTo.push(triangle)
          } else {
            const triangle = new Triangle(
              v1_3D,
              v2_3D,
              v3_3D,
              faceColor,
              normal,
              false,
              true,
            )
            appendTo.push(triangle)
          }
        }
      }
    })
    .catch((error) => {
      console.error("fehler beim laden der modeldata:", error)
    })
}

function playerAnimStart() {
  animationTimer = 0
  switch (currentAnimation) {
    case animations.idle:
      break
  }
}

function playerAnimRunning(runSpeed: number, off: number) {
  const timeSin = Math.sin(animTime)
  const timeSin2 = Math.sin(animTime2)
  playerObj.rightArm.rotation = new rotation(
    timeSin2 * 32 - 10,
    40 + timeSin2,
    0,
  )
  playerObj.rightArm.position = new Vector3(-timeSin2 * 1.3, -0.5, -3)
  playerObj.leftArm.rotation = new rotation(
    off + timeSin * 32 + 10,
    -40 - timeSin,
    0,
  )
  playerObj.leftArm.position = new Vector3(timeSin * 1.3, -0.5, 3)

  playerObj.leftLeg.rotation = new rotation(off, 0, timeSin2 * 60)
  playerObj.leftLeg.position = new Vector3(
    timeSin2 * 1.4,
    Math.abs(timeSin2),
    0,
  )
  playerObj.rightLeg.rotation = new rotation(off, 0, -timeSin * 60)
  playerObj.rightLeg.position = new Vector3(
    -timeSin * 1.4,
    Math.abs(timeSin),
    0,
  )

  playerObj.Body.rotation = new rotation(off + timeSin * 3, 0, 0)
  playerObj.Body.position = new Vector3(-0.2, timeSin2 / 8, 0)
  playerObj.Head.rotation = new rotation(off - timeSin2 * 7, 0, 7 - timeSin)
  playerObj.Head.position = new Vector3(0.2, timeSin2 / 7 - 0.1, 0)
  const diff = Math.random(-0.3, 0.3)
  animTime = (animTime + runSpeed + diff) % 360
  animTime2 = (animTime2 + runSpeed - diff) % 360
}

function playerAnimIdle() {
  const timeSin = Math.sin(animTime)
  const timeSinAbs = Math.abs(timeSin)
  const timeSinAbs4 = Math.abs(timeSin) / 4
  const timeSin2 = Math.sin(animTime2)
  player.animWannaState = (player.animWannaState + 1) % 270
  playerObj.rightArm.rotation = new rotation(0, timeSin, -timeSinAbs)
  playerObj.rightArm.position = new Vector3(0, -timeSinAbs4, 0)
  playerObj.leftArm.rotation = new rotation(0, timeSin, -timeSinAbs)
  playerObj.leftArm.position = new Vector3(0, -timeSinAbs4, 0)

  playerObj.leftLeg.rotation = new rotation(0, 0, -timeSin * 3)
  playerObj.leftLeg.position = new Vector3(0, 0, 0)
  playerObj.rightLeg.rotation = new rotation(0, 0, timeSin * 3)
  playerObj.rightLeg.position = new Vector3(0, 0, 0)

  playerObj.Body.rotation = new rotation(0, 0, 0)
  playerObj.Body.position = new Vector3(0, -timeSinAbs4, 0)
  if (player.animWannaState > 90) {
    playerObj.Head.rotation = new rotation(timeSin2 * 28, 0, timeSinAbs)
  } else {
    playerObj.Head.rotation = new rotation(timeSin2 / 2, 0, timeSinAbs)
  }
  playerObj.Head.position = new Vector3(0, -timeSinAbs4, 0)
  const diff = Math.random(-0.3, 0.3)
  animTime = (animTime + 3 + diff) % 360
  animTime2 = (animTime2 + 2 - diff) % 360
}

function playerAnimJumpStart() {
  if (animationTimer == 0) {
    animationTimer = 0
    animationTime = 30
  }
  playerObj.rightArm.rotation = new rotation(0, 0, 0)
  playerObj.rightArm.position = new Vector3(0, 0, 0)
  playerObj.leftArm.rotation = new rotation(0, 0, 0)
  playerObj.leftArm.position = new Vector3(0, 0, 0)

  playerObj.leftLeg.rotation = new rotation(0, 0, 0)
  playerObj.leftLeg.position = new Vector3(0, 0, 0)
  playerObj.rightLeg.rotation = new rotation(0, 0, 0)
  playerObj.rightLeg.position = new Vector3(0, 0, 0)

  playerObj.Body.rotation = new rotation(0, 0, 0)
  playerObj.Body.position = new Vector3(0, 0, 0)
  playerObj.Head.rotation = new rotation(0, 0, 0)
  playerObj.Head.position = new Vector3(0, 0 + animationTimer, 0)

  if (animationTimer < animationTime) animationTimer++
  if (animationTimer == animationTime) currentAnimation = animations.idle
}
//LATESTBACKUO
