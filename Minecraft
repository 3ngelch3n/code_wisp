//GAME
const sChunkX = 16
const sChunkY = 16
const sChunkYA = 4
const sChunkZ = 16

interface subChunk {
  y: number
  fullAir: boolean
  blocks: blockTypes[]
}

interface chunk {
  x: number
  z: number
  subChunks: subChunk[]
}

interface world {
  chunks: chunk[]
}

enum blockTypes {
  air,
  stone,
  dirt,
  grass,
}

function createChunk(x: number, z: number): chunk {
  const subChunks: subChunk[] = []

  for (let y = 0; y < sChunkYA; y++) {
    const blocks: blockTypes[] = new Array(sChunkX * sChunkY * sChunkZ).fill(
      blockTypes.air,
    )

    let fullAir = true
    for (let i = 0; i < blocks.length; i++) {
      if (Math.random(0, 10) == 0) {
        blocks[i] = blockTypes.stone
        fullAir = false
      }
    }

    subChunks.push({
      y,
      fullAir: fullAir,
      blocks,
    })
  }

  return {
    x,
    z,
    subChunks,
  }
}

function index(x: number, y: number, z: number): number {
  return y * sChunkX * sChunkZ + z * sChunkX + x
}

function setBlock(c: chunk, x: number, y: number, z: number, type: blockTypes) {
  // Check if coordinates are within chunk bounds
  if (
    x < 0 ||
    x >= sChunkX ||
    y < 0 ||
    y >= sChunkYA * sChunkY ||
    z < 0 ||
    z >= sChunkZ
  ) {
    // Log an error or simply do nothing if the block is outside the chunk
    console.error(
      `Attempted to set a block outside of chunk bounds: (${x}, ${y}, ${z})`,
    )
    return
  }

  const subChunkIndex = Math.floor(y / sChunkY)
  const localY = y % sChunkY
  const subChunk = c.subChunks[subChunkIndex]

  // This check is a safeguard, though the bounds check above should prevent it
  if (!subChunk) {
    console.error(`SubChunk at index ${subChunkIndex} is undefined.`)
    return
  }

  subChunk.blocks[index(x, localY, z)] = type
}

function getBlock(c: chunk, x: number, y: number, z: number): blockTypes {
  // Check if coordinates are within chunk bounds
  if (
    x < 0 ||
    x >= sChunkX ||
    y < 0 ||
    y >= sChunkYA * sChunkY ||
    z < 0 ||
    z >= sChunkZ
  ) {
    // Return a safe, non-solid block type for out-of-bounds requests
    return blockTypes.air
  }

  const subChunkIndex = Math.floor(y / sChunkY)
  const localY = y % sChunkY
  const subChunk = c.subChunks[subChunkIndex]

  // Safeguard check, though the bounds check should handle it
  if (!subChunk) {
    return blockTypes.air
  }

  return subChunk.blocks[index(x, localY, z)]
}

const world: world = { chunks: [] }

for (let cx = 0; cx <= 1; cx++) {
  for (let cz = 0; cz <= 1; cz++) {
    const c = createChunk(cx, cz)

    for (let x = 0; x < sChunkX; x++) {
      for (let z = 0; z < sChunkZ; z++) {
        for (let y = 2; y < sChunkY; y++) {
          if (y < sChunkY - 2) {
            setBlock(c, x, y, z, blockTypes.stone) // unten Stein
          } else if (y === sChunkY - 2) {
            setBlock(c, x, y, z, blockTypes.dirt) // dann Dirt
          } else if (y === sChunkY - 1) {
            setBlock(c, x, y, z, blockTypes.grass) // oben Gras
          }
        }
      }
    }

    world.chunks.push(c)
  }
}

function isTransparent(type: blockTypes): boolean {
  return type === blockTypes.air
}

// ==================== 3D Renderer + Camera ====================

type Vec3 = [number, number, number]
type Triangle = [Vec3, Vec3, Vec3, number]

const camera = {
  x: 0,
  y: 20,
  z: -10,
  yaw: 0,
  pitch: 0,
  fov: 90,
  nearZ: 0.1,
  focalLength: 300,
  yawCos: 0,
  yawSin: 0,
  pitchCos: 0,
  pitchSin: 0,
  scale: 30,
}
let scene: Triangle[] = []

function addCube(center: Vec3, size: number = 1, colors?: any) {
  const c = size / 2
  const cx = center[0]
  const cy = center[1]
  const cz = center[2]

  const v: Vec3[] = [
    [-c, -c, -c],
    [c, -c, -c],
    [-c, c, -c],
    [c, c, -c],
    [-c, -c, c],
    [c, -c, c],
    [-c, c, c],
    [c, c, c],
  ]

  for (let i = 0; i < v.length; i++) {
    v[i][0] += cx
    v[i][1] += cy
    v[i][2] += cz
  }

  const col = colors || {
    front: 0xff0000,
    back: 0x00ff00,
    top: 0x0000ff,
    bottom: 0xffff00,
    left: 0xff00ff,
    right: 0x00ffff,
  }

  const push = (i1: number, i2: number, i3: number, color: number) =>
    scene.push([v[i1], v[i2], v[i3], color])

  // Front
  push(4, 5, 7, col.front)
  push(4, 7, 6, col.front)
  // Back
  push(1, 0, 2, col.back)
  push(1, 2, 3, col.back)
  // Top
  push(2, 6, 7, col.top)
  push(2, 7, 3, col.top)
  // Bottom
  push(0, 1, 5, col.bottom)
  push(0, 5, 4, col.bottom)
  // Left
  push(0, 4, 6, col.left)
  push(0, 6, 2, col.left)
  // Right
  push(5, 1, 3, col.right)
  push(5, 3, 7, col.right)
}

function isFrontface(tri: Triangle): boolean {
  const p1 = tri[0]
  const p2 = tri[1]
  const p3 = tri[2]

  const ux = p2[0] - p1[0]
  const uy = p2[1] - p1[1]
  const uz = p2[2] - p1[2]

  const vx = p3[0] - p1[0]
  const vy = p3[1] - p1[1]
  const vz = p3[2] - p1[2]

  const dx = p1[0] - camera.x
  const dy = p1[1] - camera.y
  const dz = p1[2] - camera.z

  const dot =
    (uy * vz - uz * vy) * dx +
    (uz * vx - ux * vz) * dy +
    (ux * vy - uy * vx) * dz

  return dot < 0
}

function vertexShader(p: Vec3): Vec3 | null {
  const dx = p[0] - camera.x
  const dy = p[1] - camera.y
  const dz = p[2] - camera.z

  /*const x1 = dx * camera.yawCos - dz * camera.yawSin
  const z1 = dx * camera.yawSin + dz * camera.yawCos

  const y2 = dy * camera.pitchCos - z1 * camera.pitchSin
  const z2 = dy * camera.pitchSin + z1 * camera.pitchCos*/
  const x1 = dx * camera.yawCos - dz * camera.yawSin
  const z1 = dx * camera.yawSin + dz * camera.yawCos

  const y2 = dy * camera.pitchCos - z1 * camera.pitchSin
  const z2 = dy * camera.pitchSin + z1 * camera.pitchCos

  if (z2 <= camera.nearZ) return null
  return [x1, y2, z2]
}

function projectToScreen(p: Vec3) {
  const s = camera.scale
  const f = camera.focalLength
  const x = (p[0] / p[2] / s) * f
  const y = (p[1] / p[2] / s) * f
  return [x, y, p[2]]
}

function fragmentShader(a: Vec3, b: Vec3, c: Vec3, color: number) {
  const p0 = projectToScreen(a)
  const p1 = projectToScreen(b)
  const p2 = projectToScreen(c)

  drawTriangle(
    p0[0],
    p0[1],
    p1[0],
    p1[1],
    p2[0],
    p2[1],
    color,
    -Math.min(p0[2], p1[2], p2[2]),
  )
}

function renderScene() {
  for (let tri of scene as any) {
    if (!isFrontface(tri)) continue
    const a = vertexShader(tri[0])
    const b = vertexShader(tri[1])
    const c = vertexShader(tri[2])
    if (!a || !b || !c) continue
    fragmentShader(a, b, c, tri[3])
  }
}

function inputs() {
  const speed = 0.2,
    rotSpeed = 2
  let rotatedY = false
  let rotatedP = false
  if (Keyboard.keyHeld(Key.J)) {
    camera.yaw -= rotSpeed
    rotatedY = true
  }
  if (Keyboard.keyHeld(Key.L)) {
    camera.yaw += rotSpeed
    rotatedY = true
  }
  if (Keyboard.keyHeld(Key.I)) {
    camera.pitch += rotSpeed
    rotatedP = true
  }
  if (Keyboard.keyHeld(Key.K)) {
    camera.pitch -= rotSpeed
    rotatedP = true
  }

  if (rotatedY) {
    camera.yawCos = Math.cos(camera.yaw)
    camera.yawSin = Math.sin(camera.yaw)
  }
  if (rotatedP) {
    camera.pitchCos = Math.cos(camera.pitch)
    camera.pitchSin = Math.sin(camera.pitch)
  }

  if (Keyboard.keyHeld(Key.W)) {
    camera.x += camera.yawSin * speed
    camera.z += camera.yawCos * speed
  }
  if (Keyboard.keyHeld(Key.S)) {
    camera.x -= camera.yawSin * speed
    camera.z -= camera.yawCos * speed
  }
  if (Keyboard.keyHeld(Key.A)) {
    camera.x -= camera.yawCos * speed
    camera.z += camera.yawSin * speed
  }
  if (Keyboard.keyHeld(Key.D)) {
    camera.x += camera.yawCos * speed
    camera.z -= camera.yawSin * speed
  }
  if (Keyboard.keyHeld(Key.H)) camera.y += speed
  if (Keyboard.keyHeld(Key.F)) camera.y -= speed
}

/* DEPRICATED::

function rotate3D(p: Vec3, yawCos: number, yawSin: number, pitchCos: number, pitchSin: number): Vec3 {
  const x1 = p[0] * yawCos - p[2] * yawSin
  const z1 = p[0] * yawSin + p[2] * yawCos

  const y2 = p[1] * pitchCos - z1 * pitchSin
  const z2 = p[1] * pitchSin + z1 * pitchCos

  return [x1, y2, z2]
}

*/

// ====================== INIT =======================
function init() {
  camera.scale = Math.tan(camera.fov / 2)
  camera.yawCos = Math.cos(camera.yaw)
  camera.yawSin = Math.sin(camera.yaw)
  camera.pitchCos = Math.cos(camera.pitch)
  camera.pitchSin = Math.sin(camera.pitch)
  for (const c of world.chunks as any) {
    c.mesh = buildChunkMesh(c)
  }
}

function buildChunkMesh(c: chunk) {
  // First pass for top faces
  for (let y = 0; y < sChunkYA * sChunkY; y++) {
    greedyTopFace(c, y);
  }

  // Second pass for side faces on the X-axis
  for (let x = 0; x < sChunkX; x++) {
    greedyXFace(c, x);
  }

  // Third pass for side faces on the Z-axis
  for (let z = 0; z < sChunkZ; z++) {
    greedyZFace(c, z);
  }
}

function addBlockFaces(c: chunk, x: number, y: number, z: number, type: blockTypes) {
  const blockSize = 1
  const halfSize = blockSize / 2
  const cx = c.x * sChunkX + x
  const cy = y
  const cz = c.z * sChunkZ + z

  const v: Vec3[] = [
    [cx - halfSize, cy - halfSize, cz - halfSize],
    [cx + halfSize, cy - halfSize, cz - halfSize],
    [cx - halfSize, cy + halfSize, cz - halfSize],
    [cx + halfSize, cy + halfSize, cz - halfSize],
    [cx - halfSize, cy - halfSize, cz + halfSize],
    [cx + halfSize, cy - halfSize, cz + halfSize],
    [cx - halfSize, cy + halfSize, cz + halfSize],
    [cx + halfSize, cy + halfSize, cz + halfSize],
  ]
  const push = (i1: number, i2: number, i3: number, color: number) =>
    scene.push([v[i1], v[i2], v[i3], color])
  const colors = {
    stone: 0x808080,
    dirt: 0x654321,
    grass: 0x00ff00,
  }
  const color = colors[blockTypes[type] as keyof typeof colors]

  if (getBlockWorld(cx + 1, cy, cz) === blockTypes.air) {
    push(5, 1, 3, color)
    push(5, 3, 7, color)
  }
  if (getBlockWorld(cx - 1, cy, cz) === blockTypes.air) {
    push(0, 4, 6, color)
    push(0, 6, 2, color)
  }
  if (getBlockWorld(cx, cy + 1, cz) === blockTypes.air) {
    push(2, 6, 7, color)
    push(2, 7, 3, color)
  }
  if (getBlockWorld(cx, cy - 1, cz) === blockTypes.air) {
    push(0, 1, 5, color)
    push(0, 5, 4, color)
  }
  if (getBlockWorld(cx, cy, cz + 1) === blockTypes.air) {
    push(4, 5, 7, color)
    push(4, 7, 6, color)
  }
  if (getBlockWorld(cx, cy, cz - 1) === blockTypes.air) {
    push(1, 0, 2, color)
    push(1, 2, 3, color)
  }
}

function greedyTopFace(c: chunk, y: number) {
  const mask: (number | null)[][] = []
  
  for (let z = 0; z < sChunkZ; z++) {
    mask[z] = []
    for (let x = 0; x < sChunkX; x++) {
      const block = getBlock(c, x, y, z)
      const above = getBlock(c, x, y + 1, z)
      mask[z][x] = (block !== blockTypes.air && above === blockTypes.air) ? block : null
    }
  }

  const visited: boolean[][] = Array.from({ length: sChunkZ }, () => Array(sChunkX).fill(false))

  for (let z = 0; z < sChunkZ; z++) {
    for (let x = 0; x < sChunkX; x++) {
      if (visited[z][x] || mask[z][x] === null) continue

      const color = mask[z][x]

      let width = 1
      while (x + width < sChunkX && mask[z][x + width] === color && !visited[z][x + width]) width++

      let height = 1
      let keep = true
      while (keep && z + height < sChunkZ) {
        for (let k = 0; k < width; k++) {
          if (mask[z + height][x + k] !== color || visited[z + height][x + k]) {
            keep = false
            break
          }
        }
        if (keep) height++
      }

      const x0 = c.x * sChunkX + x
      const z0 = c.z * sChunkZ + z
      if (color !== null) {
        console.log("added quad", color, width, height)
        addQuadTop([x0, y, z0], width, height, color)
      }
        
      // 4. Rechteck markieren
      for (let dz = 0; dz < height; dz++) {
        for (let dx = 0; dx < width; dx++) {
          visited[z + dz][x + dx] = true
        }
      }
    }
  }
}

function greedyXFace(c: chunk, x: number) {
  const maskLeft: (number | null)[][] = []
  const maskRight: (number | null)[][] = []

  for (let y = 0; y < sChunkYA * sChunkY; y++) {
    maskLeft[y] = []
    maskRight[y] = []
    for (let z = 0; z < sChunkZ; z++) {
      const block = getBlock(c, x, y, z)
      const leftNeighbor = getBlockWorld(c.x * sChunkX + x - 1, y, c.z * sChunkZ + z)
      const rightNeighbor = getBlockWorld(c.x * sChunkX + x + 1, y, c.z * sChunkZ + z)

      if (block !== blockTypes.air && isTransparent(leftNeighbor)) {
        maskLeft[y][z] = block
      } else {
        maskLeft[y][z] = null
      }

      if (block !== blockTypes.air && isTransparent(rightNeighbor)) {
        maskRight[y][z] = block
      } else {
        maskRight[y][z] = null
      }
    }
  }

  generateQuadsFromMask(maskLeft, c, x, addQuadLeft)
  generateQuadsFromMask(maskRight, c, x, addQuadRight)
}

function greedyZFace(c: chunk, z: number) {
  const maskBack: (number | null)[][] = []
  const maskFront: (number | null)[][] = []

  for (let y = 0; y < sChunkYA * sChunkY; y++) {
    maskBack[y] = []
    maskFront[y] = []
    for (let x = 0; x < sChunkX; x++) {
      const block = getBlock(c, x, y, z)
      const backNeighbor = getBlockWorld(c.x * sChunkX + x, y, c.z * sChunkZ + z - 1)
      const frontNeighbor = getBlockWorld(c.x * sChunkX + x, y, c.z * sChunkZ + z + 1)

      if (block !== blockTypes.air && isTransparent(backNeighbor)) {
        maskBack[y][x] = block
      } else {
        maskBack[y][x] = null
      }

      if (block !== blockTypes.air && isTransparent(frontNeighbor)) {
        maskFront[y][x] = block
      } else {
        maskFront[y][x] = null
      }
    }
  }

  generateQuadsFromMask(maskBack, c, z, addQuadBack)
  generateQuadsFromMask(maskFront, c, z, addQuadFront)
}

function addQuadX(start: Vec3, h: number, w: number, blockType: blockTypes) {
  const x = start[0]
  const y0 = start[1]
  const z0 = start[2]
  const colorMap = {
    stone: 0x808080,
    dirt: 0x654321,
    grass: 0x00ff00,
  }
  const color = colorMap[blockTypes[blockType] as keyof typeof colorMap]

  const v0: Vec3 = [x, y0, z0]
  const v1: Vec3 = [x, y0 + h, z0]
  const v2: Vec3 = [x, y0, z0 + w]
  const v3: Vec3 = [x, y0 + h, z0 + w]

  scene.push([v0, v3, v1, color])
  scene.push([v0, v2, v3, color])
}

function addQuadZ(start: Vec3, h: number, w: number, blockType: blockTypes) {
  const x0 = start[0]
  const y0 = start[1]
  const z = start[2]
  const colorMap = {
    stone: 0x808080,
    dirt: 0x654321,
    grass: 0x00ff00,
  }
  const color = colorMap[blockTypes[blockType] as keyof typeof colorMap]

  const v0: Vec3 = [x0, y0, z]
  const v1: Vec3 = [x0 + w, y0, z]
  const v2: Vec3 = [x0, y0 + h, z]
  const v3: Vec3 = [x0 + w, y0 + h, z]

  scene.push([v0, v3, v1, color])
  scene.push([v0, v2, v3, color])
}

function addQuadLeft(start: Vec3, h: number, w: number, blockType: blockTypes) {
  const x = start[0]
  const y0 = start[1]
  const z0 = start[2]
  const colorMap = {
    stone: 0x808080,
    dirt: 0x654321,
    grass: 0x00ff00,
  }
  const color = colorMap[blockTypes[blockType] as keyof typeof colorMap]
  const v0: Vec3 = [x, y0 + h, z0]
  const v1: Vec3 = [x, y0, z0]
  const v2: Vec3 = [x, y0, z0 + w]
  const v3: Vec3 = [x, y0 + h, z0 + w]
  scene.push([v0, v1, v2, color])
  scene.push([v0, v2, v3, color])
}

function addQuadRight(start: Vec3, h: number, w: number, blockType: blockTypes) {
  const x = start[0] + 1
  const y0 = start[1]
  const z0 = start[2]
  const colorMap = {
    stone: 0x808080,
    dirt: 0x654321,
    grass: 0x00ff00,
  }
  const color = colorMap[blockTypes[blockType] as keyof typeof colorMap]
  const v0: Vec3 = [x, y0, z0]
  const v1: Vec3 = [x, y0 + h, z0]
  const v2: Vec3 = [x, y0 + h, z0 + w]
  const v3: Vec3 = [x, y0, z0 + w]
  scene.push([v0, v1, v2, color])
  scene.push([v0, v2, v3, color])
}

function addQuadBack(start: Vec3, h: number, w: number, blockType: blockTypes) {
  const x0 = start[0]
  const y0 = start[1]
  const z = start[2]
  const colorMap = {
    stone: 0x808080,
    dirt: 0x654321,
    grass: 0x00ff00,
  }
  const color = colorMap[blockTypes[blockType] as keyof typeof colorMap]
  const v0: Vec3 = [x0 + w, y0, z]
  const v1: Vec3 = [x0, y0, z]
  const v2: Vec3 = [x0, y0 + h, z]
  const v3: Vec3 = [x0 + w, y0 + h, z]
  scene.push([v0, v1, v2, color])
  scene.push([v0, v2, v3, color])
}

function addQuadFront(start: Vec3, h: number, w: number, blockType: blockTypes) {
  const x0 = start[0]
  const y0 = start[1]
  const z = start[2] + 1
  const colorMap = {
    stone: 0x808080,
    dirt: 0x654321,
    grass: 0x00ff00,
  }
  const color = colorMap[blockTypes[blockType] as keyof typeof colorMap]
  const v0: Vec3 = [x0, y0, z]
  const v1: Vec3 = [x0 + w, y0, z]
  const v2: Vec3 = [x0 + w, y0 + h, z]
  const v3: Vec3 = [x0, y0 + h, z]
  scene.push([v0, v1, v2, color])
  scene.push([v0, v2, v3, color])
}

function generateQuadsFromMask(mask: (number | null)[][], c: chunk, axisCoord: number, addQuadFunc: (start: Vec3, h: number, w: number, blockType: blockTypes) => void) {
  const isXAxis = addQuadFunc === addQuadLeft || addQuadFunc === addQuadRight
  const visited: boolean[][] = Array.from({ length: sChunkYA * sChunkY }, () =>
    Array(isXAxis ? sChunkZ : sChunkX).fill(false)
  )
  
  const ySize = sChunkYA * sChunkY
  const otherSize = isXAxis ? sChunkZ : sChunkX

  for (let y = 0; y < ySize; y++) {
    for (let other = 0; other < otherSize; other++) {
      if (visited[y][other] || mask[y][other] === null) continue

      const color = mask[y][other]
      let height = 1
      while (y + height < ySize && mask[y + height][other] === color && !visited[y + height][other]) {
        height++
      }

      let width = 1
      let keep = true
      while (keep && other + width < otherSize) {
        for (let k = 0; k < height; k++) {
          if (mask[y + k][other + width] !== color || visited[y + k][other + width]) {
            keep = false
            break
          }
        }
        if (keep) width++
      }

      const x0 = isXAxis ? axisCoord : other
      const y0 = y
      const z0 = isXAxis ? other : axisCoord
      addQuadFunc([c.x * sChunkX + x0, y0, c.z * sChunkZ + z0], height, width, color)

      for (let dy = 0; dy < height; dy++) {
        for (let dw = 0; dw < width; dw++) {
          visited[y + dy][other + dw] = true
        }
      }
    }
  }
}

function addQuadTop(start: Vec3, w: number, h: number, blockType: blockTypes) {
  const x0 = start[0]
  const y = start[1]
  const z0 = start[2]
  const colorMap = {
    stone: 0x808080,
    dirt: 0x654321,
    grass: 0x00ff00
  }
  const color = colorMap[blockTypes[blockType] as keyof typeof colorMap]
  
  const v0: Vec3 = [x0, y + 1, z0]
  const v1: Vec3 = [x0 + w, y + 1, z0]
  const v2: Vec3 = [x0, y + 1, z0 + h]
  const v3: Vec3 = [x0 + w, y + 1, z0 + h]

  scene.push([v0, v3, v1, color])
  scene.push([v0, v2, v3, color])
}

function getBlockWorld(wx: number, wy: number, wz: number): blockTypes {
  const cx = Math.floor(wx / sChunkX)
  const cz = Math.floor(wz / sChunkZ)
  const lx = ((wx % sChunkX) + sChunkX) % sChunkX // local X
  const lz = ((wz % sChunkZ) + sChunkZ) % sChunkZ // local Z

  const chunk = getChunkAt(cx, cz)
  if (!chunk) return blockTypes.air

  return getBlock(chunk, lx, wy, lz)
}

function getChunkAt(cx: number, cz: number): chunk | undefined {
  return world.chunks.find(ch => ch.x === cx && ch.z === cz)
}

// ==================== Main Loop ====================
let t = 0
init()
forever(function () {
  t++
  inputs()
  /*scene = []
  // Beispielwürfel
  addCube([0, 0, 5], 2)
  addCube([3, 0, 8], 1, {
    front: 0xffff00,
    back: 0xff00ff,
    top: 0x00ffff,
    bottom: 0xff0000,
    left: 0x00ff00,
    right: 0x0000ff,
  })*/
  renderScene()
  drawFrame()
  fpsTxt.text = measureFPS().avgFps + ""
})

const fpsTxt = Game.createText("")
const cloneTxt = Game.createText("")
fpsTxt.x = -300
fpsTxt.y = 220
fpsTxt.style.align = "left"
cloneTxt.x = -300
cloneTxt.y = 180
cloneTxt.style.align = "left"
globals.gameRunning = true

const triAmt = 400

const SW2 = Game.width / 2
const SH2 = Game.height / 2

function createFrame() {
  for (let i = 0; i < triAmt; i++) {
    drawTriangle(
      Math.random(-SW2, SW2),
      Math.random(-SH2, SH2),
      Math.random(-SW2, SW2),
      Math.random(-SH2, SH2),
      Math.random(-SW2, SW2),
      Math.random(-SH2, SH2),
      randColor(),
      Math.random(-100, -1),
    )
  }
}

//------------- TRIANGLE RENDERER -------------
const xPixelSize = 2650 / 8 / Game.width
const yPixelSize = 1880 / 8 / Game.height
const triangleM = 64 / 55
sprite.x = 1000
sprite.y = 1000
sprite.size = 1
const t1 = "triangle_yh"
const t1_l = "triangle_yh_l"
const t1_r = "triangle_yh_r"

const allSprites = [
  "triangle_yh",
  "triangle_yh_r",
  "triangle_yh_l",
  "square_yh",
]

function randColor() {
  return Math.random(0x000000, 0xdddddd)
}

interface CloneEntry {
  clone: any
}
interface DrawEntry {
  width: number
  height: number
  x: number
  y: number
  rotation: number
  texture: string
  color: number
  dist: number
}

let cloneList: CloneEntry[] = []
let drawList: DrawEntry[] = []
let lastUsedClones = 0

let cloneGroups: { [key: string]: { clones: CloneEntry[]; lastUsed: number } } =
  {}
let drawGroups: { [key: string]: DrawEntry[] } = {}
function addToDrawList(entry: DrawEntry) {
  if (!drawGroups[entry.texture]) {
    drawGroups[entry.texture] = []
  }
  drawGroups[entry.texture].push(entry)
}

onCloneStart(function (clone) {
  cloneList.push({
    clone: clone,
  })
})

function drawFrame() {
  // Ein temporäres Objekt, um zu verfolgen, welche Klone in diesem Frame verwendet werden
  const usedClonesInThisFrame: { [key: string]: boolean } = {}

  // 1. Verarbeite die aktuelle Zeichnungsliste
  for (const texture in drawGroups) {
    const drawListSprite = drawGroups[texture]

    // Markiere die Textur als verwendet
    usedClonesInThisFrame[texture] = true

    let group = cloneGroups[texture]
    if (!group) {
      group = { clones: [], lastUsed: 0 }
      cloneGroups[texture] = group
    }

    // Erstelle neue Klone, falls nötig
    for (let j = group.clones.length; j < drawListSprite.length; j++) {
      const newClone = createClone()
      newClone.setCostume(texture)
      group.clones.push({ clone: newClone })
    }

    // Aktualisiere die Eigenschaften der verwendeten Klone
    for (let j = 0; j < drawListSprite.length; j++) {
      const entry = drawListSprite[j]
      const clone = group.clones[j].clone

      clone.layer = entry.dist
      clone.x = entry.x
      clone.y = entry.y
      clone.width = entry.width
      clone.height = entry.height
      clone.rotation = entry.rotation
      clone.tint = entry.color
      clone.visible = true
    }

    // Setze den Zähler für die nächste Runde
    group.lastUsed = drawListSprite.length
    drawGroups[texture] = []
  }

  // 2. Gehe durch alle Klon-Gruppen und blende unbenutzte Klone aus
  for (const texture in cloneGroups) {
    if (!usedClonesInThisFrame[texture]) {
      // Wenn diese Gruppe in diesem Frame nicht verwendet wurde, blende alle Klone aus
      const group = cloneGroups[texture]
      for (let j = 0; j < group.clones.length; j++) {
        group.clones[j].clone.visible = false
      }
      group.lastUsed = 0 // Setze den Zähler zurück
    } else {
      // Wenn die Gruppe verwendet wurde, aber weniger Klone als im letzten Frame,
      // blende die überschüssigen Klone aus
      const group = cloneGroups[texture]
      for (let j = group.lastUsed; j < group.clones.length; j++) {
        group.clones[j].clone.visible = false
      }
    }
  }
}

///*#
let lastTime = performance.now()
let frames = 0
let fps = 0
let avgFps = 0
const samples: number[] = []
const maxSamples = 100

function measureFPS() {
  frames++
  const now = performance.now()
  const diff = now - lastTime

  if (diff >= 1000) {
    fps = (frames * 1000) / diff

    samples.push(fps)
    if (samples.length > maxSamples) {
      samples.shift()
    }

    avgFps = samples.reduce((a, b) => a + b, 0) / samples.length

    frames = 0
    lastTime = now
  }

  return { fps, avgFps }
} //#

function drawTriangle(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
  color: number,
  dist: number,
) {
  const orientation = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)
  if (orientation > 0) {
    const tempX = x2
    x2 = x3
    x3 = tempX

    const tempY = y2
    y2 = y3
    y3 = tempY
  }

  //---TRIANGLE TYPE FILTER
  const triVals = analyzeTriangle(x1, y1, x2, y2, x3, y3)
  const hypSideP = triVals.hypSideP
  const rightTriangles = splitTriangleIntoRightTriangles(hypSideP)
  const t = rightTriangles[0]
  const triVals1 = analyzeTriangleR(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3)
  drawTrianglePartRA(
    triVals1.hypSideP,
    triVals1.kathl1,
    triVals1.kathl2,
    true,
    color,
    dist,
  )
  const d = rightTriangles[1]
  const triVals2 = analyzeTriangleR(d.x1, d.y1, d.x2, d.y2, d.x3, d.y3)
  drawTrianglePartRA(
    triVals2.hypSideP,
    triVals2.kathl1,
    triVals2.kathl2,
    true,
    color,
    dist,
  )
}

function splitTriangleIntoRightTriangles(hypSidePoints: {
  x1: number
  y1: number
  x2: number
  y2: number
  x3: number
  y3: number
}) {
  const A = { x: hypSidePoints.x1, y: hypSidePoints.y1 }
  const B = { x: hypSidePoints.x2, y: hypSidePoints.y2 }
  const C = { x: hypSidePoints.x3, y: hypSidePoints.y3 }
  const an = angleBetween(A, B)
  const g = intersectPoint(C, an, A, B)

  return [
    { x1: B.x, y1: B.y, x2: C.x, y2: C.y, x3: g.x, y3: g.y },
    { x1: A.x, y1: A.y, x2: g.x, y2: g.y, x3: C.x, y3: C.y },
  ]
}

function drawTrianglePartRA(
  hypSidePoints: { x1: number; y1: number; x2: number; y2: number },
  kathl: { x1: number; y1: number; x2: number; y2: number },
  kathl2: { x1: number; y1: number; x2: number; y2: number },
  c: boolean,
  co: number,
  dist: number,
) {
  const k1 = { x: kathl.x1, y: kathl.y1 }
  const k2 = { x: kathl.x2, y: kathl.y2 }

  const kk1 = { x: kathl2.x1, y: kathl2.y1 }
  const kk2 = { x: kathl2.x2, y: kathl2.y2 }

  const baseLength = distance(kk1, kk2)
  const height = distance(k1, k2)
  const midX = (k1.x + k2.x) / 2
  const midY = (k1.y + k2.y) / 2

  const rightPoint = {
    x:
      hypSidePoints.x1 !== kathl2.x1 || hypSidePoints.y1 !== kathl2.y1
        ? kathl2.x1
        : kathl2.x2,
    y:
      hypSidePoints.x1 !== kathl2.x1 || hypSidePoints.y1 !== kathl2.y1
        ? kathl2.y1
        : kathl2.y2,
  }
  const vx = k2.x - k1.x
  const vy = k2.y - k1.y
  const wx = rightPoint.x - k1.x
  const wy = rightPoint.y - k1.y

  const cross = vx * wy - vy * wx
  const rot = cross < 0 ? 90 : -90

  const angle = angleBetween(k1, k2) + rot
  const moved = move(midX, midY, angle, -height / 12.6)

  let drawSprite = t1_r
  if (rot == 90) drawSprite = t1_l
  addToDrawList({
    width: baseLength * xPixelSize * 1.91,
    height: height * yPixelSize * triangleM,
    x: moved.x,
    y: moved.y,
    rotation: angle + 90,
    texture: drawSprite,
    color: co,
    dist: dist,
  })
}

function trianglePieceHyp(
  kathl2: {
    x1: number
    y1: number
    x2: number
    y2: number
    x3: number
    y3: number
  },
  c: number,
  dist: number,
) {
  const p1 = { x: kathl2.x1, y: kathl2.y1 }
  const p2 = { x: kathl2.x2, y: kathl2.y2 }
  const p3 = { x: kathl2.x3, y: kathl2.y3 }
  const hypAngle = angleBetween(p1, p2)
  const p1p2xM = (p1.x + p2.x) / 2
  const p1p2yM = (p1.y + p2.y) / 2

  const angle = hypAngle - 180
  const height = distance({ x: p1p2xM, y: p1p2yM }, p3) * triangleM
  const moved = move(p1p2xM, p1p2yM, angle, -(height / 2) / triangleM)
  addToDrawList({
    width: distance(p1, p2) * xPixelSize,
    height: height * yPixelSize,
    x: moved.x,
    y: moved.y,
    rotation: angle + 90,
    texture: t1,
    color: c,
    dist: dist,
  })
}

function analyzeTriangle(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  const length_p1p2 = distance({ x: x1, y: y1 }, { x: x2, y: y2 })
  const length_p2p3 = distance({ x: x2, y: y2 }, { x: x3, y: y3 })
  const length_p3p1 = distance({ x: x3, y: y3 }, { x: x1, y: y1 })

  let hypSideP = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }

  if (length_p1p2 >= length_p2p3 && length_p1p2 >= length_p3p1) {
    hypSideP = { x1, y1, x2, y2, x3, y3 }
  } else if (length_p2p3 >= length_p1p2 && length_p2p3 >= length_p3p1) {
    hypSideP = { x1: x2, y1: y2, x2: x3, y2: y3, x3: x1, y3: y1 }
  } else {
    hypSideP = { x1: x3, y1: y3, x2: x1, y2: y1, x3: x2, y3: y2 }
  }

  return {
    hypSideP,
  }
}

function analyzeTriangleR(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  const length_p1p2 = distance({ x: x1, y: y1 }, { x: x2, y: y2 })
  const length_p2p3 = distance({ x: x2, y: y2 }, { x: x3, y: y3 })
  const length_p3p1 = distance({ x: x3, y: y3 }, { x: x1, y: y1 })

  let hypSideP = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }
  let kathl1 = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }
  let kathl2 = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }

  if (length_p1p2 >= length_p2p3 && length_p1p2 >= length_p3p1) {
    hypSideP = { x1, y1, x2, y2, x3, y3 }
    const k1 = { x1: x2, y1: y2, x2: x3, y2: y3, x3, y3 }
    const k2 = { x1: x3, y1: y3, x2: x1, y2: y1, x3, y3 }
    kathl1 = length_p2p3 >= length_p3p1 ? k1 : k2
    kathl2 = length_p2p3 >= length_p3p1 ? k2 : k1
  } else if (length_p2p3 >= length_p1p2 && length_p2p3 >= length_p3p1) {
    hypSideP = { x1: x2, y1: y2, x2: x3, y2: y3, x3: x1, y3: y1 }
    const k1 = { x1: x1, y1: y1, x2: x2, y2: y2, x3, y3 }
    const k2 = { x1: x3, y1: y3, x2: x1, y2: y1, x3, y3 }
    kathl1 = length_p1p2 >= length_p3p1 ? k1 : k2
    kathl2 = length_p1p2 >= length_p3p1 ? k2 : k1
  } else {
    hypSideP = { x1: x3, y1: y3, x2: x1, y2: y1, x3: x2, y3: y2 }
    const k1 = { x1: x1, y1: y1, x2: x2, y2: y2, x3, y3 }
    const k2 = { x1: x2, y1: y2, x2: x3, y2: y3, x3, y3 }
    kathl1 = length_p1p2 >= length_p2p3 ? k1 : k2
    kathl2 = length_p1p2 >= length_p2p3 ? k2 : k1
  }

  return {
    hypSideP,
    kathl1,
    kathl2,
  }
}

function getRightAngleVertex(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
  toleranceT: number = 1e-6,
): { x: number; y: number } | null {
  const dot1 = (x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1)
  if (Math.abs(dot1) < toleranceT) return { x: x1, y: y1 }

  const dot2 = (x1 - x2) * (x3 - x2) + (y1 - y2) * (y3 - y2)
  if (Math.abs(dot2) < toleranceT) return { x: x2, y: y2 }

  const dot3 = (x1 - x3) * (x2 - x3) + (y1 - y3) * (y2 - y3)
  if (Math.abs(dot3) < toleranceT) return { x: x3, y: y3 }

  return null
}

function drawLine(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  t: number,
  c: number,
  d: number = 100,
) {
  const p1 = { x: x1, y: y1 }
  const p2 = { x: x2, y: y2 }

  addToDrawList({
    width: xPixelSize * t,
    height: distance(p1, p2) * yPixelSize,
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2,
    rotation: angleBetween(p1, p2),
    texture: "square_yh",
    color: c,
    dist: d,
  })
}

function drawDot(x1: number, y1: number, t: number, c: number, dist: number) {
  addToDrawList({
    width: xPixelSize * t,
    height: t * yPixelSize,
    x: x1,
    y: y1,
    rotation: 0,
    texture: "square_yh",
    color: c,
    dist: dist,
  })
}

function move(x: number, y: number, rotation: number, amount: number) {
  return {
    x: x + Math.cos(rotation) * amount,
    y: y - Math.sin(rotation) * amount,
  }
}

function intersectPoint(
  p: { x: number; y: number },
  angle: number,
  a: { x: number; y: number },
  b: { x: number; y: number },
) {
  angle += 90
  const dx1 = b.x - a.x
  const dy1 = b.y - a.y
  const dx2 = Math.sin(angle)
  const dy2 = Math.cos(angle)

  const det = dx2 * dy1 - dy2 * dx1
  if (Math.abs(det) < 1e-10) {
    //console.log("PARALLEL")
    Game.stop()
  }

  const s = ((a.x - p.x) * dy1 - (a.y - p.y) * dx1) / det

  const ix = p.x + s * dx2
  const iy = p.y + s * dy2

  return { x: ix, y: iy }
}

function angleBetween(p1: any, p2: any): number {
  const dx = p2.x - p1.x
  const dy = p2.y - p1.y
  return Math.atan2(dx, dy)
}

function distance(p1: any, p2: any): number {
  const dx = p2.x - p1.x
  const dy = p2.y - p1.y
  return Math.sqrt(dx * dx + dy * dy)
}
//*/

/*
const textSize = 20
const textScX = 0.55
const textWidth = Math.ceil(Game.width / (textSize * textScX) / 1.86)
const textHeight = Math.ceil(Game.height / textSize)

// 1. Pro Tile ein Text-Objekt

const textObjects: Text[][] = []
let Camt = 0
for (let y = 0; y < textHeight; y++) {
  const row: Text[] = []
  for (let x = 0; x < textWidth; x++) {
    const t = Game.createText("██", {
      fontSize: textSize,
      fontFamily: "Cascadia Mono",
      lineHeight: textSize * 1.15,
      letterSpacing: -0.05,
      align: "center",
    })
    Camt++
    t.x = -Game.width / 2 + textSize / 2 + x * textSize
    t.y = -Game.height / 2 + textSize / 2 + y * textSize
    row.push(t)
  }
  textObjects.push(row)
}

// 2. Vorheriges Frame speichern (optional, für minimale Updates)
let prevFrame: number[][] = Array.from({ length: textHeight }, () =>
  Array(textWidth).fill(""),
)

// 3. FPS- und Clones-Text
const fpsTxt = Game.createText("")
fpsTxt.x = -300
fpsTxt.y = 220
fpsTxt.style.align = "left"

const cloneTxt = Game.createText("")
cloneTxt.x = -300
cloneTxt.y = 180
cloneTxt.style.align = "left"

cloneTxt.text = "" + Camt
// 4. Haupt-Loop, nur 1 Zeichen pro Tile setzen
forever(function () {
  for (let y = 0; y < textHeight; y++) {
    for (let x = 0; x < textWidth; x++) {
      //const color = palette[Math.floor(Math.random(0, palette.length))];
      const color = Math.random(0x000000, 0xffffff)
      if (prevFrame[y][x] !== color) {
        const r = textObjects[y][x]
        r.style.fill = color
        prevFrame[y][x] = color
      }
    }
  }

  fpsTxt.text = measureFPS().avgFps + ""
})

let lastTime = performance.now()
let frames = 0
let fps = 0
let avgFps = 0
const samples: number[] = []
const maxSamples = 100

function measureFPS() {
  frames++
  const now = performance.now()
  const diff = now - lastTime

  if (diff >= 1000) {
    fps = (frames * 1000) / diff
    samples.push(fps)
    if (samples.length > maxSamples) samples.shift()
    avgFps = samples.reduce((a, b) => a + b, 0) / samples.length
    frames = 0
    lastTime = now
  }

  return { fps, avgFps }
}
//EVERY PIXEL ONE TEXT DISPLAY
*/
//OPTIMIZED
