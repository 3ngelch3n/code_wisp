type float2 = { x: number; y: number }
//sprite.tint = 0x00ffff
sprite.y = 0
sprite.x = 0
const xPixelSize = 2650 / 8 / Game.width
const yPixelSize = 1880 / 8 / Game.height
//sprite.width = xPixelSize * Game.width
//sprite.height = yPixelSize * Game.height
sprite.visible = true
let ft = 0.1

/*sprite.setCostume("triangle_y")
sprite.layer = 1
sprite.tint = 0x0033ff
sprite.transparency = 50
wait(0)
sprite.width = 300
sprite.height = 300
createClone()
wait(0)
sprite.layer = 0
sprite.tint = 0x00ff00
sprite.setCostume("triangle_yh")
wait(100)*/

drawTriangle(-120, -160, 20, 130, 220, 0) ///HIER FEHLT UNTEN EIN GROßeS STÜCK
//drawTriangle(0, 0, 100, 200, 250, -100) //HIER PERFEKT
/*drawTriangle(
    -103,
    -212,
    -117,
    180,
    23,
    -140)*/
//DrawQuadrilateral(0, 0, 300, 50, 200, 100, 0, 150)
//drawLine(0,0,-150,120)

onCloneStart(function (clone) {
  onMessage("deleteAllClones", function (data) {
    console.log("DELTE")
    clone.delete()
  })
})

onMessage("drawFrame", function (data) {
  const xOff = 0 //Math.random(-100, 100)
  const yOff = 0 //Math.random(-100, 100)
  /*drawTriangle(
    0 + xOff,
    0 + yOff,
    100 + xOff,
    200 + yOff,
    250 + xOff,
    -100 + yOff,
  )*/
  /*const x1 = Math.random(-360, -10)
  const y1 = Math.random(-240, -10)
  const x2 = Math.random(-360, -10)
  const y2 = Math.random(10, 240)
  const x3 = Math.random(10, 360)
  const y3 = Math.random(-240, 240)
  drawTriangle(
    x1 + xOff,
    y1 + yOff,
    x2 + xOff,
    y2 + yOff,
    x3 + yOff,
    y3 + yOff,
  )
  console.log("l:", x1 + xOff,
    y1 + yOff,
    x2 + xOff,
    y2 + yOff,
    x3 + yOff,
    y3 + yOff,)*/
  drawTriangle(-103, -212, -117, 180, 23, -140)
})
//sendMessage("drawFrame")

forever(function () {
  if (Keyboard.keyHeld(Key.A)) {
    ft = 0.05
  } else {
    ft = 0.05
  }
  //sendMessage("deleteAllClones")
  //sendMessage("drawFrame")
  //wait(2)
})

function drawTriangle(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  sprite.layer = 1
  sprite.tint = 0x00aaff
  sprite.setCostume("square_yh")
  wait(0)
  drawLine(x1, y1, x2, y2, 2)
  wait(ft)
  drawLine(x2, y2, x3, y3, 2)
  wait(ft)
  drawLine(x1, y1, x3, y3, 2)

  sprite.tint = 0x0044ff
  const length_p1p2 = distance({ x: x1, y: y1 }, { x: x2, y: y2 })
  const length_p2p3 = distance({ x: x2, y: y2 }, { x: x3, y: y3 })
  const length_p3p1 = distance({ x: x3, y: y3 }, { x: x1, y: y1 })
  let hypSideP = { x1: 0, y1: 0, x2: 0, y2: 0 }

  if (length_p1p2 >= length_p2p3 && length_p1p2 >= length_p3p1) {
    hypSideP = { x1: x1, y1: y1, x2: x2, y2: y2 }
  } else if (length_p2p3 >= length_p1p2 && length_p2p3 >= length_p3p1) {
    hypSideP = { x1: x2, y1: y2, x2: x3, y2: y3 }
  } else {
    hypSideP = { x1: x3, y1: y3, x2: x1, y2: y1 }
  }
  //const heightA = height(x1, y1, x2, y2, x3, y3)

  //sprite.tint = 0xff0000
  sprite.layer = 0
  sprite.transparency = 0
  sprite.setCostume("triangle_yh")
  wait(ft)
  /*if (
    !(
      hypSideP.x1 === x1 &&
      hypSideP.y1 === y1 &&
      hypSideP.x2 === x2 &&
      hypSideP.y2 === y2
    )
  ) {
    trianglePiece(x1, y1, x2, y2, x3, y3, {
      x1: hypSideP.x1,
      y1: hypSideP.y1,
      x2: hypSideP.x2,
      y2: hypSideP.y2,
    })
  }*/
  wait(ft)
  if (
    !(
      hypSideP.x1 === x2 &&
      hypSideP.y1 === y2 &&
      hypSideP.x2 === x3 &&
      hypSideP.y2 === y3
    )
  ) {
    trianglePiece(x2, y2, x3, y3, x1, y1, {
      x1: hypSideP.x1,
      y1: hypSideP.y1,
      x2: hypSideP.x2,
      y2: hypSideP.y2,
    })
  }
  wait(ft)
  if (
    !(
      hypSideP.x1 === x3 &&
      hypSideP.y1 === y3 &&
      hypSideP.x2 === x1 &&
      hypSideP.y2 === y1
    )
  ) {
    trianglePiece(x3, y3, x1, y1, x2, y2, {
      x1: hypSideP.x1,
      y1: hypSideP.y1,
      x2: hypSideP.x2,
      y2: hypSideP.y2,
    })
  }

  function trianglePiece(
    kath1x: number,
    kath1y: number,
    kath2x: number,
    kath2y: number,
    hypx: number,
    hypy: number,
    hypSidePoints: { x1: number; y1: number; x2: number; y2: number },
  ) {
    const k1 = { x: kath1x, y: kath1y }
    const k2 = { x: kath2x, y: kath2y }
    const roundDown = 0.95
    const kathxm = (kath1x + kath2x) / 2
    const kathym = (kath1y + kath2y) / 2
    sprite.x = kathxm
    sprite.y = kathym
    const angle = angleBetween(k1, k2)
    sprite.rotation = angle
    sprite.tint = 0xff5500
    sprite.layer = 2
    sprite.rotation += 90
    sprite.height = 200
    createClone()
    sprite.layer = 0
    sprite.rotation -= 90
    sprite.tint = 0x0055ff
    sprite.width = distance(k1, k2) * xPixelSize * roundDown
    const hypA = { x: hypSidePoints.x1, y: hypSidePoints.y1 }
    const hypB = { x: hypSidePoints.x2, y: hypSidePoints.y2 }
    
    const hypM = { x: (hypA.x + hypB.x) / 2, y: (hypA.y + hypB.y) / 2 }
    const dis =
      ((distance({ x: kathxm, y: kathym }, hypM) / 52) * 64) * 1.1
    sprite.height = dis * yPixelSize
    sprite.move(dis / 2 * 0.89)
    sprite.rotation -= 90
    createClone()
    ////
    
    sprite.tint = 0x00ff00
    sprite.width = 4
    sprite.height = 4
    sprite.x = hypM.x
    sprite.y = hypM.y
    createClone()
    
    
    ////
    /*wait(0)
    sprite.tint = 0x00ff00
    sprite.width = 50
    sprite.height = 50
    sprite.x = kathxm
    sprite.y = kathym
    wait(0)
    createClone()
    
    const intP = intersectPoint({x: kathxm, y: kathym}, angle, {x: hypSidePoints.x1, y: hypSidePoints.y1}, {x: hypSidePoints.x2, y: hypSidePoints.y2})
    sprite.tint = 0x0000ff
    sprite.width = 50
    sprite.height = 50
    sprite.x = intP.x
    sprite.y = intP.y
    wait(0)
    createClone()*/
  }

  function intersectPoint(
    p: { x: number; y: number },
    angle: number,
    a: { x: number; y: number },
    b: { x: number; y: number },
  ) {
    const dx1 = b.x - a.x
    const dy1 = b.y - a.y
    const dx2 = Math.cos(angle)
    const dy2 = Math.sin(angle)

    const det = dx2 * dy1 - dy2 * dx1
    if (Math.abs(det) < 1e-10) {
      console.log("Geraden parallel")
      Game.stop() // kein Schnittpunkt
    }

    // Parameter s entlang Gerade vom Punkt P
    const s = ((a.x - p.x) * dy1 - (a.y - p.y) * dx1) / det

    // Schnittpunkt
    const ix = p.x + s * dx2
    const iy = p.y + s * dy2

    return { x: ix, y: iy }
  }

  /*
  fillTrianglePiece({x: x1, y: y1}, {x:x2,y: y2}, {x:x3, y:y3}, true, length_p1p2)
  wait(ft)
  fillTrianglePiece({x: x2, y:y2}, {x: x3, y:y3}, {x: x1, y:y1}, false, length_p2p3) //HIER FALSCH
  wait(ft)
  fillTrianglePiece({x: x3, y:y3}, {x: x1, y:y1}, {x: x2,y: y2}, true, length_p3p1)
  wait(ft)*/

  /*
  const avgHeight = averageTriangleHeight(x1, y1, x2, y2, x3, y3)
  console.log(avgHeight)
  const ySize = avgHeight / 4
  sprite.width = distance({ x: x1, y: y1 }, { x: x2, y: y2 }) * 0.9 * xPixelSize
  sprite.rotation = angleBetween({ x: x1, y: y1 }, { x: x2, y: y2 })
  sprite.x = (x1 + x2) / 2
  sprite.y = (y1 + y2) / 2
  sprite.height = ySize * yPixelSize
  sprite.move(ySize / 2)
  sprite.rotation -= 90
  createClone()
  wait(ft)
  sprite.width = distance({ x: x2, y: y2 }, { x: x3, y: y3 }) * 0.9 * xPixelSize
  sprite.rotation = angleBetween({ x: x2, y: y2 }, { x: x3, y: y3 })
  sprite.x = (x2 + x3) / 2
  sprite.y = (y2 + y3) / 2
  sprite.height = ySize * yPixelSize
  sprite.move(ySize / 2)
  sprite.rotation -= 90
  createClone()
  wait(ft)
  sprite.width = distance({ x: x3, y: y3 }, { x: x1, y: y1 }) * 0.9 * xPixelSize
  sprite.rotation = angleBetween({ x: x3, y: y3 }, { x: x1, y: y1 })
  sprite.x = (x3 + x1) / 2
  sprite.y = (y3 + y1) / 2
  sprite.height = ySize * yPixelSize
  sprite.move(ySize / 2)
  sprite.rotation -= 90
  createClone()*/

  //drawLine(x1, y1, triangleDef.x, triangleDef.y, 10)
  /*wait(ft * 100)
  const triangleDef = calcMaxTriangleSize(
    p1AngleToCenter,
    x1,
    y1,
    x2,
    y2,
    x3,
    y3,
  )
  sprite.width = xPixelSize * 5
  //sprite.height = triangleDef.height
  console.log(triangleDef)
  sprite.x = x1 + triangleDef.x
  sprite.y = y1 - triangleDef.y
  sprite.rotation = p1AngleToCenter
  createClone()
  wait(ft)
  wait(10000)
  sprite.height = xPixelSize * 100
  sprite.width = xPixelSize * 100

  sprite.x = x1
  sprite.y = y1*/
}



function intersectPointAngleLine(
  px: number,
  py: number,
  angle: number,
  ax: number,
  ay: number,
  bx: number,
  by: number,
) {
  const m1 = Math.tan(angle) // Steigung der ersten Geraden
  const m2 = (by - ay) / (bx - ax) // Steigung der anderen Geraden

  if (m1 === m2) {
    console.log("intersectPointAngleLine error!", m1, m2)
    Game.stop()
  } // parallele Geraden

  const b1 = py - m1 * px
  const b2 = ay - m2 * ax

  const x = (b2 - b1) / (m1 - m2)
  const y = m1 * x + b1

  return { x, y }
}

function calcMaxTriangleSize(
  thisAngle: number,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  const footVecP2 = footOfPerpendicularAngle(x1, y1, x2, y2, thisAngle)
  const footVecP3 = footOfPerpendicularAngle(x1, y1, x3, y3, thisAngle)
  const footVecP2Hypot = distance(
    { x: x1, y: y1 },
    { x: footVecP2.x, y: footVecP2.y },
  )
  const footVecP3Hypot = distance(
    { x: x1, y: y1 },
    { x: footVecP3.x, y: footVecP3.y },
  )

  let intersection

  let shortestVec = { x: 0, y: 0 }
  let shortestVecPos = { x: 0, y: 0 }
  if (footVecP2Hypot < footVecP3Hypot) {
    shortestVec = footVecP2
    shortestVecPos = { x: x2, y: y2 }
    intersection = getIntersectionPoint(
      thisAngle,
      footVecP2.x,
      footVecP2.y,
      x1,
      y1,
      x3,
      y3,
    )
  } else {
    shortestVec = footVecP3
    shortestVecPos = { x: x3, y: y3 }
    intersection = getIntersectionPoint(
      thisAngle,
      footVecP3.x,
      footVecP3.y,
      x1,
      y1,
      x2,
      y2,
    )
  }

  const f1 = distance(
    { x: shortestVecPos.x, y: shortestVecPos.y },
    { x: shortestVec.x, y: shortestVec.y },
  )
  const f2 = Math.hypot(intersection.x, intersection.y)

  return {
    x: shortestVec.x,
    y: shortestVec.y,
    f: f1 < f2 ? f1 : f2,
    l: distance({ x: x1, y: y1 }, { x: shortestVec.x, y: shortestVec.y }),
    xi: intersection.x,
    yi: intersection.y,
  }
}

function getIntersectionPoint(
  angle: number,
  sx: number,
  sy: number,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
): { x: number; y: number } {
  const vx = Math.cos(angle)
  const vy = Math.sin(angle)

  // Richtungsvektor der Linie x1,y1 -> x2,y2
  const dx = x2 - x1
  const dy = y2 - y1

  // Determinante prüfen
  const det = vx * dy - vy * dx
  if (Math.abs(det) < 1e-10) {
    console.log("ERROR INTERSECTION POINT!!!!")
    return { x: 1000, y: 1000 }
  } // parallel

  // Parameter t entlang der Geraden sx,sy
  const t = ((x1 - sx) * dy - (y1 - sy) * dx) / det

  // Schnittpunkt berechnen
  const ix = sx + t * vx
  const iy = sy + t * vy

  return { x: ix, y: iy }
}

function footOfPerpendicularAngle(
  sx: number,
  sy: number,
  px: number,
  py: number,
  angle: number,
): float2 {
  const vx = Math.sin(angle)
  const vy = Math.cos(angle)
  const dx = px - sx
  const dy = py - sy
  const s = (dx * vx + dy * vy) / (vx * vx + vy * vy)
  return {
    x: sx + s * vx,
    y: sy + s * vy,
  }
}

function angleToCentroid(sx: number, sy: number, ex: number, ey: number) {
  const dx = ex - sx
  const dy = ey - sy
  return Math.atan2(dx, dy) // Winkel im Bogenmaß
}

function centroid(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  return {
    x: (x1 + x2 + x3) / 3,
    y: (y1 + y2 + y3) / 3,
  }
}

function drawLine(x1: number, y1: number, x2: number, y2: number, t: number) {
  const p1 = { x: x1, y: y1 }
  const p2 = { x: x2, y: y2 }

  sprite.x = (p1.x + p2.x) / 2
  sprite.y = (p1.y + p2.y) / 2
  sprite.rotation = angleBetween(p1, p2)
  sprite.height = distance(p1, p2) * yPixelSize
  sprite.width = xPixelSize * t
  createClone()
}

function angleBetween(p1: float2, p2: float2): number {
  const dx = p2.x - p1.x
  const dy = p2.y - p1.y
  return Math.atan2(dx, dy)
}

function distance(p1: float2, p2: float2): number {
  const dx = p2.x - p1.x
  const dy = p2.y - p1.y
  return Math.sqrt(dx * dx + dy * dy)
}

/*
function DrawQuadrilateral(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
  x4: number,
  y4: number,
) {
  drawLine(x1, y1, x2, y2) // Seite 1
  drawLine(x2, y2, x3, y3) // Seite 2
  drawLine(x3, y3, x4, y4) // Seite 3
  drawLine(x4, y4, x1, y1) // Seite 4
  DrawTriangle(x1, y1, x2, y2, x3, y3)
  DrawTriangle(x1, y1, x3, y3, x4, y4)
}

// Beispiel: DrawTriangle-Funktion mit Sprite
function DrawTriangle(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  // Berechne Bounding-Box für das Sprite
  const minX = Math.min(x1, x2, x3)
  const minY = Math.min(y1, y2, y3)
  const maxX = Math.max(x1, x2, x3)
  const maxY = Math.max(y1, y2, y3)

  sprite.x = minX
  sprite.y = minY
  sprite.width = maxX - minX
  sprite.height = maxY - minY
  sprite.visible = true
  createClone()
  // Hier würdest du noch die Textur-UVs anpassen, falls nötig
}*/


//NEWEST
