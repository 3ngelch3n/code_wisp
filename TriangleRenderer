type float2 = { x: number; y: number }
//sprite.tint = 0x00ffff
sprite.y = 0
sprite.x = 0
const xPixelSize = 2650 / Game.width
const yPixelSize = 1880 / Game.height
//sprite.width = xPixelSize * Game.width
//sprite.height = yPixelSize * Game.height
sprite.visible = true

//drawTriangle(-120, -160, 20, 130, 220, 0)
//drawTriangle(0, 0, 100, 200, 250, -100)
//DrawQuadrilateral(0, 0, 300, 50, 200, 100, 0, 150)
//drawLine(0,0,-150,120)

onCloneStart(function (clone) {
  onMessage("deleteAllClones", function (data) {
    console.log("DELTE")
    clone.delete()
  })
})

onMessage("drawFrame", function (data) {
  const xOff = 0//Math.random(-100, 100)
  const yOff = 0//Math.random(-100, 100)
  /*drawTriangle(
    0 + xOff,
    0 + yOff,
    100 + xOff,
    200 + yOff,
    250 + xOff,
    -100 + yOff,
  )*/
  /*const x1 = Math.random(-360, -10)
  const y1 = Math.random(-240, -10)
  const x2 = Math.random(-360, -10)
  const y2 = Math.random(10, 240)
  const x3 = Math.random(10, 360)
  const y3 = Math.random(-240, 240)
  drawTriangle(
    x1 + xOff,
    y1 + yOff,
    x2 + xOff,
    y2 + yOff,
    x3 + yOff,
    y3 + yOff,
  )
  console.log("l:", x1 + xOff,
    y1 + yOff,
    x2 + xOff,
    y2 + yOff,
    x3 + yOff,
    y3 + yOff,)*/
  drawTriangle(
    -103,
    -212,
    -117,
    180,
    23,
    -140,
  )
})
sendMessage("drawFrame")
let ft = 1
forever(function () {
  if (Keyboard.keyHeld(Key.A)) {
    ft = 20
  }else {
    ft = 1
  }
  //sendMessage("deleteAllClones")
  //sendMessage("drawFrame")
  //wait(2)
})

function drawTriangle(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  
  sprite.layer = 1
  //sprite.tint = 0x00aaff
  sprite.setCostume("square")
  wait(ft)
  drawLine(x1, y1, x2, y2, 3)
  wait(ft)
  drawLine(x2, y2, x3, y3, 3)
  wait(ft)
  drawLine(x1, y1, x3, y3, 3)
  wait(ft)
  sprite.tint = 0x0044ff
  //sprite.setCostume("triangle")
  const center = centroid(x1, y1, x2, y2, x3, y3)
  sprite.x = center.x
  sprite.y = center.y
  sprite.width = xPixelSize * 5
  sprite.height = yPixelSize * 5
  createClone()
  wait(ft)
  sprite.width = xPixelSize * 3
  sprite.height = yPixelSize * 800
  const p1AngleToCenter = angleToCentroid(x1, y1, center.x, center.y)
  sprite.x = x1
  sprite.y = y1
  sprite.rotation = p1AngleToCenter
  createClone()
  wait(ft)
  const p2AngleToCenter = angleToCentroid(x2, y2, center.x, center.y)
  sprite.x = x2
  sprite.y = y2
  sprite.rotation = p2AngleToCenter
  createClone()
  wait(ft)
  const p3AngleToCenter = angleToCentroid(x3, y3, center.x, center.y)
  sprite.x = x3
  sprite.y = y3
  sprite.rotation = p3AngleToCenter
  createClone()
  wait(ft)
  sprite.tint = 0xff0000
  sprite.x = x2
  sprite.y = y2
  sprite.rotation = p1AngleToCenter + 90
  createClone()
  wait(ft)
  sprite.x = x3
  sprite.y = y3
  sprite.rotation = p1AngleToCenter + 90
  createClone()
  sprite.layer = -1

  
  sprite.tint = 0xff0000
  sprite.layer = 0
  //const center = centroid(x1, y1, x2, y2, x3, y3)
  //const p1AngleToCenter = angleToCentroid(x1, y1, center.x, center.y)
  //const p2AngleToCenter = angleToCentroid(x2, y2, center.x, center.y)
  //const p3AngleToCenter = angleToCentroid(x3, y3, center.x, center.y)
  sprite.setCostume("triangle")
  wait(ft)
  const triangleDefp1 = calcMaxTriangleSize(
    p1AngleToCenter,
    x1,
    y1,
    x2,
    y2,
    x3,
    y3,
  )
  sprite.x = (x1 + triangleDefp1.x) / 2
  sprite.y = (y1 + triangleDefp1.y) / 2
  sprite.rotation = p1AngleToCenter
  sprite.height = triangleDefp1.l * yPixelSize
  sprite.width = triangleDefp1.f * xPixelSize
  createClone()
  wait(ft)
  const triangleDefp2 = calcMaxTriangleSize(
    p2AngleToCenter,
    x2,
    y2,
    x3,
    y3,
    x1,
    y1,
  )
  sprite.x = (x2 + triangleDefp2.x) / 2
  sprite.y = (y2 + triangleDefp2.y) / 2
  sprite.rotation = p2AngleToCenter
  sprite.height = triangleDefp2.l * yPixelSize
  sprite.width = triangleDefp2.f * xPixelSize
  createClone()
  wait(ft)
  const triangleDefp3 = calcMaxTriangleSize(
    p3AngleToCenter,
    x3,
    y3,
    x1,
    y1,
    x2,
    y2,
  )
  sprite.x = (x3 + triangleDefp3.x) / 2
  sprite.y = (y3 + triangleDefp3.y) / 2
  sprite.rotation = p3AngleToCenter
  sprite.height = triangleDefp3.l * yPixelSize
  sprite.width = triangleDefp3.f * xPixelSize
  createClone()
  //sprite.tint = 0x00ff00
  sprite.layer = 0
  wait(ft)

  const avgHeight = averageTriangleHeight(x1, y1, x2, y2, x3, y3)
  console.log(avgHeight)
  const ySize = avgHeight / 4
  sprite.width = distance({ x: x1, y: y1 }, { x: x2, y: y2 }) * 0.9 * xPixelSize
  sprite.rotation = angleBetween({ x: x1, y: y1 }, { x: x2, y: y2 })
  sprite.x = (x1 + x2) / 2
  sprite.y = (y1 + y2) / 2
  sprite.height = ySize * yPixelSize
  sprite.move(ySize / 2)
  sprite.rotation -= 90
  createClone()
  sprite.width = distance({ x: x2, y: y2 }, { x: x3, y: y3 }) * 0.9 * xPixelSize
  sprite.rotation = angleBetween({ x: x2, y: y2 }, { x: x3, y: y3 })
  sprite.x = (x2 + x3) / 2
  sprite.y = (y2 + y3) / 2
  sprite.height = ySize * yPixelSize
  sprite.move(ySize / 2)
  sprite.rotation -= 90
  createClone()
  sprite.width = distance({ x: x3, y: y3 }, { x: x1, y: y1 }) * 0.9 * xPixelSize
  sprite.rotation = angleBetween({ x: x3, y: y3 }, { x: x1, y: y1 })
  sprite.x = (x3 + x1) / 2
  sprite.y = (y3 + y1) / 2
  sprite.height = ySize * yPixelSize
  sprite.move(ySize / 2)
  sprite.rotation -= 90
  createClone()

  //drawLine(x1, y1, triangleDef.x, triangleDef.y, 10)
  /*wait(ft * 100)
  const triangleDef = calcMaxTriangleSize(
    p1AngleToCenter,
    x1,
    y1,
    x2,
    y2,
    x3,
    y3,
  )
  sprite.width = xPixelSize * 5
  //sprite.height = triangleDef.height
  console.log(triangleDef)
  sprite.x = x1 + triangleDef.x
  sprite.y = y1 - triangleDef.y
  sprite.rotation = p1AngleToCenter
  createClone()
  wait(ft)
  wait(10000)
  sprite.height = xPixelSize * 100
  sprite.width = xPixelSize * 100

  sprite.x = x1
  sprite.y = y1*/
}

function averageTriangleHeight(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
): number {
  // Abstand eines Punktes zu einer Linie
  function height(
    px: number,
    py: number,
    ax: number,
    ay: number,
    bx: number,
    by: number,
  ): number {
    return (
      Math.abs((by - ay) * px - (bx - ax) * py + bx * ay - by * ax) /
      Math.sqrt((by - ay) ** 2 + (bx - ax) ** 2)
    )
  }

  const hA = height(x1, y1, x2, y2, x3, y3) // Höhe von A auf BC
  const hB = height(x2, y2, x1, y1, x3, y3) // Höhe von B auf AC
  const hC = height(x3, y3, x1, y1, x2, y2) // Höhe von C auf AB

  return (hA + hB + hC) / 3 // Durchschnitt
}

function calcMaxTriangleSize(
  thisAngle: number,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  const footVecP2 = footOfPerpendicularAngle(x1, y1, x2, y2, thisAngle)
  const footVecP3 = footOfPerpendicularAngle(x1, y1, x3, y3, thisAngle)
  const footVecP2Hypot = distance(
    { x: x1, y: y1 },
    { x: footVecP2.x, y: footVecP2.y },
  )
  const footVecP3Hypot = distance(
    { x: x1, y: y1 },
    { x: footVecP3.x, y: footVecP3.y },
  )
  console.log(x1, y1, x2, y2, x3, y3, thisAngle, footVecP2, footVecP3)
  if (footVecP2Hypot < footVecP3Hypot) {
    return {
      x: footVecP2.x,
      y: footVecP2.y,
      f: distance({ x: x2, y: y2 }, { x: footVecP2.x, y: footVecP2.y }),
      l: distance({ x: x1, y: y1 }, { x: footVecP2.x, y: footVecP2.y }),
    }
  } else {
    return {
      x: footVecP3.x,
      y: footVecP3.y,
      f: Math.hypot(footVecP3.x - x3, footVecP3.y - y3),
      l: distance({ x: x1, y: y1 }, { x: footVecP3.x, y: footVecP3.y }),
    }
  }
}

function footOfPerpendicularAngle(
  sx: number,
  sy: number,
  px: number,
  py: number,
  angle: number,
): float2 {
  const vx = Math.sin(angle)
  const vy = Math.cos(angle)
  const dx = px - sx
  const dy = py - sy
  const s = (dx * vx + dy * vy) / (vx * vx + vy * vy)
  return {
    x: sx + s * vx,
    y: sy + s * vy,
  }
}

function angleToCentroid(sx: number, sy: number, ex: number, ey: number) {
  const dx = ex - sx
  const dy = ey - sy
  return Math.atan2(dx, dy) // Winkel im Bogenmaß
}

function centroid(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  return {
    x: (x1 + x2 + x3) / 3,
    y: (y1 + y2 + y3) / 3,
  }
}

function drawLine(x1: number, y1: number, x2: number, y2: number, t: number) {
  const p1 = { x: x1, y: y1 }
  const p2 = { x: x2, y: y2 }

  sprite.x = (p1.x + p2.x) / 2
  sprite.y = (p1.y + p2.y) / 2
  sprite.rotation = angleBetween(p1, p2)
  sprite.height = distance(p1, p2) * yPixelSize
  sprite.width = xPixelSize * t
  createClone()
}

function angleBetween(p1: float2, p2: float2): number {
  const dx = p2.x - p1.x
  const dy = p2.y - p1.y
  return Math.atan2(dx, dy)
}

function distance(p1: float2, p2: float2): number {
  const dx = p2.x - p1.x
  const dy = p2.y - p1.y
  return Math.sqrt(dx * dx + dy * dy)
}

/*
function DrawQuadrilateral(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
  x4: number,
  y4: number,
) {
  drawLine(x1, y1, x2, y2) // Seite 1
  drawLine(x2, y2, x3, y3) // Seite 2
  drawLine(x3, y3, x4, y4) // Seite 3
  drawLine(x4, y4, x1, y1) // Seite 4
  DrawTriangle(x1, y1, x2, y2, x3, y3)
  DrawTriangle(x1, y1, x3, y3, x4, y4)
}

// Beispiel: DrawTriangle-Funktion mit Sprite
function DrawTriangle(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  // Berechne Bounding-Box für das Sprite
  const minX = Math.min(x1, x2, x3)
  const minY = Math.min(y1, y2, y3)
  const maxX = Math.max(x1, x2, x3)
  const maxY = Math.max(y1, y2, y3)

  sprite.x = minX
  sprite.y = minY
  sprite.width = maxX - minX
  sprite.height = maxY - minY
  sprite.visible = true
  createClone()
  // Hier würdest du noch die Textur-UVs anpassen, falls nötig
}*/
