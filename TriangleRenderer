const xPixelSize = 2650 / 8 / Game.width
const yPixelSize = 1880 / 8 / Game.height
const triangleM = 64 / 55
sprite.visible = true
globals.setCloneSprite = "square_yh"

onCloneStart(function (clone) {
  clone.setCostume(globals.setCloneSprite)
  onMessage("deleteAllClones", function (data) {
    clone.delete()
  })
})

onMessage("drawFrame", function (data) {
  function randomBetween(min: number, max: number) {
    return Math.random(min, max)
  }

  function rotatePoint(
    px: number,
    py: number,
    cx: number,
    cy: number,
    angle: number,
  ) {
    const s = Math.sin(angle)
    const c = Math.cos(angle)
    const dx = px - cx
    const dy = py - cy
    return {
      x: cx + dx * c - dy * s,
      y: cy + dx * s + dy * c,
    }
  }

  function randomTriangle() {
    drawTriangle(
      Math.random(-320, 320),
      Math.random(-240, 240),
      Math.random(-320, 320),
      Math.random(-240, 240),
      Math.random(-320, 320),
      Math.random(-240, 240),
      0x00ff00,
      false,
      0x00aaff,
      2,
    )
  }
  for (let i = 0; i < drawAmount; i++) {
    randomTriangle()
  }
})

let lastTime = performance.now()
let frames = 0
let fps = 0
let avgFps = 0
const samples: number[] = []
const maxSamples = 60

function measureFPS() {
  frames++
  const now = performance.now()
  const diff = now - lastTime

  if (diff >= 1000) { 
    fps = Math.round((frames * 1000) / diff)

    samples.push(fps)
    if (samples.length > maxSamples) {
      samples.shift()
    }

    avgFps = Math.round(samples.reduce((a, b) => a + b, 0) / samples.length)

    frames = 0
    lastTime = now
  }

  return { fps, avgFps }
}

const fpsTxt = Game.createText('-')
fpsTxt.x = -300
fpsTxt.y = 220
fpsTxt.style.align = "left"
const drawAmount = 50

forever(function () {
  sendMessage("deleteAllClones")
  sendMessage("drawFrame")
  fpsTxt.text = measureFPS().avgFps + ""
})

function drawTriangle(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
  color: number,
  outline: boolean = false,
  outline_color: number = 0x11ff55,
  outline_thickness: number = 4,
) {

  const orientation = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)
  if (orientation > 0) {
    const tempX = x2
    x2 = x3
    x3 = tempX

    const tempY = y2
    y2 = y3
    y3 = tempY
  }

  if (outline) {
    sprite.tint = outline_color
    globals.setCloneSprite = "square_yh"

    drawLine(x1, y1, x2, y2, outline_thickness)
    drawLine(x2, y2, x3, y3, outline_thickness)
    drawLine(x1, y1, x3, y3, outline_thickness)
  }
  sprite.tint = color

  //---TRIANGLE TYPE FILTER
  const triVals = analyzeTriangle(x1, y1, x2, y2, x3, y3)
  const p1p2_l = triVals.length_p1p2
  const p2p3_l = triVals.length_p2p3
  const p3p1_l = triVals.length_p3p1
  const hypSideP = triVals.hypSideP
  const ahypAngle = triVals.ahypAngle
  const kathl = triVals.kathl1
  const kathl2 = triVals.kathl2
  const diffT = triVals.diff

  const tolerance = (p1p2_l + p2p3_l + p3p1_l) / 3 / 100

  //  Equilateral [1 triangle]
  if (
    (Math.abs(p1p2_l - p2p3_l) <= tolerance &&
      Math.abs(p2p3_l - p3p1_l) <= tolerance) ||
    Math.abs(p1p2_l - p2p3_l) <= tolerance ||
    Math.abs(p2p3_l - p3p1_l) <= tolerance ||
    Math.abs(p3p1_l - p1p2_l) <= tolerance
  ) {
    trianglePieceHyp(diffT)
  }
  //  Right angled [1 h-triangle]
  else {
    const rightPoint = getRightAngleVertex(x1, y1, x2, y2, x3, y3)
    if (rightPoint) {
      drawTrianglePartRA(hypSideP, kathl, kathl2, ahypAngle)
    } else {
      // Any other triangle [2 h-triangle]
      const rightTriangles = splitTriangleIntoRightTriangles(
        hypSideP,
        ahypAngle,
      )
      const t = rightTriangles[0]
      const triVals1 = analyzeTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3)
      drawTrianglePartRA(
        triVals1.hypSideP,
        triVals1.kathl1,
        triVals1.kathl2,
        triVals1.ahypAngle,
      )
      const d = rightTriangles[1]
      const triVals2 = analyzeTriangle(d.x1, d.y1, d.x2, d.y2, d.x3, d.y3)
      drawTrianglePartRA(
        triVals2.hypSideP,
        triVals2.kathl1,
        triVals2.kathl2,
        triVals2.ahypAngle,
      )
    }
  }

  function splitTriangleIntoRightTriangles(
    hypSidePoints: {
      x1: number
      y1: number
      x2: number
      y2: number
      x3: number
      y3: number
    },
    p1angle: number,
  ) {
    const A = { x: hypSidePoints.x1, y: hypSidePoints.y1 }
    const B = { x: hypSidePoints.x2, y: hypSidePoints.y2 }
    const C = { x: hypSidePoints.x3, y: hypSidePoints.y3 }
    const an = angleBetween(A, B)
    const g = intersectPoint(C, an, A, B)

    return [
      { x1: B.x, y1: B.y, x2: C.x, y2: C.y, x3: g.x, y3: g.y },
      { x1: A.x, y1: A.y, x2: g.x, y2: g.y, x3: C.x, y3: C.y },
    ]
  }

  function drawTrianglePartRA(
    hypSidePoints: { x1: number; y1: number; x2: number; y2: number },
    kathl: { x1: number; y1: number; x2: number; y2: number },
    kathl2: { x1: number; y1: number; x2: number; y2: number },
    aHypAngle: number,
  ) {
    const h1 = { x: hypSidePoints.x1, y: hypSidePoints.y1 }
    const h2 = { x: hypSidePoints.x2, y: hypSidePoints.y2 }

    const k1 = { x: kathl.x1, y: kathl.y1 }
    const k2 = { x: kathl.x2, y: kathl.y2 }

    const kk1 = { x: kathl2.x1, y: kathl2.y1 }
    const kk2 = { x: kathl2.x2, y: kathl2.y2 }

    const baseLength = distance(kk1, kk2)
    const height = distance(k1, k2)
    const midX = (k1.x + k2.x) / 2
    const midY = (k1.y + k2.y) / 2

    const rightPoint = {
      x:
        hypSidePoints.x1 !== kathl2.x1 || hypSidePoints.y1 !== kathl2.y1
          ? kathl2.x1
          : kathl2.x2,
      y:
        hypSidePoints.x1 !== kathl2.x1 || hypSidePoints.y1 !== kathl2.y1
          ? kathl2.y1
          : kathl2.y2,
    }
    const vx = k2.x - k1.x
    const vy = k2.y - k1.y
    const wx = rightPoint.x - k1.x
    const wy = rightPoint.y - k1.y

    const cross = vx * wy - vy * wx
    const rot = cross < 0 ? 90 : -90

    sprite.rotation = angleBetween(k1, k2) + rot
    sprite.x = midX
    sprite.y = midY
    sprite.move(-height / 13)
    sprite.rotation += 90
    sprite.width = baseLength * xPixelSize * 1.9
    sprite.height = height * yPixelSize * triangleM
    if (rot == 90) globals.setCloneSprite = "triangle_yh_l"
    else globals.setCloneSprite = "triangle_yh_r"
    createClone()
  }

  function trianglePieceHyp(kathl2: {
    x1: number
    y1: number
    x2: number
    y2: number
    x3: number
    y3: number
  }) {
    const p1 = { x: kathl2.x1, y: kathl2.y1 }
    const p2 = { x: kathl2.x2, y: kathl2.y2 }
    const p3 = { x: kathl2.x3, y: kathl2.y3 }
    const hypAngle = angleBetween(p1, p2)
    const p1p2xM = (p1.x + p2.x) / 2
    const p1p2yM = (p1.y + p2.y) / 2
    sprite.x = p1p2xM
    sprite.y = p1p2yM
    sprite.rotation = hypAngle - 180
    const height = distance({ x: p1p2xM, y: p1p2yM }, p3) * triangleM
    sprite.move(-(height / 2) / triangleM)
    sprite.rotation += 90
    sprite.width = distance(p1, p2) * 0.91 * xPixelSize
    sprite.height = height * yPixelSize
    globals.setCloneSprite = "triangle_yh"
    createClone()
  }

  function analyzeTriangle(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    x3: number,
    y3: number,
  ) {
    const length_p1p2 = distance({ x: x1, y: y1 }, { x: x2, y: y2 })
    const length_p2p3 = distance({ x: x2, y: y2 }, { x: x3, y: y3 })
    const length_p3p1 = distance({ x: x3, y: y3 }, { x: x1, y: y1 })

    let hypSideP = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }
    let kathl1 = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }
    let kathl2 = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }
    let rightPoint = { x: 0, y: 0 }
    let ahypAngle = 90
    let diff = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }

    if (length_p1p2 >= length_p2p3 && length_p1p2 >= length_p3p1) {
      hypSideP = { x1, y1, x2, y2, x3, y3 }
      rightPoint = { x: x3, y: y3 }
      const k1 = { x1: x2, y1: y2, x2: x3, y2: y3, x3, y3 }
      const k2 = { x1: x3, y1: y3, x2: x1, y2: y1, x3, y3 }
      kathl1 = length_p2p3 >= length_p3p1 ? k1 : k2
      kathl2 = length_p2p3 >= length_p3p1 ? k2 : k1
    } else if (length_p2p3 >= length_p1p2 && length_p2p3 >= length_p3p1) {
      hypSideP = { x1: x2, y1: y2, x2: x3, y2: y3, x3: x1, y3: y1 }
      rightPoint = { x: x1, y: y1 }
      const k1 = { x1: x1, y1: y1, x2: x2, y2: y2, x3, y3 }
      const k2 = { x1: x3, y1: y3, x2: x1, y2: y1, x3, y3 }
      kathl1 = length_p1p2 >= length_p3p1 ? k1 : k2
      kathl2 = length_p1p2 >= length_p3p1 ? k2 : k1
    } else {
      hypSideP = { x1: x3, y1: y3, x2: x1, y2: y1, x3: x2, y3: y2 }
      rightPoint = { x: x2, y: y2 }
      const k1 = { x1: x1, y1: y1, x2: x2, y2: y2, x3, y3 }
      const k2 = { x1: x2, y1: y2, x2: x3, y2: y3, x3, y3 }
      kathl1 = length_p1p2 >= length_p2p3 ? k1 : k2
      kathl2 = length_p1p2 >= length_p2p3 ? k2 : k1
    }

    let sideLengths = [
      { len: length_p1p2, pts: { x1, y1, x2, y2, x3, y3 } },
      {
        len: length_p2p3,
        pts: { x1: x2, y1: y2, x2: x3, y2: y3, x3: x1, y3: y1 },
      },
      {
        len: length_p3p1,
        pts: { x1: x3, y1: y3, x2: x1, y2: y1, x3: x2, y3: y2 },
      },
    ]

    sideLengths.sort((a, b) => a.len - b.len)

    const diffSide = (() => {
      const d1 = Math.abs(sideLengths[1].len - sideLengths[0].len)
      const d2 = Math.abs(sideLengths[2].len - sideLengths[1].len)
      const d3 = Math.abs(sideLengths[2].len - sideLengths[0].len)

      if (d1 < d2 && d1 < d3) return sideLengths[2].pts
      if (d2 < d1 && d2 < d3) return sideLengths[0].pts
      return sideLengths[1].pts
    })()

    diff = diffSide

    return {
      hypSideP,
      kathl1,
      kathl2,
      rightPoint,
      ahypAngle,
      diff,
      length_p1p2,
      length_p2p3,
      length_p3p1,
    }
  }

  function intersectPoint(
    p: { x: number; y: number },
    angle: number,
    a: { x: number; y: number },
    b: { x: number; y: number },
  ) {
    angle += 90
    const dx1 = b.x - a.x
    const dy1 = b.y - a.y
    const dx2 = Math.sin(angle)
    const dy2 = Math.cos(angle)

    const det = dx2 * dy1 - dy2 * dx1
    if (Math.abs(det) < 1e-10) {
      console.log("PARALLEL")
      Game.stop()
    }

    const s = ((a.x - p.x) * dy1 - (a.y - p.y) * dx1) / det

    const ix = p.x + s * dx2
    const iy = p.y + s * dy2

    return { x: ix, y: iy }
  }

  function getRightAngleVertex(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    x3: number,
    y3: number,
    toleranceT: number = 1e-6,
  ): { x: number; y: number } | null {
    const dot1 = (x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1)
    if (Math.abs(dot1) < toleranceT) return { x: x1, y: y1 }

    const dot2 = (x1 - x2) * (x3 - x2) + (y1 - y2) * (y3 - y2)
    if (Math.abs(dot2) < toleranceT) return { x: x2, y: y2 }

    const dot3 = (x1 - x3) * (x2 - x3) + (y1 - y3) * (y2 - y3)
    if (Math.abs(dot3) < toleranceT) return { x: x3, y: y3 }

    return null
  }
}

function drawLine(x1: number, y1: number, x2: number, y2: number, t: number) {
  const p1 = { x: x1, y: y1 }
  const p2 = { x: x2, y: y2 }

  sprite.x = (p1.x + p2.x) / 2
  sprite.y = (p1.y + p2.y) / 2
  sprite.rotation = angleBetween(p1, p2)
  sprite.height = distance(p1, p2) * yPixelSize
  sprite.width = xPixelSize * t
  globals.setCloneSprite = "square_yh"
  createClone()
}

function drawDot(x1: number, y1: number, t: number, c: number) {
  const p1 = { x: x1, y: y1 }
  sprite.tint = c
  sprite.x = x1
  sprite.y = y1
  sprite.height = t * yPixelSize
  sprite.width = xPixelSize * t
  globals.setCloneSprite = "square_yh"
  createClone()
}

function angleBetween(p1: any, p2: any): number {
  const dx = p2.x - p1.x
  const dy = p2.y - p1.y
  return Math.atan2(dx, dy)
}

function distance(p1: any, p2: any): number {
  const dx = p2.x - p1.x
  const dy = p2.y - p1.y
  return Math.sqrt(dx * dx + dy * dy)
}
//FULLY WORKING with 50 draw calls avg 30 fps
