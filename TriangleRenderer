const xPixelSize = 2650 / 8 / Game.width
const yPixelSize = 1880 / 8 / Game.height
const triangleM = 64 / 55
sprite.visible = false
globals.setCloneSprite = "square_yh"
const tolerance = 0.5

onCloneStart(function (clone) {
  clone.visible = true
  clone.setCostume(globals.setCloneSprite)
  onMessage("deleteAllClones", function (data) {
    clone.delete()
  })
})

//drawTriangle(-120, -160, 20, 130, 220, 0, 0x00ff00) ///HIER FEHLT UNTEN EIN GROßeS STÜCK
//drawTriangle(0, 0, 100, 200, 250, -100, 0xff0000) //HIER PERFEKT
//drawTriangle(100, 200, 0, 0, 250, -100, 0xff0000) //HIER PERFEKT

onMessage("drawFrame", function (data) {

  function randomBetween(min: number, max: number) {
    return Math.random(min, max)
  }

  function rotatePoint(px: number, py: number, cx: number, cy: number, angle: number) {
    const s = Math.sin(angle)
    const c = Math.cos(angle)
    const dx = px - cx
    const dy = py - cy
    return {
      x: cx + dx * c - dy * s,
      y: cy + dx * s + dy * c
    }
  }

  function randomTriangle() {
    const typee = Math.floor(Math.random(0, 3))
    const rot = randomBetween(0, 360)
    console.log(typee)
    let tri = { x1:0, y1:0, x2:0, y2:0, x3:0, y3:0 }
    console.log("typ", typee)
    if (typee === 0) {
      const x = randomBetween(-200, 200)
      const y = randomBetween(-100, 100)
      const size = randomBetween(50, 150)
      tri = {
        x1: x,
        y1: y,
        x2: x + size,
        y2: y,
        x3: x + size / 2,
        y3: y + size * 0.866
      }
    }

    if (typee === 1) {
      const x = randomBetween(-200, 200)
      const y = randomBetween(-100, 100)
      const base = randomBetween(60, 160)
      const height = randomBetween(60, 160)
      tri = {
        x1: x,
        y1: y,
        x2: x + base,
        y2: y,
        x3: x + base/2,
        y3: y + height
      }
    }

    if (typee === 2) {
      const x = randomBetween(-200, 200)
      const y = randomBetween(-100, 100)
      const a = randomBetween(50, 150)
      const b = randomBetween(50, 150)
      tri = {
        x1: x,
        y1: y,
        x2: x + a,
        y2: y,
        x3: x,
        y3: y + b
      }
    }
    console.log("tri", tri)

    // Mittelpunkt für Rotation
    const cx = (tri.x1 + tri.x2 + tri.x3)/3
    const cy = (tri.y1 + tri.y2 + tri.y3)/3
    
    const r1 = rotatePoint(Math.floor(tri.x1), Math.floor(tri.y1), cx, cy, rot)
    const r2 = rotatePoint(Math.floor(tri.x2), Math.floor(tri.y2), cx, cy, rot)
    const r3 = rotatePoint(Math.floor(tri.x3), Math.floor(tri.y3), cx, cy, rot)
    console.log("rrr", r1, r2, r3)
    drawTriangle(r1.x, r1.y, r2.x, r2.y, r3.x, r3.y, 0xff0000, true, 0x00aaff, 2)
  }

  //randomTriangle()
drawTriangle(
  -102.44415048969915, -72.53800410989464, // x1, y1
  -8.582681553053867, -67.43656813017546,  // x2, y2
  -59.909334259219634, 10.893341367925252, // x3, y3
  0xff0000,   // color
  true,       // outline
  0x00aaff,   // outline color
  4           // outline thickness
)




})



sendMessage("drawFrame")
forever(function () {
  sendMessage("deleteAllClones")
  sendMessage("drawFrame")
  wait(0.5)
})

function drawTriangle(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
  color: number,
  outline: boolean = false,
  outline_color: number = 0x11ff55,
  outline_thickness: number = 4,
) {
  /*let result = normalizeTriangle(x1, y1, x2, y2, x3, y3)
  ;(x1 = result.x1), (y1 = result.y1)
  ;(x2 = result.x2), (y2 = result.y2)
  ;(x3 = result.x3), (y3 = result.y3)*/

  const orientation = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)
  console.log(orientation)
  console.log(x1, y1, x2, y2, x3, y3)
  if (orientation > 0) {
    const tempX = x2
    x2 = x3
    x3 = tempX

    const tempY = y2
    y2 = y3
    y3 = tempY
  }
  console.log(x1, y1, x2, y2, x3, y3)

  if (outline) {
    sprite.tint = outline_color
    globals.setCloneSprite = "square_yh"
    //!wait(0)
    drawLine(x1, y1, x2, y2, outline_thickness)
    drawLine(x2, y2, x3, y3, outline_thickness)
    drawLine(x1, y1, x3, y3, outline_thickness)
  }
  sprite.tint = color
  //!wait(0)

  //---TRIANGLE TYPE FILTER
  const triVals = analyzeTriangle(x1, y1, x2, y2, x3, y3)
  const p1p2_l = triVals.length_p1p2
  const p2p3_l = triVals.length_p2p3
  const p3p1_l = triVals.length_p3p1
  const hypSideP = triVals.hypSideP
  const ahypAngle = triVals.ahypAngle
  const kathl = triVals.kathl1
  const kathl2 = triVals.kathl2
  const diffT = triVals.diff
  

  console.log("p",p1p2_l, p2p3_l, p3p1_l)
  
  //  Equilateral [1 triangle]
  if (Math.abs(p1p2_l - p2p3_l) <= tolerance && Math.abs(p2p3_l - p3p1_l) <= tolerance) {
    //drawTrianglePart(x1, y1, x2, y2, x3, y3)
    trianglePieceHyp(diffT)
    console.log("gleichseitig!") 
  } 
  //  Isosceles [1 triangle]
  else if (Math.abs(p1p2_l - p2p3_l) <= tolerance ||
    Math.abs(p2p3_l - p3p1_l) <= tolerance ||
    Math.abs(p3p1_l - p1p2_l) <= tolerance) {
    trianglePieceHyp(diffT)
    console.log("gleichschenklig!")
  }
  //  Right angled [1 h-triangle]
  else {
    const rightPoint = getRightAngleVertex(x1, y1, x2, y2, x3, y3)
    if (rightPoint) {
      drawTrianglePartRA(hypSideP, kathl, kathl2, ahypAngle)
      console.log("Das Dreieck ist rechtwinklig!")
    }
  }

  /*
  let ignoreHypS = false
  if (ahypAngle > 90) ignoreHypS = true

  if (!isHypSide(x1, y1, x2, y2, hypSideP)) {
    trianglePieceKath(x1, y1, x2, y2, x3, y3, hypSideP)
  }
  if (!isHypSide(x2, y2, x3, y3, hypSideP)) {
    trianglePieceKath(x2, y2, x3, y3, x1, y1, hypSideP)
  }
  if (!isHypSide(x3, y3, x1, y1, hypSideP)) {
    trianglePieceKath(x3, y3, x1, y1, x2, y2, hypSideP)
  }
  if (ignoreHypS) {
    //!wait(0)
    //sprite.setCostume("triangle_yh")
    trianglePieceHyp(hypSideP, anglePos.x, anglePos.y, ahypAngle)
  }
  globals.setCloneSprite = "square_yh"
  sprite.tint = 0x00ff00
  drawLine(hypSideP.x1, hypSideP.y1, hypSideP.x2, hypSideP.y2, 8)
  */
  function drawTrianglePart(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    x3: number,
    y3: number,
  ) {
    const p1 = { x: x1, y: y1 }
    const p2 = { x: x2, y: y2 }
    const p3 = { x: x3, y: y3 }

    const baseLength = distance(p1, p2)
    const height =
      (Math.abs((p2.y - p1.y) * (p3.x - p1.x) - (p2.x - p1.x) * (p3.y - p1.y)) /
        baseLength /
        55) *
      64
    const midX = (p1.x + p2.x) / 2
    const midY = (p1.y + p2.y) / 2

    sprite.rotation = angleBetween(p1, p2)
    sprite.x = midX
    sprite.y = midY
    sprite.move((-height / 2) * 0.87)
    sprite.rotation += 90

    sprite.width = baseLength * xPixelSize * 0.95
    sprite.height = height * yPixelSize
    globals.setCloneSprite = "triangle_yh"
    createClone()
  }

  function drawTrianglePartRA(
    hypSidePoints: { x1: number; y1: number; x2: number; y2: number },
    kathl: { x1: number; y1: number; x2: number; y2: number },
    kathl2: { x1: number; y1: number; x2: number; y2: number },
    aHypAngle: number,
  ) {
    const h1 = { x: hypSidePoints.x1, y: hypSidePoints.y1 }
    const h2 = { x: hypSidePoints.x2, y: hypSidePoints.y2 }

    const k1 = { x: kathl.x1, y: kathl.y1 }
    const k2 = { x: kathl.x2, y: kathl.y2 }

    const kk1 = { x: kathl2.x1, y: kathl2.y1 }
    const kk2 = { x: kathl2.x2, y: kathl2.y2 }

    const baseLength = distance(kk1, kk2)
    const height = distance(k1, k2)
    const midX = (k1.x + k2.x) / 2
    const midY = (k1.y + k2.y) / 2

    sprite.width = 5
    sprite.height = 5
    sprite.tint = 0x00ff00
    sprite.x = kk1.x
    sprite.y = kk1.y
    createClone()
    sprite.tint = 0x000fff
    sprite.x = kk2.x
    sprite.y = kk2.y
    createClone()

    const rightPoint = {
      x:
        hypSidePoints.x1 !== kathl2.x1 || hypSidePoints.y1 !== kathl2.y1
          ? kathl2.x1
          : kathl2.x2,
      y:
        hypSidePoints.x1 !== kathl2.x1 || hypSidePoints.y1 !== kathl2.y1
          ? kathl2.y1
          : kathl2.y2,
    }
    const vx = k2.x - k1.x
    const vy = k2.y - k1.y
    const wx = rightPoint.x - k1.x
    const wy = rightPoint.y - k1.y

    const cross = vx * wy - vy * wx
    const rot = cross < 0 ? 90 : -90

    console.log("a", cross)

    sprite.rotation = angleBetween(k1, k2) + rot
    sprite.x = midX
    sprite.y = midY
    sprite.move(-height / 13)
    sprite.rotation += 90
    sprite.width = baseLength * xPixelSize * 1.95
    sprite.height = height * yPixelSize * triangleM
    console.log("r", sprite.height, sprite.width, height, baseLength)
    if (rot == 90) globals.setCloneSprite = "triangle_yh_l"
    else globals.setCloneSprite = "triangle_yh_r"
    console.log(height)
    createClone()

    //createClone()
  }

  function trianglePieceKath(
    kath1x: number,
    kath1y: number,
    kath2x: number,
    kath2y: number,
    hypx: number,
    hypy: number,
    hypSidePoints: { x1: number; y1: number; x2: number; y2: number },
  ) {
    const k1 = { x: kath1x, y: kath1y }
    const k2 = { x: kath2x, y: kath2y }
    const kathxm = (kath1x + kath2x) / 2
    const kathym = (kath1y + kath2y) / 2
    const angle = angleBetween(k1, k2)
    const interP = intersectPoint(
      { x: kathxm, y: kathym },
      angle,
      { x: hypSidePoints.x1, y: hypSidePoints.y1 },
      { x: hypSidePoints.x2, y: hypSidePoints.y2 },
    )
    const dis =
      (distance({ x: kathxm, y: kathym }, { x: interP.x, y: interP.y }) / 55) *
      64
    sprite.width = distance(k1, k2) * xPixelSize * 0.95
    sprite.height = dis * yPixelSize
    sprite.rotation = angle
    sprite.x = kathxm
    sprite.y = kathym
    sprite.move((dis / 2) * 0.87)
    sprite.rotation -= 90
    globals.setCloneSprite = "triangle_yh"
    //!wait(0)
    createClone()
  }

  function trianglePieceHyp(
    kathl2: {
      x1: number
      y1: number
      x2: number
      y2: number
      x3: number
      y3: number
    }
  ) {
    const p1 = { x: kathl2.x1, y: kathl2.y1 }
    const p2 = { x: kathl2.x2, y: kathl2.y2 }
    const p3 = { x: kathl2.x3, y: kathl2.y3 }
    drawDot(p1.x, p1.y, 10, 0x00ff00)
    drawDot(p2.x, p2.y, 10, 0x0000ff)
    drawDot(p3.x, p3.y, 10, 0x005555)
    sprite.tint = 0xff0000
    const hypAngle = angleBetween(p1, p2)
    const p1p2xM = (p1.x + p2.x) / 2
    const p1p2yM = (p1.y + p2.y) / 2
    sprite.x = p1p2xM
    sprite.y = p1p2yM
    sprite.rotation = hypAngle - 180
    console.log(sprite.x, sprite.y)
    const height = distance({ x: p1p2xM, y: p1p2yM }, p3) * triangleM
    sprite.move(-(height / 2) / triangleM)
    console.log(sprite.x, sprite.y)
    sprite.rotation += 90
    sprite.width = distance(p1, p2) * 0.95 * xPixelSize
    sprite.height = height * yPixelSize
    globals.setCloneSprite = "triangle_yh"
    createClone()
  }

function analyzeTriangle(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number,
) {
  const length_p1p2 = distance({ x: x1, y: y1 }, { x: x2, y: y2 })
  const length_p2p3 = distance({ x: x2, y: y2 }, { x: x3, y: y3 })
  const length_p3p1 = distance({ x: x3, y: y3 }, { x: x1, y: y1 })


  let hypSideP = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }
  let kathl1   = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }
  let kathl2   = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }
  let rightPoint = { x: 0, y: 0 }
  let ahypAngle = 90
  let diff      = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }

  // Hypotenuse + Katheten bestimmen
  if (length_p1p2 >= length_p2p3 && length_p1p2 >= length_p3p1) {
    hypSideP = { x1, y1, x2, y2, x3, y3 }
    rightPoint = { x: x3, y: y3 }
    const k1 = { x1: x2, y1: y2, x2: x3, y2: y3, x3, y3 }
    const k2 = { x1: x3, y1: y3, x2: x1, y2: y1, x3, y3 }
    kathl1 = length_p2p3 >= length_p3p1 ? k1 : k2
    kathl2 = length_p2p3 >= length_p3p1 ? k2 : k1
  } else if (length_p2p3 >= length_p1p2 && length_p2p3 >= length_p3p1) {
    hypSideP = { x1: x2, y1: y2, x2: x3, y2: y3, x3: x1, y3: y1 }
    rightPoint = { x: x1, y: y1 }
    const k1 = { x1: x1, y1: y1, x2: x2, y2: y2, x3, y3 }
    const k2 = { x1: x3, y1: y3, x2: x1, y2: y1, x3, y3 }
    kathl1 = length_p1p2 >= length_p3p1 ? k1 : k2
    kathl2 = length_p1p2 >= length_p3p1 ? k2 : k1
  } else {
    hypSideP = { x1: x3, y1: y3, x2: x1, y2: y1, x3: x2, y3: y2 }
    rightPoint = { x: x2, y: y2 }
    const k1 = { x1: x1, y1: y1, x2: x2, y2: y2, x3, y3 }
    const k2 = { x1: x2, y1: y2, x2: x3, y2: y3, x3, y3 }
    kathl1 = length_p1p2 >= length_p2p3 ? k1 : k2
    kathl2 = length_p1p2 >= length_p2p3 ? k2 : k1
  }

  // find the "different side" (diff)
let sideLengths = [
  { len: length_p1p2, pts: { x1, y1, x2, y2, x3, y3 } },
  { len: length_p2p3, pts: { x1: x2, y1: y2, x2: x3, y2: y3, x3: x1, y3: y1 } },
  { len: length_p3p1, pts: { x1: x3, y1: y3, x2: x1, y2: y1, x3: x2, y3: y2 } }
]

// find the two sides that are closest in length
sideLengths.sort((a, b) => a.len - b.len)

const diffSide = (() => {
  const d1 = Math.abs(sideLengths[1].len - sideLengths[0].len)
  const d2 = Math.abs(sideLengths[2].len - sideLengths[1].len)
  const d3 = Math.abs(sideLengths[2].len - sideLengths[0].len)

  if (d1 < d2 && d1 < d3) return sideLengths[2].pts
  if (d2 < d1 && d2 < d3) return sideLengths[0].pts
  return sideLengths[1].pts
})()

diff = diffSide


  return {
    hypSideP,
    kathl1,
    kathl2,
    rightPoint,
    ahypAngle,
    diff,
    length_p1p2,
    length_p2p3,
    length_p3p1
  }
}






  /*
    //sprite.setCostume("triangle_yh_r")
    sprite.setCostume("triangle_yh_r")
    wait(0)
    createClone()
    
    sprite.x = angleX
    sprite.y = angleY
    sprite.tint = 0x00aaff
    //sprite.setCostume("triangle_yh_r")
    sprite.setCostume("square_yh")
    sprite.width = 3
    sprite.height =80
    sprite.rotation = aHypAngle / 2 - 90
    wait(0)
    createClone()

    sprite.x = interP.x
    sprite.y = interP.y
    sprite.tint = 0xff00f0
    //sprite.setCostume("triangle_yh_r")
    sprite.setCostume("square_yh")
    sprite.width = 5
    sprite.height = 5
    sprite.rotation = 0
    wait(0)
    createClone()
    sprite.tint = 0xff0000
    drawLine(interP.x, interP.y, angleX, angleY, 5)*/

  function intersectPoint(
    p: { x: number; y: number },
    angle: number,
    a: { x: number; y: number },
    b: { x: number; y: number },
  ) {
    angle += 90
    const dx1 = b.x - a.x
    const dy1 = b.y - a.y
    const dx2 = Math.sin(angle)
    const dy2 = Math.cos(angle)

    const det = dx2 * dy1 - dy2 * dx1
    if (Math.abs(det) < 1e-10) {
      console.log("PARALLEL")
      Game.stop()
    }

    const s = ((a.x - p.x) * dy1 - (a.y - p.y) * dx1) / det

    const ix = p.x + s * dx2
    const iy = p.y + s * dy2

    return { x: ix, y: iy }
  }
  function normalizeTriangle(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    x3: number,
    y3: number,
  ) {
    let orientation = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)
    if (orientation < 0) {
      let tx = x2
      let ty = y2
      x2 = x3
      y2 = y3
      x3 = tx
      y3 = ty
    }

    let o1 = (x1 + y1) / 2
    let o2 = (x2 + y2) / 2
    let o3 = (x3 + y3) / 2

    if (o1 > o2) {
      let tx = x1
      let ty = y1
      let to = o1
      x1 = x2
      y1 = y2
      o1 = o2
      x2 = tx
      y2 = ty
      o2 = to
    }

    if (o2 > o3) {
      let tx = x2
      let ty = y2
      let to = o2
      x2 = x3
      y2 = y3
      o2 = o3
      x3 = tx
      y3 = ty
      o3 = to
      if (o1 > o2) {
        let tx = x1
        let ty = y1
        let to = o1
        x1 = x2
        y1 = y2
        o1 = o2
        x2 = tx
        y2 = ty
        o2 = to
      }
    }

    return { x1, y1, x2, y2, x3, y3 }
  }

  function getRightAngleVertex(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    x3: number,
    y3: number,
    toleranceT: number = 1e-6,
  ): { x: number; y: number } | null {
    // Winkel bei P1 prüfen
    const dot1 = (x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1)
    if (Math.abs(dot1) < toleranceT) return { x: x1, y: y1 }

    // Winkel bei P2 prüfen
    const dot2 = (x1 - x2) * (x3 - x2) + (y1 - y2) * (y3 - y2)
    if (Math.abs(dot2) < toleranceT) return { x: x2, y: y2 }

    // Winkel bei P3 prüfen
    const dot3 = (x1 - x3) * (x2 - x3) + (y1 - y3) * (y2 - y3)
    if (Math.abs(dot3) < toleranceT) return { x: x3, y: y3 }

    // Kein rechter Winkel
    return null
  }
}

function drawLine(x1: number, y1: number, x2: number, y2: number, t: number) {
  const p1 = { x: x1, y: y1 }
  const p2 = { x: x2, y: y2 }

  sprite.x = (p1.x + p2.x) / 2
  sprite.y = (p1.y + p2.y) / 2
  sprite.rotation = angleBetween(p1, p2)
  sprite.height = distance(p1, p2) * yPixelSize
  sprite.width = xPixelSize * t
  globals.setCloneSprite = "square_yh"
  createClone()
}

function drawDot(x1: number, y1: number, t: number, c: number) {
  const p1 = { x: x1, y: y1 }
  sprite.tint = c
  sprite.x = x1
  sprite.y = y1
  sprite.height = t * yPixelSize
  sprite.width = xPixelSize * t
  globals.setCloneSprite = "square_yh"
  createClone()
}

function isHypSide(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  hypSideP: any,
) {
  return (
    hypSideP.x1 === x1 &&
    hypSideP.y1 === y1 &&
    hypSideP.x2 === x2 &&
    hypSideP.y2 === y2
  )
}

function getHypAngle(side1: number, side2: number, hyp: number): number {
  return Math.acos((side1 ** 2 + side2 ** 2 - hyp ** 2) / (2 * side1 * side2))
}

function angleBetween(p1: any, p2: any): number {
  const dx = p2.x - p1.x
  const dy = p2.y - p1.y
  return Math.atan2(dx, dy)
}

function distance(p1: any, p2: any): number {
  const dx = p2.x - p1.x
  const dy = p2.y - p1.y
  return Math.sqrt(dx * dx + dy * dy)
}
//NOT WORKINF
